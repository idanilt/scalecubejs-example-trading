// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function(modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})(
  {
    '../../../node_modules/core-js/internals/global.js': [
      function(require, module, exports) {
        var global = arguments[3];
        var check = function(it) {
          return it && it.Math == Math && it;
        };

        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        module.exports =
          // eslint-disable-next-line no-undef
          check(typeof globalThis == 'object' && globalThis) ||
          check(typeof window == 'object' && window) ||
          check(typeof self == 'object' && self) ||
          check(typeof global == 'object' && global) ||
          // eslint-disable-next-line no-new-func
          Function('return this')();
      },
      {},
    ],
    '../../../node_modules/core-js/internals/fails.js': [
      function(require, module, exports) {
        module.exports = function(exec) {
          try {
            return !!exec();
          } catch (error) {
            return true;
          }
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/descriptors.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');

        // Thank's IE8 for his funny defineProperty
        module.exports = !fails(function() {
          return (
            Object.defineProperty({}, 1, {
              get: function() {
                return 7;
              },
            })[1] != 7
          );
        });
      },
      { '../internals/fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/internals/object-property-is-enumerable.js': [
      function(require, module, exports) {
        'use strict';
        var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
        var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

        // Nashorn ~ JDK8 bug
        var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

        // `Object.prototype.propertyIsEnumerable` method implementation
        // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
        exports.f = NASHORN_BUG
          ? function propertyIsEnumerable(V) {
              var descriptor = getOwnPropertyDescriptor(this, V);
              return !!descriptor && descriptor.enumerable;
            }
          : nativePropertyIsEnumerable;
      },
      {},
    ],
    '../../../node_modules/core-js/internals/create-property-descriptor.js': [
      function(require, module, exports) {
        module.exports = function(bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value,
          };
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/classof-raw.js': [
      function(require, module, exports) {
        var toString = {}.toString;

        module.exports = function(it) {
          return toString.call(it).slice(8, -1);
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/indexed-object.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');
        var classof = require('../internals/classof-raw');

        var split = ''.split;

        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        module.exports = fails(function() {
          // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
          // eslint-disable-next-line no-prototype-builtins
          return !Object('z').propertyIsEnumerable(0);
        })
          ? function(it) {
              return classof(it) == 'String' ? split.call(it, '') : Object(it);
            }
          : Object;
      },
      {
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
      },
    ],
    '../../../node_modules/core-js/internals/require-object-coercible.js': [
      function(require, module, exports) {
        // `RequireObjectCoercible` abstract operation
        // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
        module.exports = function(it) {
          if (it == undefined) throw TypeError("Can't call method on " + it);
          return it;
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/to-indexed-object.js': [
      function(require, module, exports) {
        // toObject with fallback for non-array-like ES3 strings
        var IndexedObject = require('../internals/indexed-object');
        var requireObjectCoercible = require('../internals/require-object-coercible');

        module.exports = function(it) {
          return IndexedObject(requireObjectCoercible(it));
        };
      },
      {
        '../internals/indexed-object': '../../../node_modules/core-js/internals/indexed-object.js',
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
      },
    ],
    '../../../node_modules/core-js/internals/is-object.js': [
      function(require, module, exports) {
        module.exports = function(it) {
          return typeof it === 'object' ? it !== null : typeof it === 'function';
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/to-primitive.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');

        // `ToPrimitive` abstract operation
        // https://tc39.github.io/ecma262/#sec-toprimitive
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function(input, PREFERRED_STRING) {
          if (!isObject(input)) return input;
          var fn, val;
          if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject((val = fn.call(input))))
            return val;
          if (typeof (fn = input.valueOf) == 'function' && !isObject((val = fn.call(input)))) return val;
          if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject((val = fn.call(input))))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      },
      { '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js' },
    ],
    '../../../node_modules/core-js/internals/has.js': [
      function(require, module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;

        module.exports = function(it, key) {
          return hasOwnProperty.call(it, key);
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/document-create-element.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var isObject = require('../internals/is-object');

        var document = global.document;
        // typeof document.createElement is 'object' in old IE
        var EXISTS = isObject(document) && isObject(document.createElement);

        module.exports = function(it) {
          return EXISTS ? document.createElement(it) : {};
        };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
      },
    ],
    '../../../node_modules/core-js/internals/ie8-dom-define.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var fails = require('../internals/fails');
        var createElement = require('../internals/document-create-element');

        // Thank's IE8 for his funny defineProperty
        module.exports =
          !DESCRIPTORS &&
          !fails(function() {
            return (
              Object.defineProperty(createElement('div'), 'a', {
                get: function() {
                  return 7;
                },
              }).a != 7
            );
          });
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/document-create-element': '../../../node_modules/core-js/internals/document-create-element.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
        var createPropertyDescriptor = require('../internals/create-property-descriptor');
        var toIndexedObject = require('../internals/to-indexed-object');
        var toPrimitive = require('../internals/to-primitive');
        var has = require('../internals/has');
        var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');

        var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
        exports.f = DESCRIPTORS
          ? nativeGetOwnPropertyDescriptor
          : function getOwnPropertyDescriptor(O, P) {
              O = toIndexedObject(O);
              P = toPrimitive(P, true);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeGetOwnPropertyDescriptor(O, P);
                } catch (error) {
                  /* empty */
                }
              if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
            };
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/object-property-is-enumerable':
          '../../../node_modules/core-js/internals/object-property-is-enumerable.js',
        '../internals/create-property-descriptor':
          '../../../node_modules/core-js/internals/create-property-descriptor.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/to-primitive': '../../../node_modules/core-js/internals/to-primitive.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/ie8-dom-define': '../../../node_modules/core-js/internals/ie8-dom-define.js',
      },
    ],
    '../../../node_modules/core-js/internals/an-object.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');

        module.exports = function(it) {
          if (!isObject(it)) {
            throw TypeError(String(it) + ' is not an object');
          }
          return it;
        };
      },
      { '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js' },
    ],
    '../../../node_modules/core-js/internals/object-define-property.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
        var anObject = require('../internals/an-object');
        var toPrimitive = require('../internals/to-primitive');

        var nativeDefineProperty = Object.defineProperty;

        // `Object.defineProperty` method
        // https://tc39.github.io/ecma262/#sec-object.defineproperty
        exports.f = DESCRIPTORS
          ? nativeDefineProperty
          : function defineProperty(O, P, Attributes) {
              anObject(O);
              P = toPrimitive(P, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeDefineProperty(O, P, Attributes);
                } catch (error) {
                  /* empty */
                }
              if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
              if ('value' in Attributes) O[P] = Attributes.value;
              return O;
            };
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/ie8-dom-define': '../../../node_modules/core-js/internals/ie8-dom-define.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/to-primitive': '../../../node_modules/core-js/internals/to-primitive.js',
      },
    ],
    '../../../node_modules/core-js/internals/create-non-enumerable-property.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var definePropertyModule = require('../internals/object-define-property');
        var createPropertyDescriptor = require('../internals/create-property-descriptor');

        module.exports = DESCRIPTORS
          ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            }
          : function(object, key, value) {
              object[key] = value;
              return object;
            };
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/create-property-descriptor':
          '../../../node_modules/core-js/internals/create-property-descriptor.js',
      },
    ],
    '../../../node_modules/core-js/internals/set-global.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

        module.exports = function(key, value) {
          try {
            createNonEnumerableProperty(global, key, value);
          } catch (error) {
            global[key] = value;
          }
          return value;
        };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
      },
    ],
    '../../../node_modules/core-js/internals/shared-store.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var setGlobal = require('../internals/set-global');

        var SHARED = '__core-js_shared__';
        var store = global[SHARED] || setGlobal(SHARED, {});

        module.exports = store;
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/set-global': '../../../node_modules/core-js/internals/set-global.js',
      },
    ],
    '../../../node_modules/core-js/internals/inspect-source.js': [
      function(require, module, exports) {
        var store = require('../internals/shared-store');

        var functionToString = Function.toString;

        // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
        if (typeof store.inspectSource != 'function') {
          store.inspectSource = function(it) {
            return functionToString.call(it);
          };
        }

        module.exports = store.inspectSource;
      },
      { '../internals/shared-store': '../../../node_modules/core-js/internals/shared-store.js' },
    ],
    '../../../node_modules/core-js/internals/native-weak-map.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var inspectSource = require('../internals/inspect-source');

        var WeakMap = global.WeakMap;

        module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/inspect-source': '../../../node_modules/core-js/internals/inspect-source.js',
      },
    ],
    '../../../node_modules/core-js/internals/is-pure.js': [
      function(require, module, exports) {
        module.exports = false;
      },
      {},
    ],
    '../../../node_modules/core-js/internals/shared.js': [
      function(require, module, exports) {
        var IS_PURE = require('../internals/is-pure');
        var store = require('../internals/shared-store');

        (module.exports = function(key, value) {
          return store[key] || (store[key] = value !== undefined ? value : {});
        })('versions', []).push({
          version: '3.6.4',
          mode: IS_PURE ? 'pure' : 'global',
          copyright: '© 2020 Denis Pushkarev (zloirock.ru)',
        });
      },
      {
        '../internals/is-pure': '../../../node_modules/core-js/internals/is-pure.js',
        '../internals/shared-store': '../../../node_modules/core-js/internals/shared-store.js',
      },
    ],
    '../../../node_modules/core-js/internals/uid.js': [
      function(require, module, exports) {
        var id = 0;
        var postfix = Math.random();

        module.exports = function(key) {
          return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/shared-key.js': [
      function(require, module, exports) {
        var shared = require('../internals/shared');
        var uid = require('../internals/uid');

        var keys = shared('keys');

        module.exports = function(key) {
          return keys[key] || (keys[key] = uid(key));
        };
      },
      {
        '../internals/shared': '../../../node_modules/core-js/internals/shared.js',
        '../internals/uid': '../../../node_modules/core-js/internals/uid.js',
      },
    ],
    '../../../node_modules/core-js/internals/hidden-keys.js': [
      function(require, module, exports) {
        module.exports = {};
      },
      {},
    ],
    '../../../node_modules/core-js/internals/internal-state.js': [
      function(require, module, exports) {
        var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
        var global = require('../internals/global');
        var isObject = require('../internals/is-object');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var objectHas = require('../internals/has');
        var sharedKey = require('../internals/shared-key');
        var hiddenKeys = require('../internals/hidden-keys');

        var WeakMap = global.WeakMap;
        var set, get, has;

        var enforce = function(it) {
          return has(it) ? get(it) : set(it, {});
        };

        var getterFor = function(TYPE) {
          return function(it) {
            var state;
            if (!isObject(it) || (state = get(it)).type !== TYPE) {
              throw TypeError('Incompatible receiver, ' + TYPE + ' required');
            }
            return state;
          };
        };

        if (NATIVE_WEAK_MAP) {
          var store = new WeakMap();
          var wmget = store.get;
          var wmhas = store.has;
          var wmset = store.set;
          set = function(it, metadata) {
            wmset.call(store, it, metadata);
            return metadata;
          };
          get = function(it) {
            return wmget.call(store, it) || {};
          };
          has = function(it) {
            return wmhas.call(store, it);
          };
        } else {
          var STATE = sharedKey('state');
          hiddenKeys[STATE] = true;
          set = function(it, metadata) {
            createNonEnumerableProperty(it, STATE, metadata);
            return metadata;
          };
          get = function(it) {
            return objectHas(it, STATE) ? it[STATE] : {};
          };
          has = function(it) {
            return objectHas(it, STATE);
          };
        }

        module.exports = {
          set: set,
          get: get,
          has: has,
          enforce: enforce,
          getterFor: getterFor,
        };
      },
      {
        '../internals/native-weak-map': '../../../node_modules/core-js/internals/native-weak-map.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/shared-key': '../../../node_modules/core-js/internals/shared-key.js',
        '../internals/hidden-keys': '../../../node_modules/core-js/internals/hidden-keys.js',
      },
    ],
    '../../../node_modules/core-js/internals/redefine.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var has = require('../internals/has');
        var setGlobal = require('../internals/set-global');
        var inspectSource = require('../internals/inspect-source');
        var InternalStateModule = require('../internals/internal-state');

        var getInternalState = InternalStateModule.get;
        var enforceInternalState = InternalStateModule.enforce;
        var TEMPLATE = String(String).split('String');

        (module.exports = function(O, key, value, options) {
          var unsafe = options ? !!options.unsafe : false;
          var simple = options ? !!options.enumerable : false;
          var noTargetGet = options ? !!options.noTargetGet : false;
          if (typeof value == 'function') {
            if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
            enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
          }
          if (O === global) {
            if (simple) O[key] = value;
            else setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O[key];
          } else if (!noTargetGet && O[key]) {
            simple = true;
          }
          if (simple) O[key] = value;
          else createNonEnumerableProperty(O, key, value);
          // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
        })(Function.prototype, 'toString', function toString() {
          return (typeof this == 'function' && getInternalState(this).source) || inspectSource(this);
        });
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/set-global': '../../../node_modules/core-js/internals/set-global.js',
        '../internals/inspect-source': '../../../node_modules/core-js/internals/inspect-source.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
      },
    ],
    '../../../node_modules/core-js/internals/path.js': [
      function(require, module, exports) {
        var global = require('../internals/global');

        module.exports = global;
      },
      { '../internals/global': '../../../node_modules/core-js/internals/global.js' },
    ],
    '../../../node_modules/core-js/internals/get-built-in.js': [
      function(require, module, exports) {
        var path = require('../internals/path');
        var global = require('../internals/global');

        var aFunction = function(variable) {
          return typeof variable == 'function' ? variable : undefined;
        };

        module.exports = function(namespace, method) {
          return arguments.length < 2
            ? aFunction(path[namespace]) || aFunction(global[namespace])
            : (path[namespace] && path[namespace][method]) || (global[namespace] && global[namespace][method]);
        };
      },
      {
        '../internals/path': '../../../node_modules/core-js/internals/path.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
      },
    ],
    '../../../node_modules/core-js/internals/to-integer.js': [
      function(require, module, exports) {
        var ceil = Math.ceil;
        var floor = Math.floor;

        // `ToInteger` abstract operation
        // https://tc39.github.io/ecma262/#sec-tointeger
        module.exports = function(argument) {
          return isNaN((argument = +argument)) ? 0 : (argument > 0 ? floor : ceil)(argument);
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/to-length.js': [
      function(require, module, exports) {
        var toInteger = require('../internals/to-integer');

        var min = Math.min;

        // `ToLength` abstract operation
        // https://tc39.github.io/ecma262/#sec-tolength
        module.exports = function(argument) {
          return argument > 0 ? min(toInteger(argument), 0x1fffffffffffff) : 0; // 2 ** 53 - 1 == 9007199254740991
        };
      },
      { '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js' },
    ],
    '../../../node_modules/core-js/internals/to-absolute-index.js': [
      function(require, module, exports) {
        var toInteger = require('../internals/to-integer');

        var max = Math.max;
        var min = Math.min;

        // Helper for a popular repeating case of the spec:
        // Let integer be ? ToInteger(index).
        // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
        module.exports = function(index, length) {
          var integer = toInteger(index);
          return integer < 0 ? max(integer + length, 0) : min(integer, length);
        };
      },
      { '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js' },
    ],
    '../../../node_modules/core-js/internals/array-includes.js': [
      function(require, module, exports) {
        var toIndexedObject = require('../internals/to-indexed-object');
        var toLength = require('../internals/to-length');
        var toAbsoluteIndex = require('../internals/to-absolute-index');

        // `Array.prototype.{ indexOf, includes }` methods implementation
        var createMethod = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIndexedObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare
            if (IS_INCLUDES && el != el)
              while (length > index) {
                value = O[index++];
                // eslint-disable-next-line no-self-compare
                if (value != value) return true;
                // Array#indexOf ignores holes, Array#includes - not
              }
            else
              for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
              }
            return !IS_INCLUDES && -1;
          };
        };

        module.exports = {
          // `Array.prototype.includes` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.includes
          includes: createMethod(true),
          // `Array.prototype.indexOf` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
          indexOf: createMethod(false),
        };
      },
      {
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-absolute-index': '../../../node_modules/core-js/internals/to-absolute-index.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-keys-internal.js': [
      function(require, module, exports) {
        var has = require('../internals/has');
        var toIndexedObject = require('../internals/to-indexed-object');
        var indexOf = require('../internals/array-includes').indexOf;
        var hiddenKeys = require('../internals/hidden-keys');

        module.exports = function(object, names) {
          var O = toIndexedObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
          // Don't enum bug & hidden keys
          while (names.length > i)
            if (has(O, (key = names[i++]))) {
              ~indexOf(result, key) || result.push(key);
            }
          return result;
        };
      },
      {
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/array-includes': '../../../node_modules/core-js/internals/array-includes.js',
        '../internals/hidden-keys': '../../../node_modules/core-js/internals/hidden-keys.js',
      },
    ],
    '../../../node_modules/core-js/internals/enum-bug-keys.js': [
      function(require, module, exports) {
        // IE8- don't enum bug keys
        module.exports = [
          'constructor',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'toLocaleString',
          'toString',
          'valueOf',
        ];
      },
      {},
    ],
    '../../../node_modules/core-js/internals/object-get-own-property-names.js': [
      function(require, module, exports) {
        var internalObjectKeys = require('../internals/object-keys-internal');
        var enumBugKeys = require('../internals/enum-bug-keys');

        var hiddenKeys = enumBugKeys.concat('length', 'prototype');

        // `Object.getOwnPropertyNames` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
        exports.f =
          Object.getOwnPropertyNames ||
          function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
      },
      {
        '../internals/object-keys-internal': '../../../node_modules/core-js/internals/object-keys-internal.js',
        '../internals/enum-bug-keys': '../../../node_modules/core-js/internals/enum-bug-keys.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-get-own-property-symbols.js': [
      function(require, module, exports) {
        exports.f = Object.getOwnPropertySymbols;
      },
      {},
    ],
    '../../../node_modules/core-js/internals/own-keys.js': [
      function(require, module, exports) {
        var getBuiltIn = require('../internals/get-built-in');
        var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
        var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
        var anObject = require('../internals/an-object');

        // all object keys, includes non-enumerable and symbols
        module.exports =
          getBuiltIn('Reflect', 'ownKeys') ||
          function ownKeys(it) {
            var keys = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
          };
      },
      {
        '../internals/get-built-in': '../../../node_modules/core-js/internals/get-built-in.js',
        '../internals/object-get-own-property-names':
          '../../../node_modules/core-js/internals/object-get-own-property-names.js',
        '../internals/object-get-own-property-symbols':
          '../../../node_modules/core-js/internals/object-get-own-property-symbols.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
      },
    ],
    '../../../node_modules/core-js/internals/copy-constructor-properties.js': [
      function(require, module, exports) {
        var has = require('../internals/has');
        var ownKeys = require('../internals/own-keys');
        var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
        var definePropertyModule = require('../internals/object-define-property');

        module.exports = function(target, source) {
          var keys = ownKeys(source);
          var defineProperty = definePropertyModule.f;
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        };
      },
      {
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/own-keys': '../../../node_modules/core-js/internals/own-keys.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
      },
    ],
    '../../../node_modules/core-js/internals/is-forced.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');

        var replacement = /#|\.prototype\./;

        var isForced = function(feature, detection) {
          var value = data[normalize(feature)];
          return value == POLYFILL
            ? true
            : value == NATIVE
            ? false
            : typeof detection == 'function'
            ? fails(detection)
            : !!detection;
        };

        var normalize = (isForced.normalize = function(string) {
          return String(string)
            .replace(replacement, '.')
            .toLowerCase();
        });

        var data = (isForced.data = {});
        var NATIVE = (isForced.NATIVE = 'N');
        var POLYFILL = (isForced.POLYFILL = 'P');

        module.exports = isForced;
      },
      { '../internals/fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/internals/export.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var redefine = require('../internals/redefine');
        var setGlobal = require('../internals/set-global');
        var copyConstructorProperties = require('../internals/copy-constructor-properties');
        var isForced = require('../internals/is-forced');

        /*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
        module.exports = function(options, source) {
          var TARGET = options.target;
          var GLOBAL = options.global;
          var STATIC = options.stat;
          var FORCED, target, key, targetProperty, sourceProperty, descriptor;
          if (GLOBAL) {
            target = global;
          } else if (STATIC) {
            target = global[TARGET] || setGlobal(TARGET, {});
          } else {
            target = (global[TARGET] || {}).prototype;
          }
          if (target)
            for (key in source) {
              sourceProperty = source[key];
              if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
              // contained in target
              if (!FORCED && targetProperty !== undefined) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              // add a flag to not completely full polyfills
              if (options.sham || (targetProperty && targetProperty.sham)) {
                createNonEnumerableProperty(sourceProperty, 'sham', true);
              }
              // extend global
              redefine(target, key, sourceProperty, options);
            }
        };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/set-global': '../../../node_modules/core-js/internals/set-global.js',
        '../internals/copy-constructor-properties':
          '../../../node_modules/core-js/internals/copy-constructor-properties.js',
        '../internals/is-forced': '../../../node_modules/core-js/internals/is-forced.js',
      },
    ],
    '../../../node_modules/core-js/internals/native-symbol.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');

        module.exports =
          !!Object.getOwnPropertySymbols &&
          !fails(function() {
            // Chrome 38 Symbol has incorrect toString conversion
            // eslint-disable-next-line no-undef
            return !String(Symbol());
          });
      },
      { '../internals/fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/internals/use-symbol-as-uid.js': [
      function(require, module, exports) {
        var NATIVE_SYMBOL = require('../internals/native-symbol');

        module.exports =
          NATIVE_SYMBOL &&
          // eslint-disable-next-line no-undef
          !Symbol.sham &&
          // eslint-disable-next-line no-undef
          typeof Symbol.iterator == 'symbol';
      },
      { '../internals/native-symbol': '../../../node_modules/core-js/internals/native-symbol.js' },
    ],
    '../../../node_modules/core-js/internals/is-array.js': [
      function(require, module, exports) {
        var classof = require('../internals/classof-raw');

        // `IsArray` abstract operation
        // https://tc39.github.io/ecma262/#sec-isarray
        module.exports =
          Array.isArray ||
          function isArray(arg) {
            return classof(arg) == 'Array';
          };
      },
      { '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js' },
    ],
    '../../../node_modules/core-js/internals/to-object.js': [
      function(require, module, exports) {
        var requireObjectCoercible = require('../internals/require-object-coercible');

        // `ToObject` abstract operation
        // https://tc39.github.io/ecma262/#sec-toobject
        module.exports = function(argument) {
          return Object(requireObjectCoercible(argument));
        };
      },
      {
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-keys.js': [
      function(require, module, exports) {
        var internalObjectKeys = require('../internals/object-keys-internal');
        var enumBugKeys = require('../internals/enum-bug-keys');

        // `Object.keys` method
        // https://tc39.github.io/ecma262/#sec-object.keys
        module.exports =
          Object.keys ||
          function keys(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
      },
      {
        '../internals/object-keys-internal': '../../../node_modules/core-js/internals/object-keys-internal.js',
        '../internals/enum-bug-keys': '../../../node_modules/core-js/internals/enum-bug-keys.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-define-properties.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var definePropertyModule = require('../internals/object-define-property');
        var anObject = require('../internals/an-object');
        var objectKeys = require('../internals/object-keys');

        // `Object.defineProperties` method
        // https://tc39.github.io/ecma262/#sec-object.defineproperties
        module.exports = DESCRIPTORS
          ? Object.defineProperties
          : function defineProperties(O, Properties) {
              anObject(O);
              var keys = objectKeys(Properties);
              var length = keys.length;
              var index = 0;
              var key;
              while (length > index) definePropertyModule.f(O, (key = keys[index++]), Properties[key]);
              return O;
            };
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/object-keys': '../../../node_modules/core-js/internals/object-keys.js',
      },
    ],
    '../../../node_modules/core-js/internals/html.js': [
      function(require, module, exports) {
        var getBuiltIn = require('../internals/get-built-in');

        module.exports = getBuiltIn('document', 'documentElement');
      },
      { '../internals/get-built-in': '../../../node_modules/core-js/internals/get-built-in.js' },
    ],
    '../../../node_modules/core-js/internals/object-create.js': [
      function(require, module, exports) {
        var anObject = require('../internals/an-object');
        var defineProperties = require('../internals/object-define-properties');
        var enumBugKeys = require('../internals/enum-bug-keys');
        var hiddenKeys = require('../internals/hidden-keys');
        var html = require('../internals/html');
        var documentCreateElement = require('../internals/document-create-element');
        var sharedKey = require('../internals/shared-key');

        var GT = '>';
        var LT = '<';
        var PROTOTYPE = 'prototype';
        var SCRIPT = 'script';
        var IE_PROTO = sharedKey('IE_PROTO');

        var EmptyConstructor = function() {
          /* empty */
        };

        var scriptTag = function(content) {
          return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
        };

        // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
        var NullProtoObjectViaActiveX = function(activeXDocument) {
          activeXDocument.write(scriptTag(''));
          activeXDocument.close();
          var temp = activeXDocument.parentWindow.Object;
          activeXDocument = null; // avoid memory leak
          return temp;
        };

        // Create object with fake `null` prototype: use iframe Object with cleared prototype
        var NullProtoObjectViaIFrame = function() {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = documentCreateElement('iframe');
          var JS = 'java' + SCRIPT + ':';
          var iframeDocument;
          iframe.style.display = 'none';
          html.appendChild(iframe);
          // https://github.com/zloirock/core-js/issues/475
          iframe.src = String(JS);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(scriptTag('document.F=Object'));
          iframeDocument.close();
          return iframeDocument.F;
        };

        // Check for document.domain and active x support
        // No need to use active x approach when document.domain is not set
        // see https://github.com/es-shims/es5-shim/issues/150
        // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
        // avoid IE GC bug
        var activeXDocument;
        var NullProtoObject = function() {
          try {
            /* global ActiveXObject */
            activeXDocument = document.domain && new ActiveXObject('htmlfile');
          } catch (error) {
            /* ignore */
          }
          NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
          var length = enumBugKeys.length;
          while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
          return NullProtoObject();
        };

        hiddenKeys[IE_PROTO] = true;

        // `Object.create` method
        // https://tc39.github.io/ecma262/#sec-object.create
        module.exports =
          Object.create ||
          function create(O, Properties) {
            var result;
            if (O !== null) {
              EmptyConstructor[PROTOTYPE] = anObject(O);
              result = new EmptyConstructor();
              EmptyConstructor[PROTOTYPE] = null;
              // add "__proto__" for Object.getPrototypeOf polyfill
              result[IE_PROTO] = O;
            } else result = NullProtoObject();
            return Properties === undefined ? result : defineProperties(result, Properties);
          };
      },
      {
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/object-define-properties': '../../../node_modules/core-js/internals/object-define-properties.js',
        '../internals/enum-bug-keys': '../../../node_modules/core-js/internals/enum-bug-keys.js',
        '../internals/hidden-keys': '../../../node_modules/core-js/internals/hidden-keys.js',
        '../internals/html': '../../../node_modules/core-js/internals/html.js',
        '../internals/document-create-element': '../../../node_modules/core-js/internals/document-create-element.js',
        '../internals/shared-key': '../../../node_modules/core-js/internals/shared-key.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-get-own-property-names-external.js': [
      function(require, module, exports) {
        var toIndexedObject = require('../internals/to-indexed-object');
        var nativeGetOwnPropertyNames = require('../internals/object-get-own-property-names').f;

        var toString = {}.toString;

        var windowNames =
          typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

        var getWindowNames = function(it) {
          try {
            return nativeGetOwnPropertyNames(it);
          } catch (error) {
            return windowNames.slice();
          }
        };

        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        module.exports.f = function getOwnPropertyNames(it) {
          return windowNames && toString.call(it) == '[object Window]'
            ? getWindowNames(it)
            : nativeGetOwnPropertyNames(toIndexedObject(it));
        };
      },
      {
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/object-get-own-property-names':
          '../../../node_modules/core-js/internals/object-get-own-property-names.js',
      },
    ],
    '../../../node_modules/core-js/internals/well-known-symbol.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var shared = require('../internals/shared');
        var has = require('../internals/has');
        var uid = require('../internals/uid');
        var NATIVE_SYMBOL = require('../internals/native-symbol');
        var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

        var WellKnownSymbolsStore = shared('wks');
        var Symbol = global.Symbol;
        var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : (Symbol && Symbol.withoutSetter) || uid;

        module.exports = function(name) {
          if (!has(WellKnownSymbolsStore, name)) {
            if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
            else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
          }
          return WellKnownSymbolsStore[name];
        };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/shared': '../../../node_modules/core-js/internals/shared.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/uid': '../../../node_modules/core-js/internals/uid.js',
        '../internals/native-symbol': '../../../node_modules/core-js/internals/native-symbol.js',
        '../internals/use-symbol-as-uid': '../../../node_modules/core-js/internals/use-symbol-as-uid.js',
      },
    ],
    '../../../node_modules/core-js/internals/well-known-symbol-wrapped.js': [
      function(require, module, exports) {
        var wellKnownSymbol = require('../internals/well-known-symbol');

        exports.f = wellKnownSymbol;
      },
      { '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js' },
    ],
    '../../../node_modules/core-js/internals/define-well-known-symbol.js': [
      function(require, module, exports) {
        var path = require('../internals/path');
        var has = require('../internals/has');
        var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
        var defineProperty = require('../internals/object-define-property').f;

        module.exports = function(NAME) {
          var Symbol = path.Symbol || (path.Symbol = {});
          if (!has(Symbol, NAME))
            defineProperty(Symbol, NAME, {
              value: wrappedWellKnownSymbolModule.f(NAME),
            });
        };
      },
      {
        '../internals/path': '../../../node_modules/core-js/internals/path.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/well-known-symbol-wrapped':
          '../../../node_modules/core-js/internals/well-known-symbol-wrapped.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
      },
    ],
    '../../../node_modules/core-js/internals/set-to-string-tag.js': [
      function(require, module, exports) {
        var defineProperty = require('../internals/object-define-property').f;
        var has = require('../internals/has');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var TO_STRING_TAG = wellKnownSymbol('toStringTag');

        module.exports = function(it, TAG, STATIC) {
          if (it && !has((it = STATIC ? it : it.prototype), TO_STRING_TAG)) {
            defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
          }
        };
      },
      {
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/a-function.js': [
      function(require, module, exports) {
        module.exports = function(it) {
          if (typeof it != 'function') {
            throw TypeError(String(it) + ' is not a function');
          }
          return it;
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/function-bind-context.js': [
      function(require, module, exports) {
        var aFunction = require('../internals/a-function');

        // optional / simple context binding
        module.exports = function(fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;
          switch (length) {
            case 0:
              return function() {
                return fn.call(that);
              };
            case 1:
              return function(a) {
                return fn.call(that, a);
              };
            case 2:
              return function(a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function(a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function(/* ...args */) {
            return fn.apply(that, arguments);
          };
        };
      },
      { '../internals/a-function': '../../../node_modules/core-js/internals/a-function.js' },
    ],
    '../../../node_modules/core-js/internals/array-species-create.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');
        var isArray = require('../internals/is-array');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var SPECIES = wellKnownSymbol('species');

        // `ArraySpeciesCreate` abstract operation
        // https://tc39.github.io/ecma262/#sec-arrayspeciescreate
        module.exports = function(originalArray, length) {
          var C;
          if (isArray(originalArray)) {
            C = originalArray.constructor;
            // cross-realm fallback
            if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
            else if (isObject(C)) {
              C = C[SPECIES];
              if (C === null) C = undefined;
            }
          }
          return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
        };
      },
      {
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/is-array': '../../../node_modules/core-js/internals/is-array.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-iteration.js': [
      function(require, module, exports) {
        var bind = require('../internals/function-bind-context');
        var IndexedObject = require('../internals/indexed-object');
        var toObject = require('../internals/to-object');
        var toLength = require('../internals/to-length');
        var arraySpeciesCreate = require('../internals/array-species-create');

        var push = [].push;

        // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
        var createMethod = function(TYPE) {
          var IS_MAP = TYPE == 1;
          var IS_FILTER = TYPE == 2;
          var IS_SOME = TYPE == 3;
          var IS_EVERY = TYPE == 4;
          var IS_FIND_INDEX = TYPE == 6;
          var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
          return function($this, callbackfn, that, specificCreate) {
            var O = toObject($this);
            var self = IndexedObject(O);
            var boundFunction = bind(callbackfn, that, 3);
            var length = toLength(self.length);
            var index = 0;
            var create = specificCreate || arraySpeciesCreate;
            var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
            var value, result;
            for (; length > index; index++)
              if (NO_HOLES || index in self) {
                value = self[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                  if (IS_MAP) target[index] = result;
                  // map
                  else if (result)
                    switch (TYPE) {
                      case 3:
                        return true; // some
                      case 5:
                        return value; // find
                      case 6:
                        return index; // findIndex
                      case 2:
                        push.call(target, value); // filter
                    }
                  else if (IS_EVERY) return false; // every
                }
              }
            return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
          };
        };

        module.exports = {
          // `Array.prototype.forEach` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
          forEach: createMethod(0),
          // `Array.prototype.map` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.map
          map: createMethod(1),
          // `Array.prototype.filter` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.filter
          filter: createMethod(2),
          // `Array.prototype.some` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.some
          some: createMethod(3),
          // `Array.prototype.every` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.every
          every: createMethod(4),
          // `Array.prototype.find` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.find
          find: createMethod(5),
          // `Array.prototype.findIndex` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
          findIndex: createMethod(6),
        };
      },
      {
        '../internals/function-bind-context': '../../../node_modules/core-js/internals/function-bind-context.js',
        '../internals/indexed-object': '../../../node_modules/core-js/internals/indexed-object.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/array-species-create': '../../../node_modules/core-js/internals/array-species-create.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.symbol.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var global = require('../internals/global');
        var getBuiltIn = require('../internals/get-built-in');
        var IS_PURE = require('../internals/is-pure');
        var DESCRIPTORS = require('../internals/descriptors');
        var NATIVE_SYMBOL = require('../internals/native-symbol');
        var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');
        var fails = require('../internals/fails');
        var has = require('../internals/has');
        var isArray = require('../internals/is-array');
        var isObject = require('../internals/is-object');
        var anObject = require('../internals/an-object');
        var toObject = require('../internals/to-object');
        var toIndexedObject = require('../internals/to-indexed-object');
        var toPrimitive = require('../internals/to-primitive');
        var createPropertyDescriptor = require('../internals/create-property-descriptor');
        var nativeObjectCreate = require('../internals/object-create');
        var objectKeys = require('../internals/object-keys');
        var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
        var getOwnPropertyNamesExternal = require('../internals/object-get-own-property-names-external');
        var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
        var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
        var definePropertyModule = require('../internals/object-define-property');
        var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var redefine = require('../internals/redefine');
        var shared = require('../internals/shared');
        var sharedKey = require('../internals/shared-key');
        var hiddenKeys = require('../internals/hidden-keys');
        var uid = require('../internals/uid');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
        var defineWellKnownSymbol = require('../internals/define-well-known-symbol');
        var setToStringTag = require('../internals/set-to-string-tag');
        var InternalStateModule = require('../internals/internal-state');
        var $forEach = require('../internals/array-iteration').forEach;

        var HIDDEN = sharedKey('hidden');
        var SYMBOL = 'Symbol';
        var PROTOTYPE = 'prototype';
        var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(SYMBOL);
        var ObjectPrototype = Object[PROTOTYPE];
        var $Symbol = global.Symbol;
        var $stringify = getBuiltIn('JSON', 'stringify');
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
        var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
        var AllSymbols = shared('symbols');
        var ObjectPrototypeSymbols = shared('op-symbols');
        var StringToSymbolRegistry = shared('string-to-symbol-registry');
        var SymbolToStringRegistry = shared('symbol-to-string-registry');
        var WellKnownSymbolsStore = shared('wks');
        var QObject = global.QObject;
        // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
        var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

        // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
        var setSymbolDescriptor =
          DESCRIPTORS &&
          fails(function() {
            return (
              nativeObjectCreate(
                nativeDefineProperty({}, 'a', {
                  get: function() {
                    return nativeDefineProperty(this, 'a', { value: 7 }).a;
                  },
                })
              ).a != 7
            );
          })
            ? function(O, P, Attributes) {
                var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
                if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
                nativeDefineProperty(O, P, Attributes);
                if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                  nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
                }
              }
            : nativeDefineProperty;

        var wrap = function(tag, description) {
          var symbol = (AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]));
          setInternalState(symbol, {
            type: SYMBOL,
            tag: tag,
            description: description,
          });
          if (!DESCRIPTORS) symbol.description = description;
          return symbol;
        };

        var isSymbol = USE_SYMBOL_AS_UID
          ? function(it) {
              return typeof it == 'symbol';
            }
          : function(it) {
              return Object(it) instanceof $Symbol;
            };

        var $defineProperty = function defineProperty(O, P, Attributes) {
          if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
          anObject(O);
          var key = toPrimitive(P, true);
          anObject(Attributes);
          if (has(AllSymbols, key)) {
            if (!Attributes.enumerable) {
              if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
              O[HIDDEN][key] = true;
            } else {
              if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
              Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
            }
            return setSymbolDescriptor(O, key, Attributes);
          }
          return nativeDefineProperty(O, key, Attributes);
        };

        var $defineProperties = function defineProperties(O, Properties) {
          anObject(O);
          var properties = toIndexedObject(Properties);
          var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
          $forEach(keys, function(key) {
            if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
          });
          return O;
        };

        var $create = function create(O, Properties) {
          return Properties === undefined
            ? nativeObjectCreate(O)
            : $defineProperties(nativeObjectCreate(O), Properties);
        };

        var $propertyIsEnumerable = function propertyIsEnumerable(V) {
          var P = toPrimitive(V, true);
          var enumerable = nativePropertyIsEnumerable.call(this, P);
          if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
          return enumerable || !has(this, P) || !has(AllSymbols, P) || (has(this, HIDDEN) && this[HIDDEN][P])
            ? enumerable
            : true;
        };

        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
          var it = toIndexedObject(O);
          var key = toPrimitive(P, true);
          if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
          var descriptor = nativeGetOwnPropertyDescriptor(it, key);
          if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
            descriptor.enumerable = true;
          }
          return descriptor;
        };

        var $getOwnPropertyNames = function getOwnPropertyNames(O) {
          var names = nativeGetOwnPropertyNames(toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
          });
          return result;
        };

        var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
          var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
          var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
          var result = [];
          $forEach(names, function(key) {
            if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
              result.push(AllSymbols[key]);
            }
          });
          return result;
        };

        // `Symbol` constructor
        // https://tc39.github.io/ecma262/#sec-symbol-constructor
        if (!NATIVE_SYMBOL) {
          $Symbol = function Symbol() {
            if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
            var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
            var tag = uid(description);
            var setter = function(value) {
              if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
              if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
              setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
            };
            if (DESCRIPTORS && USE_SETTER)
              setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
            return wrap(tag, description);
          };

          redefine($Symbol[PROTOTYPE], 'toString', function toString() {
            return getInternalState(this).tag;
          });

          redefine($Symbol, 'withoutSetter', function(description) {
            return wrap(uid(description), description);
          });

          propertyIsEnumerableModule.f = $propertyIsEnumerable;
          definePropertyModule.f = $defineProperty;
          getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
          getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
          getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

          wrappedWellKnownSymbolModule.f = function(name) {
            return wrap(wellKnownSymbol(name), name);
          };

          if (DESCRIPTORS) {
            // https://github.com/tc39/proposal-Symbol-description
            nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
              configurable: true,
              get: function description() {
                return getInternalState(this).description;
              },
            });
            if (!IS_PURE) {
              redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
            }
          }
        }

        $(
          { global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL },
          {
            Symbol: $Symbol,
          }
        );

        $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
          defineWellKnownSymbol(name);
        });

        $(
          { target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL },
          {
            // `Symbol.for` method
            // https://tc39.github.io/ecma262/#sec-symbol.for
            for: function(key) {
              var string = String(key);
              if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
              var symbol = $Symbol(string);
              StringToSymbolRegistry[string] = symbol;
              SymbolToStringRegistry[symbol] = string;
              return symbol;
            },
            // `Symbol.keyFor` method
            // https://tc39.github.io/ecma262/#sec-symbol.keyfor
            keyFor: function keyFor(sym) {
              if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
              if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
            },
            useSetter: function() {
              USE_SETTER = true;
            },
            useSimple: function() {
              USE_SETTER = false;
            },
          }
        );

        $(
          { target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS },
          {
            // `Object.create` method
            // https://tc39.github.io/ecma262/#sec-object.create
            create: $create,
            // `Object.defineProperty` method
            // https://tc39.github.io/ecma262/#sec-object.defineproperty
            defineProperty: $defineProperty,
            // `Object.defineProperties` method
            // https://tc39.github.io/ecma262/#sec-object.defineproperties
            defineProperties: $defineProperties,
            // `Object.getOwnPropertyDescriptor` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
          }
        );

        $(
          { target: 'Object', stat: true, forced: !NATIVE_SYMBOL },
          {
            // `Object.getOwnPropertyNames` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
            getOwnPropertyNames: $getOwnPropertyNames,
            // `Object.getOwnPropertySymbols` method
            // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
            getOwnPropertySymbols: $getOwnPropertySymbols,
          }
        );

        // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
        // https://bugs.chromium.org/p/v8/issues/detail?id=3443
        $(
          {
            target: 'Object',
            stat: true,
            forced: fails(function() {
              getOwnPropertySymbolsModule.f(1);
            }),
          },
          {
            getOwnPropertySymbols: function getOwnPropertySymbols(it) {
              return getOwnPropertySymbolsModule.f(toObject(it));
            },
          }
        );

        // `JSON.stringify` method behavior with symbols
        // https://tc39.github.io/ecma262/#sec-json.stringify
        if ($stringify) {
          var FORCED_JSON_STRINGIFY =
            !NATIVE_SYMBOL ||
            fails(function() {
              var symbol = $Symbol();
              // MS Edge converts symbol values to JSON as {}
              return (
                $stringify([symbol]) != '[null]' ||
                // WebKit converts symbol values to JSON as null
                $stringify({ a: symbol }) != '{}' ||
                // V8 throws on boxed symbols
                $stringify(Object(symbol)) != '{}'
              );
            });

          $(
            { target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY },
            {
              // eslint-disable-next-line no-unused-vars
              stringify: function stringify(it, replacer, space) {
                var args = [it];
                var index = 1;
                var $replacer;
                while (arguments.length > index) args.push(arguments[index++]);
                $replacer = replacer;
                if ((!isObject(replacer) && it === undefined) || isSymbol(it)) return; // IE8 returns string on undefined
                if (!isArray(replacer))
                  replacer = function(key, value) {
                    if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
                    if (!isSymbol(value)) return value;
                  };
                args[1] = replacer;
                return $stringify.apply(null, args);
              },
            }
          );
        }

        // `Symbol.prototype[@@toPrimitive]` method
        // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
        if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
          createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
        }
        // `Symbol.prototype[@@toStringTag]` property
        // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
        setToStringTag($Symbol, SYMBOL);

        hiddenKeys[HIDDEN] = true;
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/get-built-in': '../../../node_modules/core-js/internals/get-built-in.js',
        '../internals/is-pure': '../../../node_modules/core-js/internals/is-pure.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/native-symbol': '../../../node_modules/core-js/internals/native-symbol.js',
        '../internals/use-symbol-as-uid': '../../../node_modules/core-js/internals/use-symbol-as-uid.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/is-array': '../../../node_modules/core-js/internals/is-array.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/to-primitive': '../../../node_modules/core-js/internals/to-primitive.js',
        '../internals/create-property-descriptor':
          '../../../node_modules/core-js/internals/create-property-descriptor.js',
        '../internals/object-create': '../../../node_modules/core-js/internals/object-create.js',
        '../internals/object-keys': '../../../node_modules/core-js/internals/object-keys.js',
        '../internals/object-get-own-property-names':
          '../../../node_modules/core-js/internals/object-get-own-property-names.js',
        '../internals/object-get-own-property-names-external':
          '../../../node_modules/core-js/internals/object-get-own-property-names-external.js',
        '../internals/object-get-own-property-symbols':
          '../../../node_modules/core-js/internals/object-get-own-property-symbols.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/object-property-is-enumerable':
          '../../../node_modules/core-js/internals/object-property-is-enumerable.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/shared': '../../../node_modules/core-js/internals/shared.js',
        '../internals/shared-key': '../../../node_modules/core-js/internals/shared-key.js',
        '../internals/hidden-keys': '../../../node_modules/core-js/internals/hidden-keys.js',
        '../internals/uid': '../../../node_modules/core-js/internals/uid.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/well-known-symbol-wrapped':
          '../../../node_modules/core-js/internals/well-known-symbol-wrapped.js',
        '../internals/define-well-known-symbol': '../../../node_modules/core-js/internals/define-well-known-symbol.js',
        '../internals/set-to-string-tag': '../../../node_modules/core-js/internals/set-to-string-tag.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.symbol.description.js': [
      function(require, module, exports) {
        // `Symbol.prototype.description` getter
        // https://tc39.github.io/ecma262/#sec-symbol.prototype.description
        'use strict';
        var $ = require('../internals/export');
        var DESCRIPTORS = require('../internals/descriptors');
        var global = require('../internals/global');
        var has = require('../internals/has');
        var isObject = require('../internals/is-object');
        var defineProperty = require('../internals/object-define-property').f;
        var copyConstructorProperties = require('../internals/copy-constructor-properties');

        var NativeSymbol = global.Symbol;

        if (
          DESCRIPTORS &&
          typeof NativeSymbol == 'function' &&
          (!('description' in NativeSymbol.prototype) ||
            // Safari 12 bug
            NativeSymbol().description !== undefined)
        ) {
          var EmptyStringDescriptionStore = {};
          // wrap Symbol constructor for correct work with undefined description
          var SymbolWrapper = function Symbol() {
            var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
            var result =
              this instanceof SymbolWrapper
                ? new NativeSymbol(description)
                : // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
                description === undefined
                ? NativeSymbol()
                : NativeSymbol(description);
            if (description === '') EmptyStringDescriptionStore[result] = true;
            return result;
          };
          copyConstructorProperties(SymbolWrapper, NativeSymbol);
          var symbolPrototype = (SymbolWrapper.prototype = NativeSymbol.prototype);
          symbolPrototype.constructor = SymbolWrapper;

          var symbolToString = symbolPrototype.toString;
          var native = String(NativeSymbol('test')) == 'Symbol(test)';
          var regexp = /^Symbol\((.*)\)[^)]+$/;
          defineProperty(symbolPrototype, 'description', {
            configurable: true,
            get: function description() {
              var symbol = isObject(this) ? this.valueOf() : this;
              var string = symbolToString.call(symbol);
              if (has(EmptyStringDescriptionStore, symbol)) return '';
              var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
              return desc === '' ? undefined : desc;
            },
          });

          $(
            { global: true, forced: true },
            {
              Symbol: SymbolWrapper,
            }
          );
        }
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/copy-constructor-properties':
          '../../../node_modules/core-js/internals/copy-constructor-properties.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.symbol.async-iterator.js': [
      function(require, module, exports) {
        var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

        // `Symbol.asyncIterator` well-known symbol
        // https://tc39.github.io/ecma262/#sec-symbol.asynciterator
        defineWellKnownSymbol('asyncIterator');
      },
      {
        '../internals/define-well-known-symbol': '../../../node_modules/core-js/internals/define-well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.symbol.iterator.js': [
      function(require, module, exports) {
        var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

        // `Symbol.iterator` well-known symbol
        // https://tc39.github.io/ecma262/#sec-symbol.iterator
        defineWellKnownSymbol('iterator');
      },
      {
        '../internals/define-well-known-symbol': '../../../node_modules/core-js/internals/define-well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/create-property.js': [
      function(require, module, exports) {
        'use strict';
        var toPrimitive = require('../internals/to-primitive');
        var definePropertyModule = require('../internals/object-define-property');
        var createPropertyDescriptor = require('../internals/create-property-descriptor');

        module.exports = function(object, key, value) {
          var propertyKey = toPrimitive(key);
          if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
          else object[propertyKey] = value;
        };
      },
      {
        '../internals/to-primitive': '../../../node_modules/core-js/internals/to-primitive.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/create-property-descriptor':
          '../../../node_modules/core-js/internals/create-property-descriptor.js',
      },
    ],
    '../../../node_modules/core-js/internals/engine-user-agent.js': [
      function(require, module, exports) {
        var getBuiltIn = require('../internals/get-built-in');

        module.exports = getBuiltIn('navigator', 'userAgent') || '';
      },
      { '../internals/get-built-in': '../../../node_modules/core-js/internals/get-built-in.js' },
    ],
    '../../../node_modules/core-js/internals/engine-v8-version.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var userAgent = require('../internals/engine-user-agent');

        var process = global.process;
        var versions = process && process.versions;
        var v8 = versions && versions.v8;
        var match, version;

        if (v8) {
          match = v8.split('.');
          version = match[0] + match[1];
        } else if (userAgent) {
          match = userAgent.match(/Edge\/(\d+)/);
          if (!match || match[1] >= 74) {
            match = userAgent.match(/Chrome\/(\d+)/);
            if (match) version = match[1];
          }
        }

        module.exports = version && +version;
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/engine-user-agent': '../../../node_modules/core-js/internals/engine-user-agent.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-method-has-species-support.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var V8_VERSION = require('../internals/engine-v8-version');

        var SPECIES = wellKnownSymbol('species');

        module.exports = function(METHOD_NAME) {
          // We can't use this feature detection in V8 since it causes
          // deoptimization and serious performance degradation
          // https://github.com/zloirock/core-js/issues/677
          return (
            V8_VERSION >= 51 ||
            !fails(function() {
              var array = [];
              var constructor = (array.constructor = {});
              constructor[SPECIES] = function() {
                return { foo: 1 };
              };
              return array[METHOD_NAME](Boolean).foo !== 1;
            })
          );
        };
      },
      {
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/engine-v8-version': '../../../node_modules/core-js/internals/engine-v8-version.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.concat.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var fails = require('../internals/fails');
        var isArray = require('../internals/is-array');
        var isObject = require('../internals/is-object');
        var toObject = require('../internals/to-object');
        var toLength = require('../internals/to-length');
        var createProperty = require('../internals/create-property');
        var arraySpeciesCreate = require('../internals/array-species-create');
        var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var V8_VERSION = require('../internals/engine-v8-version');

        var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
        var MAX_SAFE_INTEGER = 0x1fffffffffffff;
        var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

        // We can't use this feature detection in V8 since it causes
        // deoptimization and serious performance degradation
        // https://github.com/zloirock/core-js/issues/679
        var IS_CONCAT_SPREADABLE_SUPPORT =
          V8_VERSION >= 51 ||
          !fails(function() {
            var array = [];
            array[IS_CONCAT_SPREADABLE] = false;
            return array.concat()[0] !== array;
          });

        var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

        var isConcatSpreadable = function(O) {
          if (!isObject(O)) return false;
          var spreadable = O[IS_CONCAT_SPREADABLE];
          return spreadable !== undefined ? !!spreadable : isArray(O);
        };

        var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

        // `Array.prototype.concat` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.concat
        // with adding support of @@isConcatSpreadable and @@species
        $(
          { target: 'Array', proto: true, forced: FORCED },
          {
            concat: function concat(arg) {
              // eslint-disable-line no-unused-vars
              var O = toObject(this);
              var A = arraySpeciesCreate(O, 0);
              var n = 0;
              var i, k, length, len, E;
              for (i = -1, length = arguments.length; i < length; i++) {
                E = i === -1 ? O : arguments[i];
                if (isConcatSpreadable(E)) {
                  len = toLength(E.length);
                  if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                  for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
                } else {
                  if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                  createProperty(A, n++, E);
                }
              }
              A.length = n;
              return A;
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/is-array': '../../../node_modules/core-js/internals/is-array.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/create-property': '../../../node_modules/core-js/internals/create-property.js',
        '../internals/array-species-create': '../../../node_modules/core-js/internals/array-species-create.js',
        '../internals/array-method-has-species-support':
          '../../../node_modules/core-js/internals/array-method-has-species-support.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/engine-v8-version': '../../../node_modules/core-js/internals/engine-v8-version.js',
      },
    ],
    '../../../node_modules/core-js/internals/add-to-unscopables.js': [
      function(require, module, exports) {
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var create = require('../internals/object-create');
        var definePropertyModule = require('../internals/object-define-property');

        var UNSCOPABLES = wellKnownSymbol('unscopables');
        var ArrayPrototype = Array.prototype;

        // Array.prototype[@@unscopables]
        // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
        if (ArrayPrototype[UNSCOPABLES] == undefined) {
          definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
            configurable: true,
            value: create(null),
          });
        }

        // add a key to Array.prototype[@@unscopables]
        module.exports = function(key) {
          ArrayPrototype[UNSCOPABLES][key] = true;
        };
      },
      {
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/object-create': '../../../node_modules/core-js/internals/object-create.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
      },
    ],
    '../../../node_modules/core-js/internals/iterators.js': [
      function(require, module, exports) {
        module.exports = {};
      },
      {},
    ],
    '../../../node_modules/core-js/internals/correct-prototype-getter.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');

        module.exports = !fails(function() {
          function F() {
            /* empty */
          }
          F.prototype.constructor = null;
          return Object.getPrototypeOf(new F()) !== F.prototype;
        });
      },
      { '../internals/fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/internals/object-get-prototype-of.js': [
      function(require, module, exports) {
        var has = require('../internals/has');
        var toObject = require('../internals/to-object');
        var sharedKey = require('../internals/shared-key');
        var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

        var IE_PROTO = sharedKey('IE_PROTO');
        var ObjectPrototype = Object.prototype;

        // `Object.getPrototypeOf` method
        // https://tc39.github.io/ecma262/#sec-object.getprototypeof
        module.exports = CORRECT_PROTOTYPE_GETTER
          ? Object.getPrototypeOf
          : function(O) {
              O = toObject(O);
              if (has(O, IE_PROTO)) return O[IE_PROTO];
              if (typeof O.constructor == 'function' && O instanceof O.constructor) {
                return O.constructor.prototype;
              }
              return O instanceof Object ? ObjectPrototype : null;
            };
      },
      {
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/shared-key': '../../../node_modules/core-js/internals/shared-key.js',
        '../internals/correct-prototype-getter': '../../../node_modules/core-js/internals/correct-prototype-getter.js',
      },
    ],
    '../../../node_modules/core-js/internals/iterators-core.js': [
      function(require, module, exports) {
        'use strict';
        var getPrototypeOf = require('../internals/object-get-prototype-of');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var has = require('../internals/has');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var IS_PURE = require('../internals/is-pure');

        var ITERATOR = wellKnownSymbol('iterator');
        var BUGGY_SAFARI_ITERATORS = false;

        var returnThis = function() {
          return this;
        };

        // `%IteratorPrototype%` object
        // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
        var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

        if ([].keys) {
          arrayIterator = [].keys();
          // Safari 8 has buggy iterators w/o `next`
          if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
          else {
            PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
            if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
              IteratorPrototype = PrototypeOfArrayIteratorPrototype;
          }
        }

        if (IteratorPrototype == undefined) IteratorPrototype = {};

        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
          createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
        }

        module.exports = {
          IteratorPrototype: IteratorPrototype,
          BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS,
        };
      },
      {
        '../internals/object-get-prototype-of': '../../../node_modules/core-js/internals/object-get-prototype-of.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/is-pure': '../../../node_modules/core-js/internals/is-pure.js',
      },
    ],
    '../../../node_modules/core-js/internals/create-iterator-constructor.js': [
      function(require, module, exports) {
        'use strict';
        var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
        var create = require('../internals/object-create');
        var createPropertyDescriptor = require('../internals/create-property-descriptor');
        var setToStringTag = require('../internals/set-to-string-tag');
        var Iterators = require('../internals/iterators');

        var returnThis = function() {
          return this;
        };

        module.exports = function(IteratorConstructor, NAME, next) {
          var TO_STRING_TAG = NAME + ' Iterator';
          IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
          setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
          Iterators[TO_STRING_TAG] = returnThis;
          return IteratorConstructor;
        };
      },
      {
        '../internals/iterators-core': '../../../node_modules/core-js/internals/iterators-core.js',
        '../internals/object-create': '../../../node_modules/core-js/internals/object-create.js',
        '../internals/create-property-descriptor':
          '../../../node_modules/core-js/internals/create-property-descriptor.js',
        '../internals/set-to-string-tag': '../../../node_modules/core-js/internals/set-to-string-tag.js',
        '../internals/iterators': '../../../node_modules/core-js/internals/iterators.js',
      },
    ],
    '../../../node_modules/core-js/internals/a-possible-prototype.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');

        module.exports = function(it) {
          if (!isObject(it) && it !== null) {
            throw TypeError("Can't set " + String(it) + ' as a prototype');
          }
          return it;
        };
      },
      { '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js' },
    ],
    '../../../node_modules/core-js/internals/object-set-prototype-of.js': [
      function(require, module, exports) {
        var anObject = require('../internals/an-object');
        var aPossiblePrototype = require('../internals/a-possible-prototype');

        // `Object.setPrototypeOf` method
        // https://tc39.github.io/ecma262/#sec-object.setprototypeof
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */
        module.exports =
          Object.setPrototypeOf ||
          ('__proto__' in {}
            ? (function() {
                var CORRECT_SETTER = false;
                var test = {};
                var setter;
                try {
                  setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
                  setter.call(test, []);
                  CORRECT_SETTER = test instanceof Array;
                } catch (error) {
                  /* empty */
                }
                return function setPrototypeOf(O, proto) {
                  anObject(O);
                  aPossiblePrototype(proto);
                  if (CORRECT_SETTER) setter.call(O, proto);
                  else O.__proto__ = proto;
                  return O;
                };
              })()
            : undefined);
      },
      {
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/a-possible-prototype': '../../../node_modules/core-js/internals/a-possible-prototype.js',
      },
    ],
    '../../../node_modules/core-js/internals/define-iterator.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var createIteratorConstructor = require('../internals/create-iterator-constructor');
        var getPrototypeOf = require('../internals/object-get-prototype-of');
        var setPrototypeOf = require('../internals/object-set-prototype-of');
        var setToStringTag = require('../internals/set-to-string-tag');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var redefine = require('../internals/redefine');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var IS_PURE = require('../internals/is-pure');
        var Iterators = require('../internals/iterators');
        var IteratorsCore = require('../internals/iterators-core');

        var IteratorPrototype = IteratorsCore.IteratorPrototype;
        var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
        var ITERATOR = wellKnownSymbol('iterator');
        var KEYS = 'keys';
        var VALUES = 'values';
        var ENTRIES = 'entries';

        var returnThis = function() {
          return this;
        };

        module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
          createIteratorConstructor(IteratorConstructor, NAME, next);

          var getIterationMethod = function(KIND) {
            if (KIND === DEFAULT && defaultIterator) return defaultIterator;
            if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
            switch (KIND) {
              case KEYS:
                return function keys() {
                  return new IteratorConstructor(this, KIND);
                };
              case VALUES:
                return function values() {
                  return new IteratorConstructor(this, KIND);
                };
              case ENTRIES:
                return function entries() {
                  return new IteratorConstructor(this, KIND);
                };
            }
            return function() {
              return new IteratorConstructor(this);
            };
          };

          var TO_STRING_TAG = NAME + ' Iterator';
          var INCORRECT_VALUES_NAME = false;
          var IterablePrototype = Iterable.prototype;
          var nativeIterator =
            IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || (DEFAULT && IterablePrototype[DEFAULT]);
          var defaultIterator = (!BUGGY_SAFARI_ITERATORS && nativeIterator) || getIterationMethod(DEFAULT);
          var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
          var CurrentIteratorPrototype, methods, KEY;

          // fix native
          if (anyNativeIterator) {
            CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
            if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
              if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf) {
                  setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
                  createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                }
              }
              // Set @@toStringTag to native iterators
              setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
              if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
            }
          }

          // fix Array#{values, @@iterator}.name in V8 / FF
          if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return nativeIterator.call(this);
            };
          }

          // define iterator
          if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
            createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
          }
          Iterators[NAME] = defaultIterator;

          // export additional methods
          if (DEFAULT) {
            methods = {
              values: getIterationMethod(VALUES),
              keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
              entries: getIterationMethod(ENTRIES),
            };
            if (FORCED)
              for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                  redefine(IterablePrototype, KEY, methods[KEY]);
                }
              }
            else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
          }

          return methods;
        };
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/create-iterator-constructor':
          '../../../node_modules/core-js/internals/create-iterator-constructor.js',
        '../internals/object-get-prototype-of': '../../../node_modules/core-js/internals/object-get-prototype-of.js',
        '../internals/object-set-prototype-of': '../../../node_modules/core-js/internals/object-set-prototype-of.js',
        '../internals/set-to-string-tag': '../../../node_modules/core-js/internals/set-to-string-tag.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/is-pure': '../../../node_modules/core-js/internals/is-pure.js',
        '../internals/iterators': '../../../node_modules/core-js/internals/iterators.js',
        '../internals/iterators-core': '../../../node_modules/core-js/internals/iterators-core.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.iterator.js': [
      function(require, module, exports) {
        'use strict';
        var toIndexedObject = require('../internals/to-indexed-object');
        var addToUnscopables = require('../internals/add-to-unscopables');
        var Iterators = require('../internals/iterators');
        var InternalStateModule = require('../internals/internal-state');
        var defineIterator = require('../internals/define-iterator');

        var ARRAY_ITERATOR = 'Array Iterator';
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

        // `Array.prototype.entries` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.entries
        // `Array.prototype.keys` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.keys
        // `Array.prototype.values` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.values
        // `Array.prototype[@@iterator]` method
        // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
        // `CreateArrayIterator` internal method
        // https://tc39.github.io/ecma262/#sec-createarrayiterator
        module.exports = defineIterator(
          Array,
          'Array',
          function(iterated, kind) {
            setInternalState(this, {
              type: ARRAY_ITERATOR,
              target: toIndexedObject(iterated), // target
              index: 0, // next index
              kind: kind, // kind
            });
            // `%ArrayIteratorPrototype%.next` method
            // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
          },
          function() {
            var state = getInternalState(this);
            var target = state.target;
            var kind = state.kind;
            var index = state.index++;
            if (!target || index >= target.length) {
              state.target = undefined;
              return { value: undefined, done: true };
            }
            if (kind == 'keys') return { value: index, done: false };
            if (kind == 'values') return { value: target[index], done: false };
            return { value: [index, target[index]], done: false };
          },
          'values'
        );

        // argumentsList[@@iterator] is %ArrayProto_values%
        // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
        // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
        Iterators.Arguments = Iterators.Array;

        // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
        addToUnscopables('keys');
        addToUnscopables('values');
        addToUnscopables('entries');
      },
      {
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/add-to-unscopables': '../../../node_modules/core-js/internals/add-to-unscopables.js',
        '../internals/iterators': '../../../node_modules/core-js/internals/iterators.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
        '../internals/define-iterator': '../../../node_modules/core-js/internals/define-iterator.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-assign.js': [
      function(require, module, exports) {
        'use strict';
        var DESCRIPTORS = require('../internals/descriptors');
        var fails = require('../internals/fails');
        var objectKeys = require('../internals/object-keys');
        var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
        var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
        var toObject = require('../internals/to-object');
        var IndexedObject = require('../internals/indexed-object');

        var nativeAssign = Object.assign;
        var defineProperty = Object.defineProperty;

        // `Object.assign` method
        // https://tc39.github.io/ecma262/#sec-object.assign
        module.exports =
          !nativeAssign ||
          fails(function() {
            // should have correct order of operations (Edge bug)
            if (
              DESCRIPTORS &&
              nativeAssign(
                { b: 1 },
                nativeAssign(
                  defineProperty({}, 'a', {
                    enumerable: true,
                    get: function() {
                      defineProperty(this, 'b', {
                        value: 3,
                        enumerable: false,
                      });
                    },
                  }),
                  { b: 2 }
                )
              ).b !== 1
            )
              return true;
            // should work with symbols and should have deterministic property order (V8 bug)
            var A = {};
            var B = {};
            // eslint-disable-next-line no-undef
            var symbol = Symbol();
            var alphabet = 'abcdefghijklmnopqrst';
            A[symbol] = 7;
            alphabet.split('').forEach(function(chr) {
              B[chr] = chr;
            });
            return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
          })
            ? function assign(target, source) {
                // eslint-disable-line no-unused-vars
                var T = toObject(target);
                var argumentsLength = arguments.length;
                var index = 1;
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                var propertyIsEnumerable = propertyIsEnumerableModule.f;
                while (argumentsLength > index) {
                  var S = IndexedObject(arguments[index++]);
                  var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
                  var length = keys.length;
                  var j = 0;
                  var key;
                  while (length > j) {
                    key = keys[j++];
                    if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
                  }
                }
                return T;
              }
            : nativeAssign;
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/object-keys': '../../../node_modules/core-js/internals/object-keys.js',
        '../internals/object-get-own-property-symbols':
          '../../../node_modules/core-js/internals/object-get-own-property-symbols.js',
        '../internals/object-property-is-enumerable':
          '../../../node_modules/core-js/internals/object-property-is-enumerable.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/indexed-object': '../../../node_modules/core-js/internals/indexed-object.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.object.assign.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var assign = require('../internals/object-assign');

        // `Object.assign` method
        // https://tc39.github.io/ecma262/#sec-object.assign
        $(
          { target: 'Object', stat: true, forced: Object.assign !== assign },
          {
            assign: assign,
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/object-assign': '../../../node_modules/core-js/internals/object-assign.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var fails = require('../internals/fails');
        var toIndexedObject = require('../internals/to-indexed-object');
        var nativeGetOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
        var DESCRIPTORS = require('../internals/descriptors');

        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeGetOwnPropertyDescriptor(1);
        });
        var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
        $(
          { target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS },
          {
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
              return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
      },
    ],
    '../../../node_modules/core-js/internals/to-string-tag-support.js': [
      function(require, module, exports) {
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        var test = {};

        test[TO_STRING_TAG] = 'z';

        module.exports = String(test) === '[object z]';
      },
      { '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js' },
    ],
    '../../../node_modules/core-js/internals/classof.js': [
      function(require, module, exports) {
        var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
        var classofRaw = require('../internals/classof-raw');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        // ES3 wrong here
        var CORRECT_ARGUMENTS =
          classofRaw(
            (function() {
              return arguments;
            })()
          ) == 'Arguments';

        // fallback for IE11 Script Access Denied error
        var tryGet = function(it, key) {
          try {
            return it[key];
          } catch (error) {
            /* empty */
          }
        };

        // getting tag from ES6+ `Object.prototype.toString`
        module.exports = TO_STRING_TAG_SUPPORT
          ? classofRaw
          : function(it) {
              var O, tag, result;
              return it === undefined
                ? 'Undefined'
                : it === null
                ? 'Null'
                : // @@toStringTag case
                typeof (tag = tryGet((O = Object(it)), TO_STRING_TAG)) == 'string'
                ? tag
                : // builtinTag case
                CORRECT_ARGUMENTS
                ? classofRaw(O)
                : // ES3 arguments fallback
                (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function'
                ? 'Arguments'
                : result;
            };
      },
      {
        '../internals/to-string-tag-support': '../../../node_modules/core-js/internals/to-string-tag-support.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-to-string.js': [
      function(require, module, exports) {
        'use strict';
        var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
        var classof = require('../internals/classof');

        // `Object.prototype.toString` method implementation
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
        module.exports = TO_STRING_TAG_SUPPORT
          ? {}.toString
          : function toString() {
              return '[object ' + classof(this) + ']';
            };
      },
      {
        '../internals/to-string-tag-support': '../../../node_modules/core-js/internals/to-string-tag-support.js',
        '../internals/classof': '../../../node_modules/core-js/internals/classof.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.object.to-string.js': [
      function(require, module, exports) {
        var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
        var redefine = require('../internals/redefine');
        var toString = require('../internals/object-to-string');

        // `Object.prototype.toString` method
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
        if (!TO_STRING_TAG_SUPPORT) {
          redefine(Object.prototype, 'toString', toString, { unsafe: true });
        }
      },
      {
        '../internals/to-string-tag-support': '../../../node_modules/core-js/internals/to-string-tag-support.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/object-to-string': '../../../node_modules/core-js/internals/object-to-string.js',
      },
    ],
    '../../../node_modules/core-js/internals/native-promise-constructor.js': [
      function(require, module, exports) {
        var global = require('../internals/global');

        module.exports = global.Promise;
      },
      { '../internals/global': '../../../node_modules/core-js/internals/global.js' },
    ],
    '../../../node_modules/core-js/internals/redefine-all.js': [
      function(require, module, exports) {
        var redefine = require('../internals/redefine');

        module.exports = function(target, src, options) {
          for (var key in src) redefine(target, key, src[key], options);
          return target;
        };
      },
      { '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js' },
    ],
    '../../../node_modules/core-js/internals/set-species.js': [
      function(require, module, exports) {
        'use strict';
        var getBuiltIn = require('../internals/get-built-in');
        var definePropertyModule = require('../internals/object-define-property');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var DESCRIPTORS = require('../internals/descriptors');

        var SPECIES = wellKnownSymbol('species');

        module.exports = function(CONSTRUCTOR_NAME) {
          var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
          var defineProperty = definePropertyModule.f;

          if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
            defineProperty(Constructor, SPECIES, {
              configurable: true,
              get: function() {
                return this;
              },
            });
          }
        };
      },
      {
        '../internals/get-built-in': '../../../node_modules/core-js/internals/get-built-in.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
      },
    ],
    '../../../node_modules/core-js/internals/an-instance.js': [
      function(require, module, exports) {
        module.exports = function(it, Constructor, name) {
          if (!(it instanceof Constructor)) {
            throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
          }
          return it;
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/is-array-iterator-method.js': [
      function(require, module, exports) {
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var Iterators = require('../internals/iterators');

        var ITERATOR = wellKnownSymbol('iterator');
        var ArrayPrototype = Array.prototype;

        // check on default Array iterator
        module.exports = function(it) {
          return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
        };
      },
      {
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/iterators': '../../../node_modules/core-js/internals/iterators.js',
      },
    ],
    '../../../node_modules/core-js/internals/get-iterator-method.js': [
      function(require, module, exports) {
        var classof = require('../internals/classof');
        var Iterators = require('../internals/iterators');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var ITERATOR = wellKnownSymbol('iterator');

        module.exports = function(it) {
          if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
        };
      },
      {
        '../internals/classof': '../../../node_modules/core-js/internals/classof.js',
        '../internals/iterators': '../../../node_modules/core-js/internals/iterators.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/call-with-safe-iteration-closing.js': [
      function(require, module, exports) {
        var anObject = require('../internals/an-object');

        // call something on iterator step with safe closing on error
        module.exports = function(iterator, fn, value, ENTRIES) {
          try {
            return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            // 7.4.6 IteratorClose(iterator, completion)
          } catch (error) {
            var returnMethod = iterator['return'];
            if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
            throw error;
          }
        };
      },
      { '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js' },
    ],
    '../../../node_modules/core-js/internals/iterate.js': [
      function(require, module, exports) {
        var anObject = require('../internals/an-object');
        var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
        var toLength = require('../internals/to-length');
        var bind = require('../internals/function-bind-context');
        var getIteratorMethod = require('../internals/get-iterator-method');
        var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');

        var Result = function(stopped, result) {
          this.stopped = stopped;
          this.result = result;
        };

        var iterate = (module.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
          var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
          var iterator, iterFn, index, length, result, next, step;

          if (IS_ITERATOR) {
            iterator = iterable;
          } else {
            iterFn = getIteratorMethod(iterable);
            if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
            // optimisation for array iterators
            if (isArrayIteratorMethod(iterFn)) {
              for (index = 0, length = toLength(iterable.length); length > index; index++) {
                result = AS_ENTRIES
                  ? boundFunction(anObject((step = iterable[index]))[0], step[1])
                  : boundFunction(iterable[index]);
                if (result && result instanceof Result) return result;
              }
              return new Result(false);
            }
            iterator = iterFn.call(iterable);
          }

          next = iterator.next;
          while (!(step = next.call(iterator)).done) {
            result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
            if (typeof result == 'object' && result && result instanceof Result) return result;
          }
          return new Result(false);
        });

        iterate.stop = function(result) {
          return new Result(true, result);
        };
      },
      {
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/is-array-iterator-method': '../../../node_modules/core-js/internals/is-array-iterator-method.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/function-bind-context': '../../../node_modules/core-js/internals/function-bind-context.js',
        '../internals/get-iterator-method': '../../../node_modules/core-js/internals/get-iterator-method.js',
        '../internals/call-with-safe-iteration-closing':
          '../../../node_modules/core-js/internals/call-with-safe-iteration-closing.js',
      },
    ],
    '../../../node_modules/core-js/internals/check-correctness-of-iteration.js': [
      function(require, module, exports) {
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var ITERATOR = wellKnownSymbol('iterator');
        var SAFE_CLOSING = false;

        try {
          var called = 0;
          var iteratorWithReturn = {
            next: function() {
              return { done: !!called++ };
            },
            return: function() {
              SAFE_CLOSING = true;
            },
          };
          iteratorWithReturn[ITERATOR] = function() {
            return this;
          };
          // eslint-disable-next-line no-throw-literal
          Array.from(iteratorWithReturn, function() {
            throw 2;
          });
        } catch (error) {
          /* empty */
        }

        module.exports = function(exec, SKIP_CLOSING) {
          if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
          var ITERATION_SUPPORT = false;
          try {
            var object = {};
            object[ITERATOR] = function() {
              return {
                next: function() {
                  return { done: (ITERATION_SUPPORT = true) };
                },
              };
            };
            exec(object);
          } catch (error) {
            /* empty */
          }
          return ITERATION_SUPPORT;
        };
      },
      { '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js' },
    ],
    '../../../node_modules/core-js/internals/species-constructor.js': [
      function(require, module, exports) {
        var anObject = require('../internals/an-object');
        var aFunction = require('../internals/a-function');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var SPECIES = wellKnownSymbol('species');

        // `SpeciesConstructor` abstract operation
        // https://tc39.github.io/ecma262/#sec-speciesconstructor
        module.exports = function(O, defaultConstructor) {
          var C = anObject(O).constructor;
          var S;
          return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
        };
      },
      {
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/a-function': '../../../node_modules/core-js/internals/a-function.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/engine-is-ios.js': [
      function(require, module, exports) {
        var userAgent = require('../internals/engine-user-agent');

        module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);
      },
      { '../internals/engine-user-agent': '../../../node_modules/core-js/internals/engine-user-agent.js' },
    ],
    '../../../node_modules/core-js/internals/task.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var fails = require('../internals/fails');
        var classof = require('../internals/classof-raw');
        var bind = require('../internals/function-bind-context');
        var html = require('../internals/html');
        var createElement = require('../internals/document-create-element');
        var IS_IOS = require('../internals/engine-is-ios');

        var location = global.location;
        var set = global.setImmediate;
        var clear = global.clearImmediate;
        var process = global.process;
        var MessageChannel = global.MessageChannel;
        var Dispatch = global.Dispatch;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = 'onreadystatechange';
        var defer, channel, port;

        var run = function(id) {
          // eslint-disable-next-line no-prototype-builtins
          if (queue.hasOwnProperty(id)) {
            var fn = queue[id];
            delete queue[id];
            fn();
          }
        };

        var runner = function(id) {
          return function() {
            run(id);
          };
        };

        var listener = function(event) {
          run(event.data);
        };

        var post = function(id) {
          // old engines have not location.origin
          global.postMessage(id + '', location.protocol + '//' + location.host);
        };

        // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
        if (!set || !clear) {
          set = function setImmediate(fn) {
            var args = [];
            var i = 1;
            while (arguments.length > i) args.push(arguments[i++]);
            queue[++counter] = function() {
              // eslint-disable-next-line no-new-func
              (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
            };
            defer(counter);
            return counter;
          };
          clear = function clearImmediate(id) {
            delete queue[id];
          };
          // Node.js 0.8-
          if (classof(process) == 'process') {
            defer = function(id) {
              process.nextTick(runner(id));
            };
            // Sphere (JS game engine) Dispatch API
          } else if (Dispatch && Dispatch.now) {
            defer = function(id) {
              Dispatch.now(runner(id));
            };
            // Browsers with MessageChannel, includes WebWorkers
            // except iOS - https://github.com/zloirock/core-js/issues/624
          } else if (MessageChannel && !IS_IOS) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = bind(port.postMessage, port, 1);
            // Browsers with postMessage, skip WebWorkers
            // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
          } else if (
            global.addEventListener &&
            typeof postMessage == 'function' &&
            !global.importScripts &&
            !fails(post)
          ) {
            defer = post;
            global.addEventListener('message', listener, false);
            // IE8-
          } else if (ONREADYSTATECHANGE in createElement('script')) {
            defer = function(id) {
              html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function() {
                html.removeChild(this);
                run(id);
              };
            };
            // Rest old browsers
          } else {
            defer = function(id) {
              setTimeout(runner(id), 0);
            };
          }
        }

        module.exports = {
          set: set,
          clear: clear,
        };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        '../internals/function-bind-context': '../../../node_modules/core-js/internals/function-bind-context.js',
        '../internals/html': '../../../node_modules/core-js/internals/html.js',
        '../internals/document-create-element': '../../../node_modules/core-js/internals/document-create-element.js',
        '../internals/engine-is-ios': '../../../node_modules/core-js/internals/engine-is-ios.js',
      },
    ],
    '../../../node_modules/core-js/internals/microtask.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
        var classof = require('../internals/classof-raw');
        var macrotask = require('../internals/task').set;
        var IS_IOS = require('../internals/engine-is-ios');

        var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
        var process = global.process;
        var Promise = global.Promise;
        var IS_NODE = classof(process) == 'process';
        // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
        var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
        var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

        var flush, head, last, notify, toggle, node, promise, then;

        // modern engines have queueMicrotask method
        if (!queueMicrotask) {
          flush = function() {
            var parent, fn;
            if (IS_NODE && (parent = process.domain)) parent.exit();
            while (head) {
              fn = head.fn;
              head = head.next;
              try {
                fn();
              } catch (error) {
                if (head) notify();
                else last = undefined;
                throw error;
              }
            }
            last = undefined;
            if (parent) parent.enter();
          };

          // Node.js
          if (IS_NODE) {
            notify = function() {
              process.nextTick(flush);
            };
            // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
          } else if (MutationObserver && !IS_IOS) {
            toggle = true;
            node = document.createTextNode('');
            new MutationObserver(flush).observe(node, { characterData: true });
            notify = function() {
              node.data = toggle = !toggle;
            };
            // environments with maybe non-completely correct, but existent Promise
          } else if (Promise && Promise.resolve) {
            // Promise.resolve without an argument throws an error in LG WebOS 2
            promise = Promise.resolve(undefined);
            then = promise.then;
            notify = function() {
              then.call(promise, flush);
            };
            // for other environments - macrotask based on:
            // - setImmediate
            // - MessageChannel
            // - window.postMessag
            // - onreadystatechange
            // - setTimeout
          } else {
            notify = function() {
              // strange IE + webpack dev server bug - use .call(global)
              macrotask.call(global, flush);
            };
          }
        }

        module.exports =
          queueMicrotask ||
          function(fn) {
            var task = { fn: fn, next: undefined };
            if (last) last.next = task;
            if (!head) {
              head = task;
              notify();
            }
            last = task;
          };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        '../internals/task': '../../../node_modules/core-js/internals/task.js',
        '../internals/engine-is-ios': '../../../node_modules/core-js/internals/engine-is-ios.js',
      },
    ],
    '../../../node_modules/core-js/internals/new-promise-capability.js': [
      function(require, module, exports) {
        'use strict';
        var aFunction = require('../internals/a-function');

        var PromiseCapability = function(C) {
          var resolve, reject;
          this.promise = new C(function($$resolve, $$reject) {
            if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
            resolve = $$resolve;
            reject = $$reject;
          });
          this.resolve = aFunction(resolve);
          this.reject = aFunction(reject);
        };

        // 25.4.1.5 NewPromiseCapability(C)
        module.exports.f = function(C) {
          return new PromiseCapability(C);
        };
      },
      { '../internals/a-function': '../../../node_modules/core-js/internals/a-function.js' },
    ],
    '../../../node_modules/core-js/internals/promise-resolve.js': [
      function(require, module, exports) {
        var anObject = require('../internals/an-object');
        var isObject = require('../internals/is-object');
        var newPromiseCapability = require('../internals/new-promise-capability');

        module.exports = function(C, x) {
          anObject(C);
          if (isObject(x) && x.constructor === C) return x;
          var promiseCapability = newPromiseCapability.f(C);
          var resolve = promiseCapability.resolve;
          resolve(x);
          return promiseCapability.promise;
        };
      },
      {
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/new-promise-capability': '../../../node_modules/core-js/internals/new-promise-capability.js',
      },
    ],
    '../../../node_modules/core-js/internals/host-report-errors.js': [
      function(require, module, exports) {
        var global = require('../internals/global');

        module.exports = function(a, b) {
          var console = global.console;
          if (console && console.error) {
            arguments.length === 1 ? console.error(a) : console.error(a, b);
          }
        };
      },
      { '../internals/global': '../../../node_modules/core-js/internals/global.js' },
    ],
    '../../../node_modules/core-js/internals/perform.js': [
      function(require, module, exports) {
        module.exports = function(exec) {
          try {
            return { error: false, value: exec() };
          } catch (error) {
            return { error: true, value: error };
          }
        };
      },
      {},
    ],
    '../../../node_modules/core-js/modules/es.promise.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var IS_PURE = require('../internals/is-pure');
        var global = require('../internals/global');
        var getBuiltIn = require('../internals/get-built-in');
        var NativePromise = require('../internals/native-promise-constructor');
        var redefine = require('../internals/redefine');
        var redefineAll = require('../internals/redefine-all');
        var setToStringTag = require('../internals/set-to-string-tag');
        var setSpecies = require('../internals/set-species');
        var isObject = require('../internals/is-object');
        var aFunction = require('../internals/a-function');
        var anInstance = require('../internals/an-instance');
        var classof = require('../internals/classof-raw');
        var inspectSource = require('../internals/inspect-source');
        var iterate = require('../internals/iterate');
        var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
        var speciesConstructor = require('../internals/species-constructor');
        var task = require('../internals/task').set;
        var microtask = require('../internals/microtask');
        var promiseResolve = require('../internals/promise-resolve');
        var hostReportErrors = require('../internals/host-report-errors');
        var newPromiseCapabilityModule = require('../internals/new-promise-capability');
        var perform = require('../internals/perform');
        var InternalStateModule = require('../internals/internal-state');
        var isForced = require('../internals/is-forced');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var V8_VERSION = require('../internals/engine-v8-version');

        var SPECIES = wellKnownSymbol('species');
        var PROMISE = 'Promise';
        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
        var PromiseConstructor = NativePromise;
        var TypeError = global.TypeError;
        var document = global.document;
        var process = global.process;
        var $fetch = getBuiltIn('fetch');
        var newPromiseCapability = newPromiseCapabilityModule.f;
        var newGenericPromiseCapability = newPromiseCapability;
        var IS_NODE = classof(process) == 'process';
        var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
        var UNHANDLED_REJECTION = 'unhandledrejection';
        var REJECTION_HANDLED = 'rejectionhandled';
        var PENDING = 0;
        var FULFILLED = 1;
        var REJECTED = 2;
        var HANDLED = 1;
        var UNHANDLED = 2;
        var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

        var FORCED = isForced(PROMISE, function() {
          var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
          if (!GLOBAL_CORE_JS_PROMISE) {
            // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
            // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
            // We can't detect it synchronously, so just check versions
            if (V8_VERSION === 66) return true;
            // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
            if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
          }
          // We need Promise#finally in the pure version for preventing prototype pollution
          if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
          // We can't use @@species feature detection in V8 since it causes
          // deoptimization and performance degradation
          // https://github.com/zloirock/core-js/issues/679
          if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
          // Detect correctness of subclassing with @@species support
          var promise = PromiseConstructor.resolve(1);
          var FakePromise = function(exec) {
            exec(
              function() {
                /* empty */
              },
              function() {
                /* empty */
              }
            );
          };
          var constructor = (promise.constructor = {});
          constructor[SPECIES] = FakePromise;
          return !(
            promise.then(function() {
              /* empty */
            }) instanceof FakePromise
          );
        });

        var INCORRECT_ITERATION =
          FORCED ||
          !checkCorrectnessOfIteration(function(iterable) {
            PromiseConstructor.all(iterable)['catch'](function() {
              /* empty */
            });
          });

        // helpers
        var isThenable = function(it) {
          var then;
          return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
        };

        var notify = function(promise, state, isReject) {
          if (state.notified) return;
          state.notified = true;
          var chain = state.reactions;
          microtask(function() {
            var value = state.value;
            var ok = state.state == FULFILLED;
            var index = 0;
            // variable length - can't use forEach
            while (chain.length > index) {
              var reaction = chain[index++];
              var handler = ok ? reaction.ok : reaction.fail;
              var resolve = reaction.resolve;
              var reject = reaction.reject;
              var domain = reaction.domain;
              var result, then, exited;
              try {
                if (handler) {
                  if (!ok) {
                    if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
                    state.rejection = HANDLED;
                  }
                  if (handler === true) result = value;
                  else {
                    if (domain) domain.enter();
                    result = handler(value); // can throw
                    if (domain) {
                      domain.exit();
                      exited = true;
                    }
                  }
                  if (result === reaction.promise) {
                    reject(TypeError('Promise-chain cycle'));
                  } else if ((then = isThenable(result))) {
                    then.call(result, resolve, reject);
                  } else resolve(result);
                } else reject(value);
              } catch (error) {
                if (domain && !exited) domain.exit();
                reject(error);
              }
            }
            state.reactions = [];
            state.notified = false;
            if (isReject && !state.rejection) onUnhandled(promise, state);
          });
        };

        var dispatchEvent = function(name, promise, reason) {
          var event, handler;
          if (DISPATCH_EVENT) {
            event = document.createEvent('Event');
            event.promise = promise;
            event.reason = reason;
            event.initEvent(name, false, true);
            global.dispatchEvent(event);
          } else event = { promise: promise, reason: reason };
          if ((handler = global['on' + name])) handler(event);
          else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
        };

        var onUnhandled = function(promise, state) {
          task.call(global, function() {
            var value = state.value;
            var IS_UNHANDLED = isUnhandled(state);
            var result;
            if (IS_UNHANDLED) {
              result = perform(function() {
                if (IS_NODE) {
                  process.emit('unhandledRejection', value, promise);
                } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
              });
              // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
              state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
              if (result.error) throw result.value;
            }
          });
        };

        var isUnhandled = function(state) {
          return state.rejection !== HANDLED && !state.parent;
        };

        var onHandleUnhandled = function(promise, state) {
          task.call(global, function() {
            if (IS_NODE) {
              process.emit('rejectionHandled', promise);
            } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
          });
        };

        var bind = function(fn, promise, state, unwrap) {
          return function(value) {
            fn(promise, state, value, unwrap);
          };
        };

        var internalReject = function(promise, state, value, unwrap) {
          if (state.done) return;
          state.done = true;
          if (unwrap) state = unwrap;
          state.value = value;
          state.state = REJECTED;
          notify(promise, state, true);
        };

        var internalResolve = function(promise, state, value, unwrap) {
          if (state.done) return;
          state.done = true;
          if (unwrap) state = unwrap;
          try {
            if (promise === value) throw TypeError("Promise can't be resolved itself");
            var then = isThenable(value);
            if (then) {
              microtask(function() {
                var wrapper = { done: false };
                try {
                  then.call(
                    value,
                    bind(internalResolve, promise, wrapper, state),
                    bind(internalReject, promise, wrapper, state)
                  );
                } catch (error) {
                  internalReject(promise, wrapper, error, state);
                }
              });
            } else {
              state.value = value;
              state.state = FULFILLED;
              notify(promise, state, false);
            }
          } catch (error) {
            internalReject(promise, { done: false }, error, state);
          }
        };

        // constructor polyfill
        if (FORCED) {
          // 25.4.3.1 Promise(executor)
          PromiseConstructor = function Promise(executor) {
            anInstance(this, PromiseConstructor, PROMISE);
            aFunction(executor);
            Internal.call(this);
            var state = getInternalState(this);
            try {
              executor(bind(internalResolve, this, state), bind(internalReject, this, state));
            } catch (error) {
              internalReject(this, state, error);
            }
          };
          // eslint-disable-next-line no-unused-vars
          Internal = function Promise(executor) {
            setInternalState(this, {
              type: PROMISE,
              done: false,
              notified: false,
              parent: false,
              reactions: [],
              rejection: false,
              state: PENDING,
              value: undefined,
            });
          };
          Internal.prototype = redefineAll(PromiseConstructor.prototype, {
            // `Promise.prototype.then` method
            // https://tc39.github.io/ecma262/#sec-promise.prototype.then
            then: function then(onFulfilled, onRejected) {
              var state = getInternalPromiseState(this);
              var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
              reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
              reaction.fail = typeof onRejected == 'function' && onRejected;
              reaction.domain = IS_NODE ? process.domain : undefined;
              state.parent = true;
              state.reactions.push(reaction);
              if (state.state != PENDING) notify(this, state, false);
              return reaction.promise;
            },
            // `Promise.prototype.catch` method
            // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
            catch: function(onRejected) {
              return this.then(undefined, onRejected);
            },
          });
          OwnPromiseCapability = function() {
            var promise = new Internal();
            var state = getInternalState(promise);
            this.promise = promise;
            this.resolve = bind(internalResolve, promise, state);
            this.reject = bind(internalReject, promise, state);
          };
          newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
            return C === PromiseConstructor || C === PromiseWrapper
              ? new OwnPromiseCapability(C)
              : newGenericPromiseCapability(C);
          };

          if (!IS_PURE && typeof NativePromise == 'function') {
            nativeThen = NativePromise.prototype.then;

            // wrap native Promise#then for native async functions
            redefine(
              NativePromise.prototype,
              'then',
              function then(onFulfilled, onRejected) {
                var that = this;
                return new PromiseConstructor(function(resolve, reject) {
                  nativeThen.call(that, resolve, reject);
                }).then(onFulfilled, onRejected);
                // https://github.com/zloirock/core-js/issues/640
              },
              { unsafe: true }
            );

            // wrap fetch result
            if (typeof $fetch == 'function')
              $(
                { global: true, enumerable: true, forced: true },
                {
                  // eslint-disable-next-line no-unused-vars
                  fetch: function fetch(input /* , init */) {
                    return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
                  },
                }
              );
          }
        }

        $(
          { global: true, wrap: true, forced: FORCED },
          {
            Promise: PromiseConstructor,
          }
        );

        setToStringTag(PromiseConstructor, PROMISE, false, true);
        setSpecies(PROMISE);

        PromiseWrapper = getBuiltIn(PROMISE);

        // statics
        $(
          { target: PROMISE, stat: true, forced: FORCED },
          {
            // `Promise.reject` method
            // https://tc39.github.io/ecma262/#sec-promise.reject
            reject: function reject(r) {
              var capability = newPromiseCapability(this);
              capability.reject.call(undefined, r);
              return capability.promise;
            },
          }
        );

        $(
          { target: PROMISE, stat: true, forced: IS_PURE || FORCED },
          {
            // `Promise.resolve` method
            // https://tc39.github.io/ecma262/#sec-promise.resolve
            resolve: function resolve(x) {
              return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
            },
          }
        );

        $(
          { target: PROMISE, stat: true, forced: INCORRECT_ITERATION },
          {
            // `Promise.all` method
            // https://tc39.github.io/ecma262/#sec-promise.all
            all: function all(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var resolve = capability.resolve;
              var reject = capability.reject;
              var result = perform(function() {
                var $promiseResolve = aFunction(C.resolve);
                var values = [];
                var counter = 0;
                var remaining = 1;
                iterate(iterable, function(promise) {
                  var index = counter++;
                  var alreadyCalled = false;
                  values.push(undefined);
                  remaining++;
                  $promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = value;
                    --remaining || resolve(values);
                  }, reject);
                });
                --remaining || resolve(values);
              });
              if (result.error) reject(result.value);
              return capability.promise;
            },
            // `Promise.race` method
            // https://tc39.github.io/ecma262/#sec-promise.race
            race: function race(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var reject = capability.reject;
              var result = perform(function() {
                var $promiseResolve = aFunction(C.resolve);
                iterate(iterable, function(promise) {
                  $promiseResolve.call(C, promise).then(capability.resolve, reject);
                });
              });
              if (result.error) reject(result.value);
              return capability.promise;
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/is-pure': '../../../node_modules/core-js/internals/is-pure.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/get-built-in': '../../../node_modules/core-js/internals/get-built-in.js',
        '../internals/native-promise-constructor':
          '../../../node_modules/core-js/internals/native-promise-constructor.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/redefine-all': '../../../node_modules/core-js/internals/redefine-all.js',
        '../internals/set-to-string-tag': '../../../node_modules/core-js/internals/set-to-string-tag.js',
        '../internals/set-species': '../../../node_modules/core-js/internals/set-species.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/a-function': '../../../node_modules/core-js/internals/a-function.js',
        '../internals/an-instance': '../../../node_modules/core-js/internals/an-instance.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        '../internals/inspect-source': '../../../node_modules/core-js/internals/inspect-source.js',
        '../internals/iterate': '../../../node_modules/core-js/internals/iterate.js',
        '../internals/check-correctness-of-iteration':
          '../../../node_modules/core-js/internals/check-correctness-of-iteration.js',
        '../internals/species-constructor': '../../../node_modules/core-js/internals/species-constructor.js',
        '../internals/task': '../../../node_modules/core-js/internals/task.js',
        '../internals/microtask': '../../../node_modules/core-js/internals/microtask.js',
        '../internals/promise-resolve': '../../../node_modules/core-js/internals/promise-resolve.js',
        '../internals/host-report-errors': '../../../node_modules/core-js/internals/host-report-errors.js',
        '../internals/new-promise-capability': '../../../node_modules/core-js/internals/new-promise-capability.js',
        '../internals/perform': '../../../node_modules/core-js/internals/perform.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
        '../internals/is-forced': '../../../node_modules/core-js/internals/is-forced.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/engine-v8-version': '../../../node_modules/core-js/internals/engine-v8-version.js',
      },
    ],
    '../../../node_modules/core-js/internals/string-multibyte.js': [
      function(require, module, exports) {
        var toInteger = require('../internals/to-integer');
        var requireObjectCoercible = require('../internals/require-object-coercible');

        // `String.prototype.{ codePointAt, at }` methods implementation
        var createMethod = function(CONVERT_TO_STRING) {
          return function($this, pos) {
            var S = String(requireObjectCoercible($this));
            var position = toInteger(pos);
            var size = S.length;
            var first, second;
            if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
            first = S.charCodeAt(position);
            return first < 0xd800 ||
              first > 0xdbff ||
              position + 1 === size ||
              (second = S.charCodeAt(position + 1)) < 0xdc00 ||
              second > 0xdfff
              ? CONVERT_TO_STRING
                ? S.charAt(position)
                : first
              : CONVERT_TO_STRING
              ? S.slice(position, position + 2)
              : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
          };
        };

        module.exports = {
          // `String.prototype.codePointAt` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
          codeAt: createMethod(false),
          // `String.prototype.at` method
          // https://github.com/mathiasbynens/String.prototype.at
          charAt: createMethod(true),
        };
      },
      {
        '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js',
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.string.iterator.js': [
      function(require, module, exports) {
        'use strict';
        var charAt = require('../internals/string-multibyte').charAt;
        var InternalStateModule = require('../internals/internal-state');
        var defineIterator = require('../internals/define-iterator');

        var STRING_ITERATOR = 'String Iterator';
        var setInternalState = InternalStateModule.set;
        var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

        // `String.prototype[@@iterator]` method
        // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
        defineIterator(
          String,
          'String',
          function(iterated) {
            setInternalState(this, {
              type: STRING_ITERATOR,
              string: String(iterated),
              index: 0,
            });
            // `%StringIteratorPrototype%.next` method
            // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
          },
          function next() {
            var state = getInternalState(this);
            var string = state.string;
            var index = state.index;
            var point;
            if (index >= string.length) return { value: undefined, done: true };
            point = charAt(string, index);
            state.index += point.length;
            return { value: point, done: false };
          }
        );
      },
      {
        '../internals/string-multibyte': '../../../node_modules/core-js/internals/string-multibyte.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
        '../internals/define-iterator': '../../../node_modules/core-js/internals/define-iterator.js',
      },
    ],
    '../../../node_modules/core-js/internals/dom-iterables.js': [
      function(require, module, exports) {
        // iterable DOM collections
        // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
        module.exports = {
          CSSRuleList: 0,
          CSSStyleDeclaration: 0,
          CSSValueList: 0,
          ClientRectList: 0,
          DOMRectList: 0,
          DOMStringList: 0,
          DOMTokenList: 1,
          DataTransferItemList: 0,
          FileList: 0,
          HTMLAllCollection: 0,
          HTMLCollection: 0,
          HTMLFormElement: 0,
          HTMLSelectElement: 0,
          MediaList: 0,
          MimeTypeArray: 0,
          NamedNodeMap: 0,
          NodeList: 1,
          PaintRequestList: 0,
          Plugin: 0,
          PluginArray: 0,
          SVGLengthList: 0,
          SVGNumberList: 0,
          SVGPathSegList: 0,
          SVGPointList: 0,
          SVGStringList: 0,
          SVGTransformList: 0,
          SourceBufferList: 0,
          StyleSheetList: 0,
          TextTrackCueList: 0,
          TextTrackList: 0,
          TouchList: 0,
        };
      },
      {},
    ],
    '../../../node_modules/core-js/modules/web.dom-collections.iterator.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var DOMIterables = require('../internals/dom-iterables');
        var ArrayIteratorMethods = require('../modules/es.array.iterator');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var ITERATOR = wellKnownSymbol('iterator');
        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        var ArrayValues = ArrayIteratorMethods.values;

        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          if (CollectionPrototype) {
            // some Chrome versions have non-configurable methods on DOMTokenList
            if (CollectionPrototype[ITERATOR] !== ArrayValues)
              try {
                createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
              } catch (error) {
                CollectionPrototype[ITERATOR] = ArrayValues;
              }
            if (!CollectionPrototype[TO_STRING_TAG]) {
              createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
            }
            if (DOMIterables[COLLECTION_NAME])
              for (var METHOD_NAME in ArrayIteratorMethods) {
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                  try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                  } catch (error) {
                    CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                  }
              }
          }
        }
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/dom-iterables': '../../../node_modules/core-js/internals/dom-iterables.js',
        '../modules/es.array.iterator': '../../../node_modules/core-js/modules/es.array.iterator.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-copy-within.js': [
      function(require, module, exports) {
        'use strict';
        var toObject = require('../internals/to-object');
        var toAbsoluteIndex = require('../internals/to-absolute-index');
        var toLength = require('../internals/to-length');

        var min = Math.min;

        // `Array.prototype.copyWithin` method implementation
        // https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
        module.exports =
          [].copyWithin ||
          function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
            var O = toObject(this);
            var len = toLength(O.length);
            var to = toAbsoluteIndex(target, len);
            var from = toAbsoluteIndex(start, len);
            var end = arguments.length > 2 ? arguments[2] : undefined;
            var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
            var inc = 1;
            if (from < to && to < from + count) {
              inc = -1;
              from += count - 1;
              to += count - 1;
            }
            while (count-- > 0) {
              if (from in O) O[to] = O[from];
              else delete O[to];
              to += inc;
              from += inc;
            }
            return O;
          };
      },
      {
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-absolute-index': '../../../node_modules/core-js/internals/to-absolute-index.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.copy-within.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var copyWithin = require('../internals/array-copy-within');
        var addToUnscopables = require('../internals/add-to-unscopables');

        // `Array.prototype.copyWithin` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
        $(
          { target: 'Array', proto: true },
          {
            copyWithin: copyWithin,
          }
        );

        // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
        addToUnscopables('copyWithin');
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/array-copy-within': '../../../node_modules/core-js/internals/array-copy-within.js',
        '../internals/add-to-unscopables': '../../../node_modules/core-js/internals/add-to-unscopables.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-method-uses-to-length.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var fails = require('../internals/fails');
        var has = require('../internals/has');

        var defineProperty = Object.defineProperty;
        var cache = {};

        var thrower = function(it) {
          throw it;
        };

        module.exports = function(METHOD_NAME, options) {
          if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
          if (!options) options = {};
          var method = [][METHOD_NAME];
          var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
          var argument0 = has(options, 0) ? options[0] : thrower;
          var argument1 = has(options, 1) ? options[1] : undefined;

          return (cache[METHOD_NAME] =
            !!method &&
            !fails(function() {
              if (ACCESSORS && !DESCRIPTORS) return true;
              var O = { length: -1 };

              if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
              else O[1] = 1;

              method.call(O, argument0, argument1);
            }));
        };
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.filter.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var $filter = require('../internals/array-iteration').filter;
        var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
        // Edge 14- issue
        var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

        // `Array.prototype.filter` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.filter
        // with adding support of @@species
        $(
          { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH },
          {
            filter: function filter(callbackfn /* , thisArg */) {
              return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/array-method-has-species-support':
          '../../../node_modules/core-js/internals/array-method-has-species-support.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.includes.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var $includes = require('../internals/array-includes').includes;
        var addToUnscopables = require('../internals/add-to-unscopables');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

        // `Array.prototype.includes` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.includes
        $(
          { target: 'Array', proto: true, forced: !USES_TO_LENGTH },
          {
            includes: function includes(el /* , fromIndex = 0 */) {
              return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
            },
          }
        );

        // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
        addToUnscopables('includes');
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/array-includes': '../../../node_modules/core-js/internals/array-includes.js',
        '../internals/add-to-unscopables': '../../../node_modules/core-js/internals/add-to-unscopables.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-method-is-strict.js': [
      function(require, module, exports) {
        'use strict';
        var fails = require('../internals/fails');

        module.exports = function(METHOD_NAME, argument) {
          var method = [][METHOD_NAME];
          return (
            !!method &&
            fails(function() {
              // eslint-disable-next-line no-useless-call,no-throw-literal
              method.call(
                null,
                argument ||
                  function() {
                    throw 1;
                  },
                1
              );
            })
          );
        };
      },
      { '../internals/fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/modules/es.array.join.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var IndexedObject = require('../internals/indexed-object');
        var toIndexedObject = require('../internals/to-indexed-object');
        var arrayMethodIsStrict = require('../internals/array-method-is-strict');

        var nativeJoin = [].join;

        var ES3_STRINGS = IndexedObject != Object;
        var STRICT_METHOD = arrayMethodIsStrict('join', ',');

        // `Array.prototype.join` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.join
        $(
          { target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD },
          {
            join: function join(separator) {
              return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/indexed-object': '../../../node_modules/core-js/internals/indexed-object.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/array-method-is-strict': '../../../node_modules/core-js/internals/array-method-is-strict.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.map.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var $map = require('../internals/array-iteration').map;
        var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
        // FF49- issue
        var USES_TO_LENGTH = arrayMethodUsesToLength('map');

        // `Array.prototype.map` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.map
        // with adding support of @@species
        $(
          { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH },
          {
            map: function map(callbackfn /* , thisArg */) {
              return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/array-method-has-species-support':
          '../../../node_modules/core-js/internals/array-method-has-species-support.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.slice.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var isObject = require('../internals/is-object');
        var isArray = require('../internals/is-array');
        var toAbsoluteIndex = require('../internals/to-absolute-index');
        var toLength = require('../internals/to-length');
        var toIndexedObject = require('../internals/to-indexed-object');
        var createProperty = require('../internals/create-property');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
        var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

        var SPECIES = wellKnownSymbol('species');
        var nativeSlice = [].slice;
        var max = Math.max;

        // `Array.prototype.slice` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.slice
        // fallback for not array-like ES3 strings and DOM objects
        $(
          { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH },
          {
            slice: function slice(start, end) {
              var O = toIndexedObject(this);
              var length = toLength(O.length);
              var k = toAbsoluteIndex(start, length);
              var fin = toAbsoluteIndex(end === undefined ? length : end, length);
              // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
              var Constructor, result, n;
              if (isArray(O)) {
                Constructor = O.constructor;
                // cross-realm fallback
                if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
                  Constructor = undefined;
                } else if (isObject(Constructor)) {
                  Constructor = Constructor[SPECIES];
                  if (Constructor === null) Constructor = undefined;
                }
                if (Constructor === Array || Constructor === undefined) {
                  return nativeSlice.call(O, k, fin);
                }
              }
              result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
              for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
              result.length = n;
              return result;
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/is-array': '../../../node_modules/core-js/internals/is-array.js',
        '../internals/to-absolute-index': '../../../node_modules/core-js/internals/to-absolute-index.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/create-property': '../../../node_modules/core-js/internals/create-property.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/array-method-has-species-support':
          '../../../node_modules/core-js/internals/array-method-has-species-support.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.splice.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var toAbsoluteIndex = require('../internals/to-absolute-index');
        var toInteger = require('../internals/to-integer');
        var toLength = require('../internals/to-length');
        var toObject = require('../internals/to-object');
        var arraySpeciesCreate = require('../internals/array-species-create');
        var createProperty = require('../internals/create-property');
        var arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
        var USES_TO_LENGTH = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

        var max = Math.max;
        var min = Math.min;
        var MAX_SAFE_INTEGER = 0x1fffffffffffff;
        var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

        // `Array.prototype.splice` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.splice
        // with adding support of @@species
        $(
          { target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH },
          {
            splice: function splice(start, deleteCount /* , ...items */) {
              var O = toObject(this);
              var len = toLength(O.length);
              var actualStart = toAbsoluteIndex(start, len);
              var argumentsLength = arguments.length;
              var insertCount, actualDeleteCount, A, k, from, to;
              if (argumentsLength === 0) {
                insertCount = actualDeleteCount = 0;
              } else if (argumentsLength === 1) {
                insertCount = 0;
                actualDeleteCount = len - actualStart;
              } else {
                insertCount = argumentsLength - 2;
                actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
              }
              if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
              }
              A = arraySpeciesCreate(O, actualDeleteCount);
              for (k = 0; k < actualDeleteCount; k++) {
                from = actualStart + k;
                if (from in O) createProperty(A, k, O[from]);
              }
              A.length = actualDeleteCount;
              if (insertCount < actualDeleteCount) {
                for (k = actualStart; k < len - actualDeleteCount; k++) {
                  from = k + actualDeleteCount;
                  to = k + insertCount;
                  if (from in O) O[to] = O[from];
                  else delete O[to];
                }
                for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
              } else if (insertCount > actualDeleteCount) {
                for (k = len - actualDeleteCount; k > actualStart; k--) {
                  from = k + actualDeleteCount - 1;
                  to = k + insertCount - 1;
                  if (from in O) O[to] = O[from];
                  else delete O[to];
                }
              }
              for (k = 0; k < insertCount; k++) {
                O[k + actualStart] = arguments[k + 2];
              }
              O.length = len - actualDeleteCount + insertCount;
              return A;
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/to-absolute-index': '../../../node_modules/core-js/internals/to-absolute-index.js',
        '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/array-species-create': '../../../node_modules/core-js/internals/array-species-create.js',
        '../internals/create-property': '../../../node_modules/core-js/internals/create-property.js',
        '../internals/array-method-has-species-support':
          '../../../node_modules/core-js/internals/array-method-has-species-support.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-buffer-native.js': [
      function(require, module, exports) {
        module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';
      },
      {},
    ],
    '../../../node_modules/core-js/internals/to-index.js': [
      function(require, module, exports) {
        var toInteger = require('../internals/to-integer');
        var toLength = require('../internals/to-length');

        // `ToIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-toindex
        module.exports = function(it) {
          if (it === undefined) return 0;
          var number = toInteger(it);
          var length = toLength(number);
          if (number !== length) throw RangeError('Wrong length or index');
          return length;
        };
      },
      {
        '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
      },
    ],
    '../../../node_modules/core-js/internals/ieee754.js': [
      function(require, module, exports) {
        // IEEE754 conversions based on https://github.com/feross/ieee754
        // eslint-disable-next-line no-shadow-restricted-names
        var Infinity = 1 / 0;
        var abs = Math.abs;
        var pow = Math.pow;
        var floor = Math.floor;
        var log = Math.log;
        var LN2 = Math.LN2;

        var pack = function(number, mantissaLength, bytes) {
          var buffer = new Array(bytes);
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
          var sign = number < 0 || (number === 0 && 1 / number < 0) ? 1 : 0;
          var index = 0;
          var exponent, mantissa, c;
          number = abs(number);
          // eslint-disable-next-line no-self-compare
          if (number != number || number === Infinity) {
            // eslint-disable-next-line no-self-compare
            mantissa = number != number ? 1 : 0;
            exponent = eMax;
          } else {
            exponent = floor(log(number) / LN2);
            if (number * (c = pow(2, -exponent)) < 1) {
              exponent--;
              c *= 2;
            }
            if (exponent + eBias >= 1) {
              number += rt / c;
            } else {
              number += rt * pow(2, 1 - eBias);
            }
            if (number * c >= 2) {
              exponent++;
              c /= 2;
            }
            if (exponent + eBias >= eMax) {
              mantissa = 0;
              exponent = eMax;
            } else if (exponent + eBias >= 1) {
              mantissa = (number * c - 1) * pow(2, mantissaLength);
              exponent = exponent + eBias;
            } else {
              mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
              exponent = 0;
            }
          }
          for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
          exponent = (exponent << mantissaLength) | mantissa;
          exponentLength += mantissaLength;
          for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
          buffer[--index] |= sign * 128;
          return buffer;
        };

        var unpack = function(buffer, mantissaLength) {
          var bytes = buffer.length;
          var exponentLength = bytes * 8 - mantissaLength - 1;
          var eMax = (1 << exponentLength) - 1;
          var eBias = eMax >> 1;
          var nBits = exponentLength - 7;
          var index = bytes - 1;
          var sign = buffer[index--];
          var exponent = sign & 127;
          var mantissa;
          sign >>= 7;
          for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
          mantissa = exponent & ((1 << -nBits) - 1);
          exponent >>= -nBits;
          nBits += mantissaLength;
          for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
          if (exponent === 0) {
            exponent = 1 - eBias;
          } else if (exponent === eMax) {
            return mantissa ? NaN : sign ? -Infinity : Infinity;
          } else {
            mantissa = mantissa + pow(2, mantissaLength);
            exponent = exponent - eBias;
          }
          return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
        };

        module.exports = {
          pack: pack,
          unpack: unpack,
        };
      },
      {},
    ],
    '../../../node_modules/core-js/internals/array-fill.js': [
      function(require, module, exports) {
        'use strict';
        var toObject = require('../internals/to-object');
        var toAbsoluteIndex = require('../internals/to-absolute-index');
        var toLength = require('../internals/to-length');

        // `Array.prototype.fill` method implementation
        // https://tc39.github.io/ecma262/#sec-array.prototype.fill
        module.exports = function fill(value /* , start = 0, end = @length */) {
          var O = toObject(this);
          var length = toLength(O.length);
          var argumentsLength = arguments.length;
          var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
          var end = argumentsLength > 2 ? arguments[2] : undefined;
          var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
          while (endPos > index) O[index++] = value;
          return O;
        };
      },
      {
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-absolute-index': '../../../node_modules/core-js/internals/to-absolute-index.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-buffer.js': [
      function(require, module, exports) {
        'use strict';
        var global = require('../internals/global');
        var DESCRIPTORS = require('../internals/descriptors');
        var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var redefineAll = require('../internals/redefine-all');
        var fails = require('../internals/fails');
        var anInstance = require('../internals/an-instance');
        var toInteger = require('../internals/to-integer');
        var toLength = require('../internals/to-length');
        var toIndex = require('../internals/to-index');
        var IEEE754 = require('../internals/ieee754');
        var getPrototypeOf = require('../internals/object-get-prototype-of');
        var setPrototypeOf = require('../internals/object-set-prototype-of');
        var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
        var defineProperty = require('../internals/object-define-property').f;
        var arrayFill = require('../internals/array-fill');
        var setToStringTag = require('../internals/set-to-string-tag');
        var InternalStateModule = require('../internals/internal-state');

        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var ARRAY_BUFFER = 'ArrayBuffer';
        var DATA_VIEW = 'DataView';
        var PROTOTYPE = 'prototype';
        var WRONG_LENGTH = 'Wrong length';
        var WRONG_INDEX = 'Wrong index';
        var NativeArrayBuffer = global[ARRAY_BUFFER];
        var $ArrayBuffer = NativeArrayBuffer;
        var $DataView = global[DATA_VIEW];
        var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
        var ObjectPrototype = Object.prototype;
        var RangeError = global.RangeError;

        var packIEEE754 = IEEE754.pack;
        var unpackIEEE754 = IEEE754.unpack;

        var packInt8 = function(number) {
          return [number & 0xff];
        };

        var packInt16 = function(number) {
          return [number & 0xff, (number >> 8) & 0xff];
        };

        var packInt32 = function(number) {
          return [number & 0xff, (number >> 8) & 0xff, (number >> 16) & 0xff, (number >> 24) & 0xff];
        };

        var unpackInt32 = function(buffer) {
          return (buffer[3] << 24) | (buffer[2] << 16) | (buffer[1] << 8) | buffer[0];
        };

        var packFloat32 = function(number) {
          return packIEEE754(number, 23, 4);
        };

        var packFloat64 = function(number) {
          return packIEEE754(number, 52, 8);
        };

        var addGetter = function(Constructor, key) {
          defineProperty(Constructor[PROTOTYPE], key, {
            get: function() {
              return getInternalState(this)[key];
            },
          });
        };

        var get = function(view, count, index, isLittleEndian) {
          var intIndex = toIndex(index);
          var store = getInternalState(view);
          if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
          var bytes = getInternalState(store.buffer).bytes;
          var start = intIndex + store.byteOffset;
          var pack = bytes.slice(start, start + count);
          return isLittleEndian ? pack : pack.reverse();
        };

        var set = function(view, count, index, conversion, value, isLittleEndian) {
          var intIndex = toIndex(index);
          var store = getInternalState(view);
          if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
          var bytes = getInternalState(store.buffer).bytes;
          var start = intIndex + store.byteOffset;
          var pack = conversion(+value);
          for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
        };

        if (!NATIVE_ARRAY_BUFFER) {
          $ArrayBuffer = function ArrayBuffer(length) {
            anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
            var byteLength = toIndex(length);
            setInternalState(this, {
              bytes: arrayFill.call(new Array(byteLength), 0),
              byteLength: byteLength,
            });
            if (!DESCRIPTORS) this.byteLength = byteLength;
          };

          $DataView = function DataView(buffer, byteOffset, byteLength) {
            anInstance(this, $DataView, DATA_VIEW);
            anInstance(buffer, $ArrayBuffer, DATA_VIEW);
            var bufferLength = getInternalState(buffer).byteLength;
            var offset = toInteger(byteOffset);
            if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
            byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
            if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
            setInternalState(this, {
              buffer: buffer,
              byteLength: byteLength,
              byteOffset: offset,
            });
            if (!DESCRIPTORS) {
              this.buffer = buffer;
              this.byteLength = byteLength;
              this.byteOffset = offset;
            }
          };

          if (DESCRIPTORS) {
            addGetter($ArrayBuffer, 'byteLength');
            addGetter($DataView, 'buffer');
            addGetter($DataView, 'byteLength');
            addGetter($DataView, 'byteOffset');
          }

          redefineAll($DataView[PROTOTYPE], {
            getInt8: function getInt8(byteOffset) {
              return (get(this, 1, byteOffset)[0] << 24) >> 24;
            },
            getUint8: function getUint8(byteOffset) {
              return get(this, 1, byteOffset)[0];
            },
            getInt16: function getInt16(byteOffset /* , littleEndian */) {
              var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
              return (((bytes[1] << 8) | bytes[0]) << 16) >> 16;
            },
            getUint16: function getUint16(byteOffset /* , littleEndian */) {
              var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
              return (bytes[1] << 8) | bytes[0];
            },
            getInt32: function getInt32(byteOffset /* , littleEndian */) {
              return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
            },
            getUint32: function getUint32(byteOffset /* , littleEndian */) {
              return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
            },
            getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
              return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
            },
            getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
              return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
            },
            setInt8: function setInt8(byteOffset, value) {
              set(this, 1, byteOffset, packInt8, value);
            },
            setUint8: function setUint8(byteOffset, value) {
              set(this, 1, byteOffset, packInt8, value);
            },
            setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
              set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
              set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
              set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
              set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
              set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
            },
            setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
              set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
            },
          });
        } else {
          if (
            !fails(function() {
              NativeArrayBuffer(1);
            }) ||
            !fails(function() {
              new NativeArrayBuffer(-1); // eslint-disable-line no-new
            }) ||
            fails(function() {
              new NativeArrayBuffer(); // eslint-disable-line no-new
              new NativeArrayBuffer(1.5); // eslint-disable-line no-new
              new NativeArrayBuffer(NaN); // eslint-disable-line no-new
              return NativeArrayBuffer.name != ARRAY_BUFFER;
            })
          ) {
            $ArrayBuffer = function ArrayBuffer(length) {
              anInstance(this, $ArrayBuffer);
              return new NativeArrayBuffer(toIndex(length));
            };
            var ArrayBufferPrototype = ($ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE]);
            for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j; ) {
              if (!((key = keys[j++]) in $ArrayBuffer)) {
                createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
              }
            }
            ArrayBufferPrototype.constructor = $ArrayBuffer;
          }

          // WebKit bug - the same parent prototype for typed arrays and data view
          if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
            setPrototypeOf($DataViewPrototype, ObjectPrototype);
          }

          // iOS Safari 7.x bug
          var testView = new $DataView(new $ArrayBuffer(2));
          var nativeSetInt8 = $DataViewPrototype.setInt8;
          testView.setInt8(0, 2147483648);
          testView.setInt8(1, 2147483649);
          if (testView.getInt8(0) || !testView.getInt8(1))
            redefineAll(
              $DataViewPrototype,
              {
                setInt8: function setInt8(byteOffset, value) {
                  nativeSetInt8.call(this, byteOffset, (value << 24) >> 24);
                },
                setUint8: function setUint8(byteOffset, value) {
                  nativeSetInt8.call(this, byteOffset, (value << 24) >> 24);
                },
              },
              { unsafe: true }
            );
        }

        setToStringTag($ArrayBuffer, ARRAY_BUFFER);
        setToStringTag($DataView, DATA_VIEW);

        module.exports = {
          ArrayBuffer: $ArrayBuffer,
          DataView: $DataView,
        };
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/array-buffer-native': '../../../node_modules/core-js/internals/array-buffer-native.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/redefine-all': '../../../node_modules/core-js/internals/redefine-all.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/an-instance': '../../../node_modules/core-js/internals/an-instance.js',
        '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-index': '../../../node_modules/core-js/internals/to-index.js',
        '../internals/ieee754': '../../../node_modules/core-js/internals/ieee754.js',
        '../internals/object-get-prototype-of': '../../../node_modules/core-js/internals/object-get-prototype-of.js',
        '../internals/object-set-prototype-of': '../../../node_modules/core-js/internals/object-set-prototype-of.js',
        '../internals/object-get-own-property-names':
          '../../../node_modules/core-js/internals/object-get-own-property-names.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/array-fill': '../../../node_modules/core-js/internals/array-fill.js',
        '../internals/set-to-string-tag': '../../../node_modules/core-js/internals/set-to-string-tag.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array-buffer.constructor.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var global = require('../internals/global');
        var arrayBufferModule = require('../internals/array-buffer');
        var setSpecies = require('../internals/set-species');

        var ARRAY_BUFFER = 'ArrayBuffer';
        var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
        var NativeArrayBuffer = global[ARRAY_BUFFER];

        // `ArrayBuffer` constructor
        // https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
        $(
          { global: true, forced: NativeArrayBuffer !== ArrayBuffer },
          {
            ArrayBuffer: ArrayBuffer,
          }
        );

        setSpecies(ARRAY_BUFFER);
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/array-buffer': '../../../node_modules/core-js/internals/array-buffer.js',
        '../internals/set-species': '../../../node_modules/core-js/internals/set-species.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.function.name.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var defineProperty = require('../internals/object-define-property').f;

        var FunctionPrototype = Function.prototype;
        var FunctionPrototypeToString = FunctionPrototype.toString;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = 'name';

        // Function instances `.name` property
        // https://tc39.github.io/ecma262/#sec-function-instances-name
        if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
          defineProperty(FunctionPrototype, NAME, {
            configurable: true,
            get: function() {
              try {
                return FunctionPrototypeToString.call(this).match(nameRE)[1];
              } catch (error) {
                return '';
              }
            },
          });
        }
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
      },
    ],
    '../../../node_modules/core-js/internals/freezing.js': [
      function(require, module, exports) {
        var fails = require('../internals/fails');

        module.exports = !fails(function() {
          return Object.isExtensible(Object.preventExtensions({}));
        });
      },
      { '../internals/fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/internals/internal-metadata.js': [
      function(require, module, exports) {
        var hiddenKeys = require('../internals/hidden-keys');
        var isObject = require('../internals/is-object');
        var has = require('../internals/has');
        var defineProperty = require('../internals/object-define-property').f;
        var uid = require('../internals/uid');
        var FREEZING = require('../internals/freezing');

        var METADATA = uid('meta');
        var id = 0;

        var isExtensible =
          Object.isExtensible ||
          function() {
            return true;
          };

        var setMetadata = function(it) {
          defineProperty(it, METADATA, {
            value: {
              objectID: 'O' + ++id, // object ID
              weakData: {}, // weak collections IDs
            },
          });
        };

        var fastKey = function(it, create) {
          // return a primitive with prefix
          if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
          if (!has(it, METADATA)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return 'F';
            // not necessary to add metadata
            if (!create) return 'E';
            // add missing metadata
            setMetadata(it);
            // return object ID
          }
          return it[METADATA].objectID;
        };

        var getWeakData = function(it, create) {
          if (!has(it, METADATA)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return true;
            // not necessary to add metadata
            if (!create) return false;
            // add missing metadata
            setMetadata(it);
            // return the store of weak collections IDs
          }
          return it[METADATA].weakData;
        };

        // add metadata on freeze-family methods calling
        var onFreeze = function(it) {
          if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
          return it;
        };

        var meta = (module.exports = {
          REQUIRED: false,
          fastKey: fastKey,
          getWeakData: getWeakData,
          onFreeze: onFreeze,
        });

        hiddenKeys[METADATA] = true;
      },
      {
        '../internals/hidden-keys': '../../../node_modules/core-js/internals/hidden-keys.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/uid': '../../../node_modules/core-js/internals/uid.js',
        '../internals/freezing': '../../../node_modules/core-js/internals/freezing.js',
      },
    ],
    '../../../node_modules/core-js/internals/inherit-if-required.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');
        var setPrototypeOf = require('../internals/object-set-prototype-of');

        // makes subclassing work correct for wrapped built-ins
        module.exports = function($this, dummy, Wrapper) {
          var NewTarget, NewTargetPrototype;
          if (
            // it can work only with native `setPrototypeOf`
            setPrototypeOf &&
            // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
            typeof (NewTarget = dummy.constructor) == 'function' &&
            NewTarget !== Wrapper &&
            isObject((NewTargetPrototype = NewTarget.prototype)) &&
            NewTargetPrototype !== Wrapper.prototype
          )
            setPrototypeOf($this, NewTargetPrototype);
          return $this;
        };
      },
      {
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/object-set-prototype-of': '../../../node_modules/core-js/internals/object-set-prototype-of.js',
      },
    ],
    '../../../node_modules/core-js/internals/collection.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var global = require('../internals/global');
        var isForced = require('../internals/is-forced');
        var redefine = require('../internals/redefine');
        var InternalMetadataModule = require('../internals/internal-metadata');
        var iterate = require('../internals/iterate');
        var anInstance = require('../internals/an-instance');
        var isObject = require('../internals/is-object');
        var fails = require('../internals/fails');
        var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
        var setToStringTag = require('../internals/set-to-string-tag');
        var inheritIfRequired = require('../internals/inherit-if-required');

        module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
          var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
          var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
          var ADDER = IS_MAP ? 'set' : 'add';
          var NativeConstructor = global[CONSTRUCTOR_NAME];
          var NativePrototype = NativeConstructor && NativeConstructor.prototype;
          var Constructor = NativeConstructor;
          var exported = {};

          var fixMethod = function(KEY) {
            var nativeMethod = NativePrototype[KEY];
            redefine(
              NativePrototype,
              KEY,
              KEY == 'add'
                ? function add(value) {
                    nativeMethod.call(this, value === 0 ? 0 : value);
                    return this;
                  }
                : KEY == 'delete'
                ? function(key) {
                    return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                  }
                : KEY == 'get'
                ? function get(key) {
                    return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
                  }
                : KEY == 'has'
                ? function has(key) {
                    return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                  }
                : function set(key, value) {
                    nativeMethod.call(this, key === 0 ? 0 : key, value);
                    return this;
                  }
            );
          };

          // eslint-disable-next-line max-len
          if (
            isForced(
              CONSTRUCTOR_NAME,
              typeof NativeConstructor != 'function' ||
                !(
                  IS_WEAK ||
                  (NativePrototype.forEach &&
                    !fails(function() {
                      new NativeConstructor().entries().next();
                    }))
                )
            )
          ) {
            // create collection constructor
            Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
            InternalMetadataModule.REQUIRED = true;
          } else if (isForced(CONSTRUCTOR_NAME, true)) {
            var instance = new Constructor();
            // early implementations not supports chaining
            var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
            // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
            var THROWS_ON_PRIMITIVES = fails(function() {
              instance.has(1);
            });
            // most early implementations doesn't supports iterables, most modern - not close it correctly
            // eslint-disable-next-line no-new
            var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
              new NativeConstructor(iterable);
            });
            // for early implementations -0 and +0 not the same
            var BUGGY_ZERO =
              !IS_WEAK &&
              fails(function() {
                // V8 ~ Chromium 42- fails only with 5+ elements
                var $instance = new NativeConstructor();
                var index = 5;
                while (index--) $instance[ADDER](index, index);
                return !$instance.has(-0);
              });

            if (!ACCEPT_ITERABLES) {
              Constructor = wrapper(function(dummy, iterable) {
                anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
                var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
                return that;
              });
              Constructor.prototype = NativePrototype;
              NativePrototype.constructor = Constructor;
            }

            if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
              fixMethod('delete');
              fixMethod('has');
              IS_MAP && fixMethod('get');
            }

            if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

            // weak collections should not contains .clear method
            if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
          }

          exported[CONSTRUCTOR_NAME] = Constructor;
          $({ global: true, forced: Constructor != NativeConstructor }, exported);

          setToStringTag(Constructor, CONSTRUCTOR_NAME);

          if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

          return Constructor;
        };
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/is-forced': '../../../node_modules/core-js/internals/is-forced.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/internal-metadata': '../../../node_modules/core-js/internals/internal-metadata.js',
        '../internals/iterate': '../../../node_modules/core-js/internals/iterate.js',
        '../internals/an-instance': '../../../node_modules/core-js/internals/an-instance.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/check-correctness-of-iteration':
          '../../../node_modules/core-js/internals/check-correctness-of-iteration.js',
        '../internals/set-to-string-tag': '../../../node_modules/core-js/internals/set-to-string-tag.js',
        '../internals/inherit-if-required': '../../../node_modules/core-js/internals/inherit-if-required.js',
      },
    ],
    '../../../node_modules/core-js/internals/collection-strong.js': [
      function(require, module, exports) {
        var define;
        ('use strict');
        var defineProperty = require('../internals/object-define-property').f;
        var create = require('../internals/object-create');
        var redefineAll = require('../internals/redefine-all');
        var bind = require('../internals/function-bind-context');
        var anInstance = require('../internals/an-instance');
        var iterate = require('../internals/iterate');
        var defineIterator = require('../internals/define-iterator');
        var setSpecies = require('../internals/set-species');
        var DESCRIPTORS = require('../internals/descriptors');
        var fastKey = require('../internals/internal-metadata').fastKey;
        var InternalStateModule = require('../internals/internal-state');

        var setInternalState = InternalStateModule.set;
        var internalStateGetterFor = InternalStateModule.getterFor;

        module.exports = {
          getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
            var C = wrapper(function(that, iterable) {
              anInstance(that, C, CONSTRUCTOR_NAME);
              setInternalState(that, {
                type: CONSTRUCTOR_NAME,
                index: create(null),
                first: undefined,
                last: undefined,
                size: 0,
              });
              if (!DESCRIPTORS) that.size = 0;
              if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
            });

            var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

            var define = function(that, key, value) {
              var state = getInternalState(that);
              var entry = getEntry(that, key);
              var previous, index;
              // change existing entry
              if (entry) {
                entry.value = value;
                // create new entry
              } else {
                state.last = entry = {
                  index: (index = fastKey(key, true)),
                  key: key,
                  value: value,
                  previous: (previous = state.last),
                  next: undefined,
                  removed: false,
                };
                if (!state.first) state.first = entry;
                if (previous) previous.next = entry;
                if (DESCRIPTORS) state.size++;
                else that.size++;
                // add to index
                if (index !== 'F') state.index[index] = entry;
              }
              return that;
            };

            var getEntry = function(that, key) {
              var state = getInternalState(that);
              // fast case
              var index = fastKey(key);
              var entry;
              if (index !== 'F') return state.index[index];
              // frozen object case
              for (entry = state.first; entry; entry = entry.next) {
                if (entry.key == key) return entry;
              }
            };

            redefineAll(C.prototype, {
              // 23.1.3.1 Map.prototype.clear()
              // 23.2.3.2 Set.prototype.clear()
              clear: function clear() {
                var that = this;
                var state = getInternalState(that);
                var data = state.index;
                var entry = state.first;
                while (entry) {
                  entry.removed = true;
                  if (entry.previous) entry.previous = entry.previous.next = undefined;
                  delete data[entry.index];
                  entry = entry.next;
                }
                state.first = state.last = undefined;
                if (DESCRIPTORS) state.size = 0;
                else that.size = 0;
              },
              // 23.1.3.3 Map.prototype.delete(key)
              // 23.2.3.4 Set.prototype.delete(value)
              delete: function(key) {
                var that = this;
                var state = getInternalState(that);
                var entry = getEntry(that, key);
                if (entry) {
                  var next = entry.next;
                  var prev = entry.previous;
                  delete state.index[entry.index];
                  entry.removed = true;
                  if (prev) prev.next = next;
                  if (next) next.previous = prev;
                  if (state.first == entry) state.first = next;
                  if (state.last == entry) state.last = prev;
                  if (DESCRIPTORS) state.size--;
                  else that.size--;
                }
                return !!entry;
              },
              // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
              // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
              forEach: function forEach(callbackfn /* , that = undefined */) {
                var state = getInternalState(this);
                var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
                var entry;
                while ((entry = entry ? entry.next : state.first)) {
                  boundFunction(entry.value, entry.key, this);
                  // revert to the last existing entry
                  while (entry && entry.removed) entry = entry.previous;
                }
              },
              // 23.1.3.7 Map.prototype.has(key)
              // 23.2.3.7 Set.prototype.has(value)
              has: function has(key) {
                return !!getEntry(this, key);
              },
            });

            redefineAll(
              C.prototype,
              IS_MAP
                ? {
                    // 23.1.3.6 Map.prototype.get(key)
                    get: function get(key) {
                      var entry = getEntry(this, key);
                      return entry && entry.value;
                    },
                    // 23.1.3.9 Map.prototype.set(key, value)
                    set: function set(key, value) {
                      return define(this, key === 0 ? 0 : key, value);
                    },
                  }
                : {
                    // 23.2.3.1 Set.prototype.add(value)
                    add: function add(value) {
                      return define(this, (value = value === 0 ? 0 : value), value);
                    },
                  }
            );
            if (DESCRIPTORS)
              defineProperty(C.prototype, 'size', {
                get: function() {
                  return getInternalState(this).size;
                },
              });
            return C;
          },
          setStrong: function(C, CONSTRUCTOR_NAME, IS_MAP) {
            var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
            var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
            var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
            // add .keys, .values, .entries, [@@iterator]
            // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
            defineIterator(
              C,
              CONSTRUCTOR_NAME,
              function(iterated, kind) {
                setInternalState(this, {
                  type: ITERATOR_NAME,
                  target: iterated,
                  state: getInternalCollectionState(iterated),
                  kind: kind,
                  last: undefined,
                });
              },
              function() {
                var state = getInternalIteratorState(this);
                var kind = state.kind;
                var entry = state.last;
                // revert to the last existing entry
                while (entry && entry.removed) entry = entry.previous;
                // get next entry
                if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                  // or finish the iteration
                  state.target = undefined;
                  return { value: undefined, done: true };
                }
                // return step by kind
                if (kind == 'keys') return { value: entry.key, done: false };
                if (kind == 'values') return { value: entry.value, done: false };
                return { value: [entry.key, entry.value], done: false };
              },
              IS_MAP ? 'entries' : 'values',
              !IS_MAP,
              true
            );

            // add [@@species], 23.1.2.2, 23.2.2.2
            setSpecies(CONSTRUCTOR_NAME);
          },
        };
      },
      {
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/object-create': '../../../node_modules/core-js/internals/object-create.js',
        '../internals/redefine-all': '../../../node_modules/core-js/internals/redefine-all.js',
        '../internals/function-bind-context': '../../../node_modules/core-js/internals/function-bind-context.js',
        '../internals/an-instance': '../../../node_modules/core-js/internals/an-instance.js',
        '../internals/iterate': '../../../node_modules/core-js/internals/iterate.js',
        '../internals/define-iterator': '../../../node_modules/core-js/internals/define-iterator.js',
        '../internals/set-species': '../../../node_modules/core-js/internals/set-species.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/internal-metadata': '../../../node_modules/core-js/internals/internal-metadata.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.map.js': [
      function(require, module, exports) {
        'use strict';
        var collection = require('../internals/collection');
        var collectionStrong = require('../internals/collection-strong');

        // `Map` constructor
        // https://tc39.github.io/ecma262/#sec-map-objects
        module.exports = collection(
          'Map',
          function(init) {
            return function Map() {
              return init(this, arguments.length ? arguments[0] : undefined);
            };
          },
          collectionStrong
        );
      },
      {
        '../internals/collection': '../../../node_modules/core-js/internals/collection.js',
        '../internals/collection-strong': '../../../node_modules/core-js/internals/collection-strong.js',
      },
    ],
    '../../../node_modules/core-js/internals/whitespaces.js': [
      function(require, module, exports) {
        // a string of all valid unicode whitespaces
        // eslint-disable-next-line max-len
        module.exports =
          '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
      },
      {},
    ],
    '../../../node_modules/core-js/internals/string-trim.js': [
      function(require, module, exports) {
        var requireObjectCoercible = require('../internals/require-object-coercible');
        var whitespaces = require('../internals/whitespaces');

        var whitespace = '[' + whitespaces + ']';
        var ltrim = RegExp('^' + whitespace + whitespace + '*');
        var rtrim = RegExp(whitespace + whitespace + '*$');

        // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
        var createMethod = function(TYPE) {
          return function($this) {
            var string = String(requireObjectCoercible($this));
            if (TYPE & 1) string = string.replace(ltrim, '');
            if (TYPE & 2) string = string.replace(rtrim, '');
            return string;
          };
        };

        module.exports = {
          // `String.prototype.{ trimLeft, trimStart }` methods
          // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
          start: createMethod(1),
          // `String.prototype.{ trimRight, trimEnd }` methods
          // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
          end: createMethod(2),
          // `String.prototype.trim` method
          // https://tc39.github.io/ecma262/#sec-string.prototype.trim
          trim: createMethod(3),
        };
      },
      {
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
        '../internals/whitespaces': '../../../node_modules/core-js/internals/whitespaces.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.number.constructor.js': [
      function(require, module, exports) {
        'use strict';
        var DESCRIPTORS = require('../internals/descriptors');
        var global = require('../internals/global');
        var isForced = require('../internals/is-forced');
        var redefine = require('../internals/redefine');
        var has = require('../internals/has');
        var classof = require('../internals/classof-raw');
        var inheritIfRequired = require('../internals/inherit-if-required');
        var toPrimitive = require('../internals/to-primitive');
        var fails = require('../internals/fails');
        var create = require('../internals/object-create');
        var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
        var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
        var defineProperty = require('../internals/object-define-property').f;
        var trim = require('../internals/string-trim').trim;

        var NUMBER = 'Number';
        var NativeNumber = global[NUMBER];
        var NumberPrototype = NativeNumber.prototype;

        // Opera ~12 has broken Object#toString
        var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

        // `ToNumber` abstract operation
        // https://tc39.github.io/ecma262/#sec-tonumber
        var toNumber = function(argument) {
          var it = toPrimitive(argument, false);
          var first, third, radix, maxCode, digits, length, index, code;
          if (typeof it == 'string' && it.length > 2) {
            it = trim(it);
            first = it.charCodeAt(0);
            if (first === 43 || first === 45) {
              third = it.charCodeAt(2);
              if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
            } else if (first === 48) {
              switch (it.charCodeAt(1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break; // fast equal of /^0b[01]+$/i
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break; // fast equal of /^0o[0-7]+$/i
                default:
                  return +it;
              }
              digits = it.slice(2);
              length = digits.length;
              for (index = 0; index < length; index++) {
                code = digits.charCodeAt(index);
                // parseInt parses a string to a first unavailable symbol
                // but ToNumber should return NaN if a string contains unavailable symbols
                if (code < 48 || code > maxCode) return NaN;
              }
              return parseInt(digits, radix);
            }
          }
          return +it;
        };

        // `Number` constructor
        // https://tc39.github.io/ecma262/#sec-number-constructor
        if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
          var NumberWrapper = function Number(value) {
            var it = arguments.length < 1 ? 0 : value;
            var dummy = this;
            return dummy instanceof NumberWrapper &&
              // check on 1..constructor(foo) case
              (BROKEN_CLASSOF
                ? fails(function() {
                    NumberPrototype.valueOf.call(dummy);
                  })
                : classof(dummy) != NUMBER)
              ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper)
              : toNumber(it);
          };
          for (
            var keys = DESCRIPTORS
                ? getOwnPropertyNames(NativeNumber)
                : // ES3:
                  (
                    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
                    // ES2015 (in case, if modules with ES2015 Number statics required before):
                    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
                    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
                  ).split(','),
              j = 0,
              key;
            keys.length > j;
            j++
          ) {
            if (has(NativeNumber, (key = keys[j])) && !has(NumberWrapper, key)) {
              defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
            }
          }
          NumberWrapper.prototype = NumberPrototype;
          NumberPrototype.constructor = NumberWrapper;
          redefine(global, NUMBER, NumberWrapper);
        }
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/is-forced': '../../../node_modules/core-js/internals/is-forced.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        '../internals/inherit-if-required': '../../../node_modules/core-js/internals/inherit-if-required.js',
        '../internals/to-primitive': '../../../node_modules/core-js/internals/to-primitive.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/object-create': '../../../node_modules/core-js/internals/object-create.js',
        '../internals/object-get-own-property-names':
          '../../../node_modules/core-js/internals/object-get-own-property-names.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/string-trim': '../../../node_modules/core-js/internals/string-trim.js',
      },
    ],
    '../../../node_modules/core-js/internals/is-integer.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');

        var floor = Math.floor;

        // `Number.isInteger` method implementation
        // https://tc39.github.io/ecma262/#sec-number.isinteger
        module.exports = function isInteger(it) {
          return !isObject(it) && isFinite(it) && floor(it) === it;
        };
      },
      { '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js' },
    ],
    '../../../node_modules/core-js/modules/es.number.is-integer.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var isInteger = require('../internals/is-integer');

        // `Number.isInteger` method
        // https://tc39.github.io/ecma262/#sec-number.isinteger
        $(
          { target: 'Number', stat: true },
          {
            isInteger: isInteger,
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/is-integer': '../../../node_modules/core-js/internals/is-integer.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.number.max-safe-integer.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');

        // `Number.MAX_SAFE_INTEGER` constant
        // https://tc39.github.io/ecma262/#sec-number.max_safe_integer
        $(
          { target: 'Number', stat: true },
          {
            MAX_SAFE_INTEGER: 0x1fffffffffffff,
          }
        );
      },
      { '../internals/export': '../../../node_modules/core-js/internals/export.js' },
    ],
    '../../../node_modules/core-js/modules/es.object.freeze.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var FREEZING = require('../internals/freezing');
        var fails = require('../internals/fails');
        var isObject = require('../internals/is-object');
        var onFreeze = require('../internals/internal-metadata').onFreeze;

        var nativeFreeze = Object.freeze;
        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeFreeze(1);
        });

        // `Object.freeze` method
        // https://tc39.github.io/ecma262/#sec-object.freeze
        $(
          { target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING },
          {
            freeze: function freeze(it) {
              return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/freezing': '../../../node_modules/core-js/internals/freezing.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/internal-metadata': '../../../node_modules/core-js/internals/internal-metadata.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.object.keys.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var toObject = require('../internals/to-object');
        var nativeKeys = require('../internals/object-keys');
        var fails = require('../internals/fails');

        var FAILS_ON_PRIMITIVES = fails(function() {
          nativeKeys(1);
        });

        // `Object.keys` method
        // https://tc39.github.io/ecma262/#sec-object.keys
        $(
          { target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES },
          {
            keys: function keys(it) {
              return nativeKeys(toObject(it));
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/object-keys': '../../../node_modules/core-js/internals/object-keys.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
      },
    ],
    '../../../node_modules/core-js/internals/object-to-array.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var objectKeys = require('../internals/object-keys');
        var toIndexedObject = require('../internals/to-indexed-object');
        var propertyIsEnumerable = require('../internals/object-property-is-enumerable').f;

        // `Object.{ entries, values }` methods implementation
        var createMethod = function(TO_ENTRIES) {
          return function(it) {
            var O = toIndexedObject(it);
            var keys = objectKeys(O);
            var length = keys.length;
            var i = 0;
            var result = [];
            var key;
            while (length > i) {
              key = keys[i++];
              if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
                result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
              }
            }
            return result;
          };
        };

        module.exports = {
          // `Object.entries` method
          // https://tc39.github.io/ecma262/#sec-object.entries
          entries: createMethod(true),
          // `Object.values` method
          // https://tc39.github.io/ecma262/#sec-object.values
          values: createMethod(false),
        };
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/object-keys': '../../../node_modules/core-js/internals/object-keys.js',
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/object-property-is-enumerable':
          '../../../node_modules/core-js/internals/object-property-is-enumerable.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.object.values.js': [
      function(require, module, exports) {
        var $ = require('../internals/export');
        var $values = require('../internals/object-to-array').values;

        // `Object.values` method
        // https://tc39.github.io/ecma262/#sec-object.values
        $(
          { target: 'Object', stat: true },
          {
            values: function values(O) {
              return $values(O);
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/object-to-array': '../../../node_modules/core-js/internals/object-to-array.js',
      },
    ],
    '../../../node_modules/core-js/internals/regexp-flags.js': [
      function(require, module, exports) {
        'use strict';
        var anObject = require('../internals/an-object');

        // `RegExp.prototype.flags` getter implementation
        // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
        module.exports = function() {
          var that = anObject(this);
          var result = '';
          if (that.global) result += 'g';
          if (that.ignoreCase) result += 'i';
          if (that.multiline) result += 'm';
          if (that.dotAll) result += 's';
          if (that.unicode) result += 'u';
          if (that.sticky) result += 'y';
          return result;
        };
      },
      { '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js' },
    ],
    '../../../node_modules/core-js/internals/regexp-sticky-helpers.js': [
      function(require, module, exports) {
        'use strict';

        var fails = require('./fails');

        // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
        // so we use an intermediate function.
        function RE(s, f) {
          return RegExp(s, f);
        }

        exports.UNSUPPORTED_Y = fails(function() {
          // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
          var re = RE('a', 'y');
          re.lastIndex = 2;
          return re.exec('abcd') != null;
        });

        exports.BROKEN_CARET = fails(function() {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
          var re = RE('^r', 'gy');
          re.lastIndex = 2;
          return re.exec('str') != null;
        });
      },
      { './fails': '../../../node_modules/core-js/internals/fails.js' },
    ],
    '../../../node_modules/core-js/modules/es.regexp.flags.js': [
      function(require, module, exports) {
        var DESCRIPTORS = require('../internals/descriptors');
        var objectDefinePropertyModule = require('../internals/object-define-property');
        var regExpFlags = require('../internals/regexp-flags');
        var UNSUPPORTED_Y = require('../internals/regexp-sticky-helpers').UNSUPPORTED_Y;

        // `RegExp.prototype.flags` getter
        // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
        if (DESCRIPTORS && (/./g.flags != 'g' || UNSUPPORTED_Y)) {
          objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
            configurable: true,
            get: regExpFlags,
          });
        }
      },
      {
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/regexp-flags': '../../../node_modules/core-js/internals/regexp-flags.js',
        '../internals/regexp-sticky-helpers': '../../../node_modules/core-js/internals/regexp-sticky-helpers.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.regexp.to-string.js': [
      function(require, module, exports) {
        'use strict';
        var redefine = require('../internals/redefine');
        var anObject = require('../internals/an-object');
        var fails = require('../internals/fails');
        var flags = require('../internals/regexp-flags');

        var TO_STRING = 'toString';
        var RegExpPrototype = RegExp.prototype;
        var nativeToString = RegExpPrototype[TO_STRING];

        var NOT_GENERIC = fails(function() {
          return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b';
        });
        // FF44- RegExp#toString has a wrong name
        var INCORRECT_NAME = nativeToString.name != TO_STRING;

        // `RegExp.prototype.toString` method
        // https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
        if (NOT_GENERIC || INCORRECT_NAME) {
          redefine(
            RegExp.prototype,
            TO_STRING,
            function toString() {
              var R = anObject(this);
              var p = String(R.source);
              var rf = R.flags;
              var f = String(
                rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf
              );
              return '/' + p + '/' + f;
            },
            { unsafe: true }
          );
        }
      },
      {
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/regexp-flags': '../../../node_modules/core-js/internals/regexp-flags.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.set.js': [
      function(require, module, exports) {
        'use strict';
        var collection = require('../internals/collection');
        var collectionStrong = require('../internals/collection-strong');

        // `Set` constructor
        // https://tc39.github.io/ecma262/#sec-set-objects
        module.exports = collection(
          'Set',
          function(init) {
            return function Set() {
              return init(this, arguments.length ? arguments[0] : undefined);
            };
          },
          collectionStrong
        );
      },
      {
        '../internals/collection': '../../../node_modules/core-js/internals/collection.js',
        '../internals/collection-strong': '../../../node_modules/core-js/internals/collection-strong.js',
      },
    ],
    '../../../node_modules/core-js/internals/is-regexp.js': [
      function(require, module, exports) {
        var isObject = require('../internals/is-object');
        var classof = require('../internals/classof-raw');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var MATCH = wellKnownSymbol('match');

        // `IsRegExp` abstract operation
        // https://tc39.github.io/ecma262/#sec-isregexp
        module.exports = function(it) {
          var isRegExp;
          return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
        };
      },
      {
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/internals/not-a-regexp.js': [
      function(require, module, exports) {
        var isRegExp = require('../internals/is-regexp');

        module.exports = function(it) {
          if (isRegExp(it)) {
            throw TypeError("The method doesn't accept regular expressions");
          }
          return it;
        };
      },
      { '../internals/is-regexp': '../../../node_modules/core-js/internals/is-regexp.js' },
    ],
    '../../../node_modules/core-js/internals/correct-is-regexp-logic.js': [
      function(require, module, exports) {
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var MATCH = wellKnownSymbol('match');

        module.exports = function(METHOD_NAME) {
          var regexp = /./;
          try {
            '/./'[METHOD_NAME](regexp);
          } catch (e) {
            try {
              regexp[MATCH] = false;
              return '/./'[METHOD_NAME](regexp);
            } catch (f) {
              /* empty */
            }
          }
          return false;
        };
      },
      { '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js' },
    ],
    '../../../node_modules/core-js/modules/es.string.includes.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var notARegExp = require('../internals/not-a-regexp');
        var requireObjectCoercible = require('../internals/require-object-coercible');
        var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

        // `String.prototype.includes` method
        // https://tc39.github.io/ecma262/#sec-string.prototype.includes
        $(
          { target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') },
          {
            includes: function includes(searchString /* , position = 0 */) {
              return !!~String(requireObjectCoercible(this)).indexOf(
                notARegExp(searchString),
                arguments.length > 1 ? arguments[1] : undefined
              );
            },
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/not-a-regexp': '../../../node_modules/core-js/internals/not-a-regexp.js',
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
        '../internals/correct-is-regexp-logic': '../../../node_modules/core-js/internals/correct-is-regexp-logic.js',
      },
    ],
    '../../../node_modules/core-js/internals/regexp-exec.js': [
      function(require, module, exports) {
        'use strict';
        var regexpFlags = require('./regexp-flags');
        var stickyHelpers = require('./regexp-sticky-helpers');

        var nativeExec = RegExp.prototype.exec;
        // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.
        var nativeReplace = String.prototype.replace;

        var patchedExec = nativeExec;

        var UPDATES_LAST_INDEX_WRONG = (function() {
          var re1 = /a/;
          var re2 = /b*/g;
          nativeExec.call(re1, 'a');
          nativeExec.call(re2, 'a');
          return re1.lastIndex !== 0 || re2.lastIndex !== 0;
        })();

        var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

        // nonparticipating capturing group, copied from es5-shim's String#split patch.
        var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

        if (PATCH) {
          patchedExec = function exec(str) {
            var re = this;
            var lastIndex, reCopy, match, i;
            var sticky = UNSUPPORTED_Y && re.sticky;
            var flags = regexpFlags.call(re);
            var source = re.source;
            var charsAdded = 0;
            var strCopy = str;

            if (sticky) {
              flags = flags.replace('y', '');
              if (flags.indexOf('g') === -1) {
                flags += 'g';
              }

              strCopy = String(str).slice(re.lastIndex);
              // Support anchored sticky behavior.
              if (re.lastIndex > 0 && (!re.multiline || (re.multiline && str[re.lastIndex - 1] !== '\n'))) {
                source = '(?: ' + source + ')';
                strCopy = ' ' + strCopy;
                charsAdded++;
              }
              // ^(? + rx + ) is needed, in combination with some str slicing, to
              // simulate the 'y' flag.
              reCopy = new RegExp('^(?:' + source + ')', flags);
            }

            if (NPCG_INCLUDED) {
              reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
            }
            if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

            match = nativeExec.call(sticky ? reCopy : re, strCopy);

            if (sticky) {
              if (match) {
                match.input = match.input.slice(charsAdded);
                match[0] = match[0].slice(charsAdded);
                match.index = re.lastIndex;
                re.lastIndex += match[0].length;
              } else re.lastIndex = 0;
            } else if (UPDATES_LAST_INDEX_WRONG && match) {
              re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
            }
            if (NPCG_INCLUDED && match && match.length > 1) {
              // Fix browsers whose `exec` methods don't consistently return `undefined`
              // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
              nativeReplace.call(match[0], reCopy, function() {
                for (i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undefined) match[i] = undefined;
                }
              });
            }

            return match;
          };
        }

        module.exports = patchedExec;
      },
      {
        './regexp-flags': '../../../node_modules/core-js/internals/regexp-flags.js',
        './regexp-sticky-helpers': '../../../node_modules/core-js/internals/regexp-sticky-helpers.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.regexp.exec.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var exec = require('../internals/regexp-exec');

        $(
          { target: 'RegExp', proto: true, forced: /./.exec !== exec },
          {
            exec: exec,
          }
        );
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/regexp-exec': '../../../node_modules/core-js/internals/regexp-exec.js',
      },
    ],
    '../../../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js': [
      function(require, module, exports) {
        'use strict';
        // TODO: Remove from `core-js@4` since it's moved to entry points
        require('../modules/es.regexp.exec');
        var redefine = require('../internals/redefine');
        var fails = require('../internals/fails');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var regexpExec = require('../internals/regexp-exec');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

        var SPECIES = wellKnownSymbol('species');

        var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
          // #replace needs built-in support for named groups.
          // #match works fine because it just return the exec results, even if it has
          // a "grops" property.
          var re = /./;
          re.exec = function() {
            var result = [];
            result.groups = { a: '7' };
            return result;
          };
          return ''.replace(re, '$<a>') !== '7';
        });

        // IE <= 11 replaces $0 with the whole match, as if it was $&
        // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
        var REPLACE_KEEPS_$0 = (function() {
          return 'a'.replace(/./, '$0') === '$0';
        })();

        var REPLACE = wellKnownSymbol('replace');
        // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
        var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
          if (/./[REPLACE]) {
            return /./[REPLACE]('a', '$0') === '';
          }
          return false;
        })();

        // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
        // Weex JS has frozen built-in prototypes, so use try / catch wrapper
        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
          var re = /(?:)/;
          var originalExec = re.exec;
          re.exec = function() {
            return originalExec.apply(this, arguments);
          };
          var result = 'ab'.split(re);
          return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
        });

        module.exports = function(KEY, length, exec, sham) {
          var SYMBOL = wellKnownSymbol(KEY);

          var DELEGATES_TO_SYMBOL = !fails(function() {
            // String methods call symbol-named RegEp methods
            var O = {};
            O[SYMBOL] = function() {
              return 7;
            };
            return ''[KEY](O) != 7;
          });

          var DELEGATES_TO_EXEC =
            DELEGATES_TO_SYMBOL &&
            !fails(function() {
              // Symbol-named RegExp methods call .exec
              var execCalled = false;
              var re = /a/;

              if (KEY === 'split') {
                // We can't use real regex here since it causes deoptimization
                // and serious performance degradation in V8
                // https://github.com/zloirock/core-js/issues/306
                re = {};
                // RegExp[@@split] doesn't call the regex's exec method, but first creates
                // a new one. We need to return the patched regex when creating the new one.
                re.constructor = {};
                re.constructor[SPECIES] = function() {
                  return re;
                };
                re.flags = '';
                re[SYMBOL] = /./[SYMBOL];
              }

              re.exec = function() {
                execCalled = true;
                return null;
              };

              re[SYMBOL]('');
              return !execCalled;
            });

          if (
            !DELEGATES_TO_SYMBOL ||
            !DELEGATES_TO_EXEC ||
            (KEY === 'replace' &&
              !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE)) ||
            (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
          ) {
            var nativeRegExpMethod = /./[SYMBOL];
            var methods = exec(
              SYMBOL,
              ''[KEY],
              function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                if (regexp.exec === regexpExec) {
                  if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                    // The native String method already delegates to @@method (this
                    // polyfilled function), leasing to infinite recursion.
                    // We avoid it by directly calling the native @@method method.
                    return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                  }
                  return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                }
                return { done: false };
              },
              {
                REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
                REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,
              }
            );
            var stringMethod = methods[0];
            var regexMethod = methods[1];

            redefine(String.prototype, KEY, stringMethod);
            redefine(
              RegExp.prototype,
              SYMBOL,
              length == 2
                ? // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
                  // 21.2.5.11 RegExp.prototype[@@split](string, limit)
                  function(string, arg) {
                    return regexMethod.call(string, this, arg);
                  }
                : // 21.2.5.6 RegExp.prototype[@@match](string)
                  // 21.2.5.9 RegExp.prototype[@@search](string)
                  function(string) {
                    return regexMethod.call(string, this);
                  }
            );
          }

          if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
        };
      },
      {
        '../modules/es.regexp.exec': '../../../node_modules/core-js/modules/es.regexp.exec.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/regexp-exec': '../../../node_modules/core-js/internals/regexp-exec.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
      },
    ],
    '../../../node_modules/core-js/internals/advance-string-index.js': [
      function(require, module, exports) {
        'use strict';
        var charAt = require('../internals/string-multibyte').charAt;

        // `AdvanceStringIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-advancestringindex
        module.exports = function(S, index, unicode) {
          return index + (unicode ? charAt(S, index).length : 1);
        };
      },
      { '../internals/string-multibyte': '../../../node_modules/core-js/internals/string-multibyte.js' },
    ],
    '../../../node_modules/core-js/internals/regexp-exec-abstract.js': [
      function(require, module, exports) {
        var classof = require('./classof-raw');
        var regexpExec = require('./regexp-exec');

        // `RegExpExec` abstract operation
        // https://tc39.github.io/ecma262/#sec-regexpexec
        module.exports = function(R, S) {
          var exec = R.exec;
          if (typeof exec === 'function') {
            var result = exec.call(R, S);
            if (typeof result !== 'object') {
              throw TypeError('RegExp exec method returned something other than an Object or null');
            }
            return result;
          }

          if (classof(R) !== 'RegExp') {
            throw TypeError('RegExp#exec called on incompatible receiver');
          }

          return regexpExec.call(R, S);
        };
      },
      {
        './classof-raw': '../../../node_modules/core-js/internals/classof-raw.js',
        './regexp-exec': '../../../node_modules/core-js/internals/regexp-exec.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.string.replace.js': [
      function(require, module, exports) {
        var global = arguments[3];
        ('use strict');
        var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
        var anObject = require('../internals/an-object');
        var toObject = require('../internals/to-object');
        var toLength = require('../internals/to-length');
        var toInteger = require('../internals/to-integer');
        var requireObjectCoercible = require('../internals/require-object-coercible');
        var advanceStringIndex = require('../internals/advance-string-index');
        var regExpExec = require('../internals/regexp-exec-abstract');

        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

        var maybeToString = function(it) {
          return it === undefined ? it : String(it);
        };

        // @@replace logic
        fixRegExpWellKnownSymbolLogic('replace', 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
          var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
          var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
          var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

          return [
            // `String.prototype.replace` method
            // https://tc39.github.io/ecma262/#sec-string.prototype.replace
            function replace(searchValue, replaceValue) {
              var O = requireObjectCoercible(this);
              var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
              return replacer !== undefined
                ? replacer.call(searchValue, O, replaceValue)
                : nativeReplace.call(String(O), searchValue, replaceValue);
            },
            // `RegExp.prototype[@@replace]` method
            // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
            function(regexp, replaceValue) {
              if (
                (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
                (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
              ) {
                var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                if (res.done) return res.value;
              }

              var rx = anObject(regexp);
              var S = String(this);

              var functionalReplace = typeof replaceValue === 'function';
              if (!functionalReplace) replaceValue = String(replaceValue);

              var global = rx.global;
              if (global) {
                var fullUnicode = rx.unicode;
                rx.lastIndex = 0;
              }
              var results = [];
              while (true) {
                var result = regExpExec(rx, S);
                if (result === null) break;

                results.push(result);
                if (!global) break;

                var matchStr = String(result[0]);
                if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
              }

              var accumulatedResult = '';
              var nextSourcePosition = 0;
              for (var i = 0; i < results.length; i++) {
                result = results[i];

                var matched = String(result[0]);
                var position = max(min(toInteger(result.index), S.length), 0);
                var captures = [];
                // NOTE: This is equivalent to
                //   captures = result.slice(1).map(maybeToString)
                // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
                for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
                var namedCaptures = result.groups;
                if (functionalReplace) {
                  var replacerArgs = [matched].concat(captures, position, S);
                  if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                  var replacement = String(replaceValue.apply(undefined, replacerArgs));
                } else {
                  replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                }
                if (position >= nextSourcePosition) {
                  accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                  nextSourcePosition = position + matched.length;
                }
              }
              return accumulatedResult + S.slice(nextSourcePosition);
            },
          ];

          // https://tc39.github.io/ecma262/#sec-getsubstitution
          function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
            var tailPos = position + matched.length;
            var m = captures.length;
            var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
            if (namedCaptures !== undefined) {
              namedCaptures = toObject(namedCaptures);
              symbols = SUBSTITUTION_SYMBOLS;
            }
            return nativeReplace.call(replacement, symbols, function(match, ch) {
              var capture;
              switch (ch.charAt(0)) {
                case '$':
                  return '$';
                case '&':
                  return matched;
                case '`':
                  return str.slice(0, position);
                case "'":
                  return str.slice(tailPos);
                case '<':
                  capture = namedCaptures[ch.slice(1, -1)];
                  break;
                default:
                  // \d\d?
                  var n = +ch;
                  if (n === 0) return match;
                  if (n > m) {
                    var f = floor(n / 10);
                    if (f === 0) return match;
                    if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                    return match;
                  }
                  capture = captures[n - 1];
              }
              return capture === undefined ? '' : capture;
            });
          }
        });
      },
      {
        '../internals/fix-regexp-well-known-symbol-logic':
          '../../../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js',
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
        '../internals/advance-string-index': '../../../node_modules/core-js/internals/advance-string-index.js',
        '../internals/regexp-exec-abstract': '../../../node_modules/core-js/internals/regexp-exec-abstract.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.string.split.js': [
      function(require, module, exports) {
        'use strict';
        var fixRegExpWellKnownSymbolLogic = require('../internals/fix-regexp-well-known-symbol-logic');
        var isRegExp = require('../internals/is-regexp');
        var anObject = require('../internals/an-object');
        var requireObjectCoercible = require('../internals/require-object-coercible');
        var speciesConstructor = require('../internals/species-constructor');
        var advanceStringIndex = require('../internals/advance-string-index');
        var toLength = require('../internals/to-length');
        var callRegExpExec = require('../internals/regexp-exec-abstract');
        var regexpExec = require('../internals/regexp-exec');
        var fails = require('../internals/fails');

        var arrayPush = [].push;
        var min = Math.min;
        var MAX_UINT32 = 0xffffffff;

        // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
        var SUPPORTS_Y = !fails(function() {
          return !RegExp(MAX_UINT32, 'y');
        });

        // @@split logic
        fixRegExpWellKnownSymbolLogic(
          'split',
          2,
          function(SPLIT, nativeSplit, maybeCallNative) {
            var internalSplit;
            if (
              'abbc'.split(/(b)*/)[1] == 'c' ||
              'test'.split(/(?:)/, -1).length != 4 ||
              'ab'.split(/(?:ab)*/).length != 2 ||
              '.'.split(/(.?)(.?)/).length != 4 ||
              '.'.split(/()()/).length > 1 ||
              ''.split(/.?/).length
            ) {
              // based on es5-shim implementation, need to rework it
              internalSplit = function(separator, limit) {
                var string = String(requireObjectCoercible(this));
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (separator === undefined) return [string];
                // If `separator` is not a regex, use native split
                if (!isRegExp(separator)) {
                  return nativeSplit.call(string, separator, lim);
                }
                var output = [];
                var flags =
                  (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
                var lastLastIndex = 0;
                // Make `global` and avoid `lastIndex` issues by working with a copy
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                var match, lastIndex, lastLength;
                while ((match = regexpExec.call(separatorCopy, string))) {
                  lastIndex = separatorCopy.lastIndex;
                  if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= lim) break;
                  }
                  if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
                }
                if (lastLastIndex === string.length) {
                  if (lastLength || !separatorCopy.test('')) output.push('');
                } else output.push(string.slice(lastLastIndex));
                return output.length > lim ? output.slice(0, lim) : output;
              };
              // Chakra, V8
            } else if ('0'.split(undefined, 0).length) {
              internalSplit = function(separator, limit) {
                return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
              };
            } else internalSplit = nativeSplit;

            return [
              // `String.prototype.split` method
              // https://tc39.github.io/ecma262/#sec-string.prototype.split
              function split(separator, limit) {
                var O = requireObjectCoercible(this);
                var splitter = separator == undefined ? undefined : separator[SPLIT];
                return splitter !== undefined
                  ? splitter.call(separator, O, limit)
                  : internalSplit.call(String(O), separator, limit);
              },
              // `RegExp.prototype[@@split]` method
              // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
              //
              // NOTE: This cannot be properly polyfilled in engines that don't support
              // the 'y' flag.
              function(regexp, limit) {
                var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
                if (res.done) return res.value;

                var rx = anObject(regexp);
                var S = String(this);
                var C = speciesConstructor(rx, RegExp);

                var unicodeMatching = rx.unicode;
                var flags =
                  (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

                // ^(? + rx + ) is needed, in combination with some S slicing, to
                // simulate the 'y' flag.
                var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
                var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                if (lim === 0) return [];
                if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
                var p = 0;
                var q = 0;
                var A = [];
                while (q < S.length) {
                  splitter.lastIndex = SUPPORTS_Y ? q : 0;
                  var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
                  var e;
                  if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
                    q = advanceStringIndex(S, q, unicodeMatching);
                  } else {
                    A.push(S.slice(p, q));
                    if (A.length === lim) return A;
                    for (var i = 1; i <= z.length - 1; i++) {
                      A.push(z[i]);
                      if (A.length === lim) return A;
                    }
                    q = p = e;
                  }
                }
                A.push(S.slice(p));
                return A;
              },
            ];
          },
          !SUPPORTS_Y
        );
      },
      {
        '../internals/fix-regexp-well-known-symbol-logic':
          '../../../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js',
        '../internals/is-regexp': '../../../node_modules/core-js/internals/is-regexp.js',
        '../internals/an-object': '../../../node_modules/core-js/internals/an-object.js',
        '../internals/require-object-coercible': '../../../node_modules/core-js/internals/require-object-coercible.js',
        '../internals/species-constructor': '../../../node_modules/core-js/internals/species-constructor.js',
        '../internals/advance-string-index': '../../../node_modules/core-js/internals/advance-string-index.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/regexp-exec-abstract': '../../../node_modules/core-js/internals/regexp-exec-abstract.js',
        '../internals/regexp-exec': '../../../node_modules/core-js/internals/regexp-exec.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-buffer-view-core.js': [
      function(require, module, exports) {
        'use strict';
        var NATIVE_ARRAY_BUFFER = require('../internals/array-buffer-native');
        var DESCRIPTORS = require('../internals/descriptors');
        var global = require('../internals/global');
        var isObject = require('../internals/is-object');
        var has = require('../internals/has');
        var classof = require('../internals/classof');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var redefine = require('../internals/redefine');
        var defineProperty = require('../internals/object-define-property').f;
        var getPrototypeOf = require('../internals/object-get-prototype-of');
        var setPrototypeOf = require('../internals/object-set-prototype-of');
        var wellKnownSymbol = require('../internals/well-known-symbol');
        var uid = require('../internals/uid');

        var Int8Array = global.Int8Array;
        var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
        var Uint8ClampedArray = global.Uint8ClampedArray;
        var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
        var TypedArray = Int8Array && getPrototypeOf(Int8Array);
        var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
        var ObjectPrototype = Object.prototype;
        var isPrototypeOf = ObjectPrototype.isPrototypeOf;

        var TO_STRING_TAG = wellKnownSymbol('toStringTag');
        var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
        // Fixing native typed arrays in Opera Presto crashes the browser, see #595
        var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
        var TYPED_ARRAY_TAG_REQIRED = false;
        var NAME;

        var TypedArrayConstructorsList = {
          Int8Array: 1,
          Uint8Array: 1,
          Uint8ClampedArray: 1,
          Int16Array: 2,
          Uint16Array: 2,
          Int32Array: 4,
          Uint32Array: 4,
          Float32Array: 4,
          Float64Array: 8,
        };

        var isView = function isView(it) {
          var klass = classof(it);
          return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
        };

        var isTypedArray = function(it) {
          return isObject(it) && has(TypedArrayConstructorsList, classof(it));
        };

        var aTypedArray = function(it) {
          if (isTypedArray(it)) return it;
          throw TypeError('Target is not a typed array');
        };

        var aTypedArrayConstructor = function(C) {
          if (setPrototypeOf) {
            if (isPrototypeOf.call(TypedArray, C)) return C;
          } else
            for (var ARRAY in TypedArrayConstructorsList)
              if (has(TypedArrayConstructorsList, NAME)) {
                var TypedArrayConstructor = global[ARRAY];
                if (
                  TypedArrayConstructor &&
                  (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))
                ) {
                  return C;
                }
              }
          throw TypeError('Target is not a typed array constructor');
        };

        var exportTypedArrayMethod = function(KEY, property, forced) {
          if (!DESCRIPTORS) return;
          if (forced)
            for (var ARRAY in TypedArrayConstructorsList) {
              var TypedArrayConstructor = global[ARRAY];
              if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
                delete TypedArrayConstructor.prototype[KEY];
              }
            }
          if (!TypedArrayPrototype[KEY] || forced) {
            redefine(
              TypedArrayPrototype,
              KEY,
              forced ? property : (NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY]) || property
            );
          }
        };

        var exportTypedArrayStaticMethod = function(KEY, property, forced) {
          var ARRAY, TypedArrayConstructor;
          if (!DESCRIPTORS) return;
          if (setPrototypeOf) {
            if (forced)
              for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = global[ARRAY];
                if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
                  delete TypedArrayConstructor[KEY];
                }
              }
            if (!TypedArray[KEY] || forced) {
              // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
              try {
                return redefine(
                  TypedArray,
                  KEY,
                  forced ? property : (NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY]) || property
                );
              } catch (error) {
                /* empty */
              }
            } else return;
          }
          for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = global[ARRAY];
            if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
              redefine(TypedArrayConstructor, KEY, property);
            }
          }
        };

        for (NAME in TypedArrayConstructorsList) {
          if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
        }

        // WebKit bug - typed arrays constructors prototype is Object.prototype
        if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
          // eslint-disable-next-line no-shadow
          TypedArray = function TypedArray() {
            throw TypeError('Incorrect invocation');
          };
          if (NATIVE_ARRAY_BUFFER_VIEWS)
            for (NAME in TypedArrayConstructorsList) {
              if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
            }
        }

        if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
          TypedArrayPrototype = TypedArray.prototype;
          if (NATIVE_ARRAY_BUFFER_VIEWS)
            for (NAME in TypedArrayConstructorsList) {
              if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
            }
        }

        // WebKit bug - one more object in Uint8ClampedArray prototype chain
        if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
          setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
        }

        if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
          TYPED_ARRAY_TAG_REQIRED = true;
          defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
            get: function() {
              return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
            },
          });
          for (NAME in TypedArrayConstructorsList)
            if (global[NAME]) {
              createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
            }
        }

        module.exports = {
          NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
          TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
          aTypedArray: aTypedArray,
          aTypedArrayConstructor: aTypedArrayConstructor,
          exportTypedArrayMethod: exportTypedArrayMethod,
          exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
          isView: isView,
          isTypedArray: isTypedArray,
          TypedArray: TypedArray,
          TypedArrayPrototype: TypedArrayPrototype,
        };
      },
      {
        '../internals/array-buffer-native': '../../../node_modules/core-js/internals/array-buffer-native.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/classof': '../../../node_modules/core-js/internals/classof.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/redefine': '../../../node_modules/core-js/internals/redefine.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/object-get-prototype-of': '../../../node_modules/core-js/internals/object-get-prototype-of.js',
        '../internals/object-set-prototype-of': '../../../node_modules/core-js/internals/object-set-prototype-of.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
        '../internals/uid': '../../../node_modules/core-js/internals/uid.js',
      },
    ],
    '../../../node_modules/core-js/internals/typed-array-constructors-require-wrappers.js': [
      function(require, module, exports) {
        /* eslint-disable no-new */
        var global = require('../internals/global');
        var fails = require('../internals/fails');
        var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
        var NATIVE_ARRAY_BUFFER_VIEWS = require('../internals/array-buffer-view-core').NATIVE_ARRAY_BUFFER_VIEWS;

        var ArrayBuffer = global.ArrayBuffer;
        var Int8Array = global.Int8Array;

        module.exports =
          !NATIVE_ARRAY_BUFFER_VIEWS ||
          !fails(function() {
            Int8Array(1);
          }) ||
          !fails(function() {
            new Int8Array(-1);
          }) ||
          !checkCorrectnessOfIteration(function(iterable) {
            new Int8Array();
            new Int8Array(null);
            new Int8Array(1.5);
            new Int8Array(iterable);
          }, true) ||
          fails(function() {
            // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
            return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
          });
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/check-correctness-of-iteration':
          '../../../node_modules/core-js/internals/check-correctness-of-iteration.js',
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
      },
    ],
    '../../../node_modules/core-js/internals/to-positive-integer.js': [
      function(require, module, exports) {
        var toInteger = require('../internals/to-integer');

        module.exports = function(it) {
          var result = toInteger(it);
          if (result < 0) throw RangeError("The argument can't be less than 0");
          return result;
        };
      },
      { '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js' },
    ],
    '../../../node_modules/core-js/internals/to-offset.js': [
      function(require, module, exports) {
        var toPositiveInteger = require('../internals/to-positive-integer');

        module.exports = function(it, BYTES) {
          var offset = toPositiveInteger(it);
          if (offset % BYTES) throw RangeError('Wrong offset');
          return offset;
        };
      },
      { '../internals/to-positive-integer': '../../../node_modules/core-js/internals/to-positive-integer.js' },
    ],
    '../../../node_modules/core-js/internals/typed-array-from.js': [
      function(require, module, exports) {
        var toObject = require('../internals/to-object');
        var toLength = require('../internals/to-length');
        var getIteratorMethod = require('../internals/get-iterator-method');
        var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
        var bind = require('../internals/function-bind-context');
        var aTypedArrayConstructor = require('../internals/array-buffer-view-core').aTypedArrayConstructor;

        module.exports = function from(source /* , mapfn, thisArg */) {
          var O = toObject(source);
          var argumentsLength = arguments.length;
          var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var iteratorMethod = getIteratorMethod(O);
          var i, length, result, step, iterator, next;
          if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
            iterator = iteratorMethod.call(O);
            next = iterator.next;
            O = [];
            while (!(step = next.call(iterator)).done) {
              O.push(step.value);
            }
          }
          if (mapping && argumentsLength > 2) {
            mapfn = bind(mapfn, arguments[2], 2);
          }
          length = toLength(O.length);
          result = new (aTypedArrayConstructor(this))(length);
          for (i = 0; length > i; i++) {
            result[i] = mapping ? mapfn(O[i], i) : O[i];
          }
          return result;
        };
      },
      {
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/get-iterator-method': '../../../node_modules/core-js/internals/get-iterator-method.js',
        '../internals/is-array-iterator-method': '../../../node_modules/core-js/internals/is-array-iterator-method.js',
        '../internals/function-bind-context': '../../../node_modules/core-js/internals/function-bind-context.js',
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
      },
    ],
    '../../../node_modules/core-js/internals/typed-array-constructor.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var global = require('../internals/global');
        var DESCRIPTORS = require('../internals/descriptors');
        var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var ArrayBufferModule = require('../internals/array-buffer');
        var anInstance = require('../internals/an-instance');
        var createPropertyDescriptor = require('../internals/create-property-descriptor');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
        var toLength = require('../internals/to-length');
        var toIndex = require('../internals/to-index');
        var toOffset = require('../internals/to-offset');
        var toPrimitive = require('../internals/to-primitive');
        var has = require('../internals/has');
        var classof = require('../internals/classof');
        var isObject = require('../internals/is-object');
        var create = require('../internals/object-create');
        var setPrototypeOf = require('../internals/object-set-prototype-of');
        var getOwnPropertyNames = require('../internals/object-get-own-property-names').f;
        var typedArrayFrom = require('../internals/typed-array-from');
        var forEach = require('../internals/array-iteration').forEach;
        var setSpecies = require('../internals/set-species');
        var definePropertyModule = require('../internals/object-define-property');
        var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
        var InternalStateModule = require('../internals/internal-state');
        var inheritIfRequired = require('../internals/inherit-if-required');

        var getInternalState = InternalStateModule.get;
        var setInternalState = InternalStateModule.set;
        var nativeDefineProperty = definePropertyModule.f;
        var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        var round = Math.round;
        var RangeError = global.RangeError;
        var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
        var DataView = ArrayBufferModule.DataView;
        var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
        var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
        var TypedArray = ArrayBufferViewCore.TypedArray;
        var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var isTypedArray = ArrayBufferViewCore.isTypedArray;
        var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
        var WRONG_LENGTH = 'Wrong length';

        var fromList = function(C, list) {
          var index = 0;
          var length = list.length;
          var result = new (aTypedArrayConstructor(C))(length);
          while (length > index) result[index] = list[index++];
          return result;
        };

        var addGetter = function(it, key) {
          nativeDefineProperty(it, key, {
            get: function() {
              return getInternalState(this)[key];
            },
          });
        };

        var isArrayBuffer = function(it) {
          var klass;
          return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
        };

        var isTypedArrayIndex = function(target, key) {
          return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
        };

        var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
          return isTypedArrayIndex(target, (key = toPrimitive(key, true)))
            ? createPropertyDescriptor(2, target[key])
            : nativeGetOwnPropertyDescriptor(target, key);
        };

        var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
          if (
            isTypedArrayIndex(target, (key = toPrimitive(key, true))) &&
            isObject(descriptor) &&
            has(descriptor, 'value') &&
            !has(descriptor, 'get') &&
            !has(descriptor, 'set') &&
            // TODO: add validation descriptor w/o calling accessors
            !descriptor.configurable &&
            (!has(descriptor, 'writable') || descriptor.writable) &&
            (!has(descriptor, 'enumerable') || descriptor.enumerable)
          ) {
            target[key] = descriptor.value;
            return target;
          }
          return nativeDefineProperty(target, key, descriptor);
        };

        if (DESCRIPTORS) {
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
            definePropertyModule.f = wrappedDefineProperty;
            addGetter(TypedArrayPrototype, 'buffer');
            addGetter(TypedArrayPrototype, 'byteOffset');
            addGetter(TypedArrayPrototype, 'byteLength');
            addGetter(TypedArrayPrototype, 'length');
          }

          $(
            { target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS },
            {
              getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
              defineProperty: wrappedDefineProperty,
            }
          );

          module.exports = function(TYPE, wrapper, CLAMPED) {
            var BYTES = TYPE.match(/\d+$/)[0] / 8;
            var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
            var GETTER = 'get' + TYPE;
            var SETTER = 'set' + TYPE;
            var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
            var TypedArrayConstructor = NativeTypedArrayConstructor;
            var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
            var exported = {};

            var getter = function(that, index) {
              var data = getInternalState(that);
              return data.view[GETTER](index * BYTES + data.byteOffset, true);
            };

            var setter = function(that, index, value) {
              var data = getInternalState(that);
              if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
              data.view[SETTER](index * BYTES + data.byteOffset, value, true);
            };

            var addElement = function(that, index) {
              nativeDefineProperty(that, index, {
                get: function() {
                  return getter(this, index);
                },
                set: function(value) {
                  return setter(this, index, value);
                },
                enumerable: true,
              });
            };

            if (!NATIVE_ARRAY_BUFFER_VIEWS) {
              TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
                var index = 0;
                var byteOffset = 0;
                var buffer, byteLength, length;
                if (!isObject(data)) {
                  length = toIndex(data);
                  byteLength = length * BYTES;
                  buffer = new ArrayBuffer(byteLength);
                } else if (isArrayBuffer(data)) {
                  buffer = data;
                  byteOffset = toOffset(offset, BYTES);
                  var $len = data.byteLength;
                  if ($length === undefined) {
                    if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                    byteLength = $len - byteOffset;
                    if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                  } else {
                    byteLength = toLength($length) * BYTES;
                    if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
                  }
                  length = byteLength / BYTES;
                } else if (isTypedArray(data)) {
                  return fromList(TypedArrayConstructor, data);
                } else {
                  return typedArrayFrom.call(TypedArrayConstructor, data);
                }
                setInternalState(that, {
                  buffer: buffer,
                  byteOffset: byteOffset,
                  byteLength: byteLength,
                  length: length,
                  view: new DataView(buffer),
                });
                while (index < length) addElement(that, index++);
              });

              if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
              TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
            } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
              TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
                return inheritIfRequired(
                  (function() {
                    if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
                    if (isArrayBuffer(data))
                      return $length !== undefined
                        ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
                        : typedArrayOffset !== undefined
                        ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
                        : new NativeTypedArrayConstructor(data);
                    if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                    return typedArrayFrom.call(TypedArrayConstructor, data);
                  })(),
                  dummy,
                  TypedArrayConstructor
                );
              });

              if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
              forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                if (!(key in TypedArrayConstructor)) {
                  createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                }
              });
              TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
            }

            if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
            }

            if (TYPED_ARRAY_TAG) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
            }

            exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

            $(
              {
                global: true,
                forced: TypedArrayConstructor != NativeTypedArrayConstructor,
                sham: !NATIVE_ARRAY_BUFFER_VIEWS,
              },
              exported
            );

            if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
              createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
            }

            if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
              createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
            }

            setSpecies(CONSTRUCTOR_NAME);
          };
        } else
          module.exports = function() {
            /* empty */
          };
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/descriptors': '../../../node_modules/core-js/internals/descriptors.js',
        '../internals/typed-array-constructors-require-wrappers':
          '../../../node_modules/core-js/internals/typed-array-constructors-require-wrappers.js',
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-buffer': '../../../node_modules/core-js/internals/array-buffer.js',
        '../internals/an-instance': '../../../node_modules/core-js/internals/an-instance.js',
        '../internals/create-property-descriptor':
          '../../../node_modules/core-js/internals/create-property-descriptor.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-index': '../../../node_modules/core-js/internals/to-index.js',
        '../internals/to-offset': '../../../node_modules/core-js/internals/to-offset.js',
        '../internals/to-primitive': '../../../node_modules/core-js/internals/to-primitive.js',
        '../internals/has': '../../../node_modules/core-js/internals/has.js',
        '../internals/classof': '../../../node_modules/core-js/internals/classof.js',
        '../internals/is-object': '../../../node_modules/core-js/internals/is-object.js',
        '../internals/object-create': '../../../node_modules/core-js/internals/object-create.js',
        '../internals/object-set-prototype-of': '../../../node_modules/core-js/internals/object-set-prototype-of.js',
        '../internals/object-get-own-property-names':
          '../../../node_modules/core-js/internals/object-get-own-property-names.js',
        '../internals/typed-array-from': '../../../node_modules/core-js/internals/typed-array-from.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/set-species': '../../../node_modules/core-js/internals/set-species.js',
        '../internals/object-define-property': '../../../node_modules/core-js/internals/object-define-property.js',
        '../internals/object-get-own-property-descriptor':
          '../../../node_modules/core-js/internals/object-get-own-property-descriptor.js',
        '../internals/internal-state': '../../../node_modules/core-js/internals/internal-state.js',
        '../internals/inherit-if-required': '../../../node_modules/core-js/internals/inherit-if-required.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.uint8-array.js': [
      function(require, module, exports) {
        var createTypedArrayConstructor = require('../internals/typed-array-constructor');

        // `Uint8Array` constructor
        // https://tc39.github.io/ecma262/#sec-typedarray-objects
        createTypedArrayConstructor('Uint8', function(init) {
          return function Uint8Array(data, byteOffset, length) {
            return init(this, data, byteOffset, length);
          };
        });
      },
      { '../internals/typed-array-constructor': '../../../node_modules/core-js/internals/typed-array-constructor.js' },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.copy-within.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $copyWithin = require('../internals/array-copy-within');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.copyWithin` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
        exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
          return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-copy-within': '../../../node_modules/core-js/internals/array-copy-within.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.every.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $every = require('../internals/array-iteration').every;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.every` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
        exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
          return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.fill.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $fill = require('../internals/array-fill');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.fill` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
        // eslint-disable-next-line no-unused-vars
        exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
          return $fill.apply(aTypedArray(this), arguments);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-fill': '../../../node_modules/core-js/internals/array-fill.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.filter.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $filter = require('../internals/array-iteration').filter;
        var speciesConstructor = require('../internals/species-constructor');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.filter` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
        exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
          var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          var C = speciesConstructor(this, this.constructor);
          var index = 0;
          var length = list.length;
          var result = new (aTypedArrayConstructor(C))(length);
          while (length > index) result[index] = list[index++];
          return result;
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/species-constructor': '../../../node_modules/core-js/internals/species-constructor.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.find.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $find = require('../internals/array-iteration').find;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.find` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
        exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
          return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.find-index.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $findIndex = require('../internals/array-iteration').findIndex;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.findIndex` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
        exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
          return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.for-each.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $forEach = require('../internals/array-iteration').forEach;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.forEach` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
        exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
          $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.includes.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $includes = require('../internals/array-includes').includes;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.includes` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
        exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
          return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-includes': '../../../node_modules/core-js/internals/array-includes.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.index-of.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $indexOf = require('../internals/array-includes').indexOf;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.indexOf` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
        exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
          return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-includes': '../../../node_modules/core-js/internals/array-includes.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.iterator.js': [
      function(require, module, exports) {
        'use strict';
        var global = require('../internals/global');
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var ArrayIterators = require('../modules/es.array.iterator');
        var wellKnownSymbol = require('../internals/well-known-symbol');

        var ITERATOR = wellKnownSymbol('iterator');
        var Uint8Array = global.Uint8Array;
        var arrayValues = ArrayIterators.values;
        var arrayKeys = ArrayIterators.keys;
        var arrayEntries = ArrayIterators.entries;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

        var CORRECT_ITER_NAME =
          !!nativeTypedArrayIterator &&
          (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

        var typedArrayValues = function values() {
          return arrayValues.call(aTypedArray(this));
        };

        // `%TypedArray%.prototype.entries` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
        exportTypedArrayMethod('entries', function entries() {
          return arrayEntries.call(aTypedArray(this));
        });
        // `%TypedArray%.prototype.keys` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
        exportTypedArrayMethod('keys', function keys() {
          return arrayKeys.call(aTypedArray(this));
        });
        // `%TypedArray%.prototype.values` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
        exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
        // `%TypedArray%.prototype[@@iterator]` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
        exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../modules/es.array.iterator': '../../../node_modules/core-js/modules/es.array.iterator.js',
        '../internals/well-known-symbol': '../../../node_modules/core-js/internals/well-known-symbol.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.join.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $join = [].join;

        // `%TypedArray%.prototype.join` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
        // eslint-disable-next-line no-unused-vars
        exportTypedArrayMethod('join', function join(separator) {
          return $join.apply(aTypedArray(this), arguments);
        });
      },
      { '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js' },
    ],
    '../../../node_modules/core-js/internals/array-last-index-of.js': [
      function(require, module, exports) {
        'use strict';
        var toIndexedObject = require('../internals/to-indexed-object');
        var toInteger = require('../internals/to-integer');
        var toLength = require('../internals/to-length');
        var arrayMethodIsStrict = require('../internals/array-method-is-strict');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var min = Math.min;
        var nativeLastIndexOf = [].lastIndexOf;
        var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
        var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
        // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
        var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
        var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH;

        // `Array.prototype.lastIndexOf` method implementation
        // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
        module.exports = FORCED
          ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
              // convert -0 to +0
              if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
              var O = toIndexedObject(this);
              var length = toLength(O.length);
              var index = length - 1;
              if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
              if (index < 0) index = length + index;
              for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
              return -1;
            }
          : nativeLastIndexOf;
      },
      {
        '../internals/to-indexed-object': '../../../node_modules/core-js/internals/to-indexed-object.js',
        '../internals/to-integer': '../../../node_modules/core-js/internals/to-integer.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/array-method-is-strict': '../../../node_modules/core-js/internals/array-method-is-strict.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.last-index-of.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $lastIndexOf = require('../internals/array-last-index-of');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.lastIndexOf` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
        // eslint-disable-next-line no-unused-vars
        exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
          return $lastIndexOf.apply(aTypedArray(this), arguments);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-last-index-of': '../../../node_modules/core-js/internals/array-last-index-of.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.map.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $map = require('../internals/array-iteration').map;
        var speciesConstructor = require('../internals/species-constructor');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.map` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
        exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
          return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function(O, length) {
            return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
          });
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/species-constructor': '../../../node_modules/core-js/internals/species-constructor.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-reduce.js': [
      function(require, module, exports) {
        var aFunction = require('../internals/a-function');
        var toObject = require('../internals/to-object');
        var IndexedObject = require('../internals/indexed-object');
        var toLength = require('../internals/to-length');

        // `Array.prototype.{ reduce, reduceRight }` methods implementation
        var createMethod = function(IS_RIGHT) {
          return function(that, callbackfn, argumentsLength, memo) {
            aFunction(callbackfn);
            var O = toObject(that);
            var self = IndexedObject(O);
            var length = toLength(O.length);
            var index = IS_RIGHT ? length - 1 : 0;
            var i = IS_RIGHT ? -1 : 1;
            if (argumentsLength < 2)
              while (true) {
                if (index in self) {
                  memo = self[index];
                  index += i;
                  break;
                }
                index += i;
                if (IS_RIGHT ? index < 0 : length <= index) {
                  throw TypeError('Reduce of empty array with no initial value');
                }
              }
            for (; IS_RIGHT ? index >= 0 : length > index; index += i)
              if (index in self) {
                memo = callbackfn(memo, self[index], index, O);
              }
            return memo;
          };
        };

        module.exports = {
          // `Array.prototype.reduce` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
          left: createMethod(false),
          // `Array.prototype.reduceRight` method
          // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
          right: createMethod(true),
        };
      },
      {
        '../internals/a-function': '../../../node_modules/core-js/internals/a-function.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/indexed-object': '../../../node_modules/core-js/internals/indexed-object.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.reduce.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $reduce = require('../internals/array-reduce').left;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.reduce` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
        exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
          return $reduce(
            aTypedArray(this),
            callbackfn,
            arguments.length,
            arguments.length > 1 ? arguments[1] : undefined
          );
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-reduce': '../../../node_modules/core-js/internals/array-reduce.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.reduce-right.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $reduceRight = require('../internals/array-reduce').right;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.reduceRicht` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
        exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
          return $reduceRight(
            aTypedArray(this),
            callbackfn,
            arguments.length,
            arguments.length > 1 ? arguments[1] : undefined
          );
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-reduce': '../../../node_modules/core-js/internals/array-reduce.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.reverse.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var floor = Math.floor;

        // `%TypedArray%.prototype.reverse` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
        exportTypedArrayMethod('reverse', function reverse() {
          var that = this;
          var length = aTypedArray(that).length;
          var middle = floor(length / 2);
          var index = 0;
          var value;
          while (index < middle) {
            value = that[index];
            that[index++] = that[--length];
            that[length] = value;
          }
          return that;
        });
      },
      { '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js' },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.set.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var toLength = require('../internals/to-length');
        var toOffset = require('../internals/to-offset');
        var toObject = require('../internals/to-object');
        var fails = require('../internals/fails');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        var FORCED = fails(function() {
          // eslint-disable-next-line no-undef
          new Int8Array(1).set({});
        });

        // `%TypedArray%.prototype.set` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
        exportTypedArrayMethod(
          'set',
          function set(arrayLike /* , offset */) {
            aTypedArray(this);
            var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
            var length = this.length;
            var src = toObject(arrayLike);
            var len = toLength(src.length);
            var index = 0;
            if (len + offset > length) throw RangeError('Wrong length');
            while (index < len) this[offset + index] = src[index++];
          },
          FORCED
        );
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-offset': '../../../node_modules/core-js/internals/to-offset.js',
        '../internals/to-object': '../../../node_modules/core-js/internals/to-object.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.slice.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var speciesConstructor = require('../internals/species-constructor');
        var fails = require('../internals/fails');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $slice = [].slice;

        var FORCED = fails(function() {
          // eslint-disable-next-line no-undef
          new Int8Array(1).slice();
        });

        // `%TypedArray%.prototype.slice` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
        exportTypedArrayMethod(
          'slice',
          function slice(start, end) {
            var list = $slice.call(aTypedArray(this), start, end);
            var C = speciesConstructor(this, this.constructor);
            var index = 0;
            var length = list.length;
            var result = new (aTypedArrayConstructor(C))(length);
            while (length > index) result[index] = list[index++];
            return result;
          },
          FORCED
        );
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/species-constructor': '../../../node_modules/core-js/internals/species-constructor.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.some.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var $some = require('../internals/array-iteration').some;

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.some` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
        exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
          return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.sort.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $sort = [].sort;

        // `%TypedArray%.prototype.sort` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
        exportTypedArrayMethod('sort', function sort(comparefn) {
          return $sort.call(aTypedArray(this), comparefn);
        });
      },
      { '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js' },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.subarray.js': [
      function(require, module, exports) {
        'use strict';
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var toLength = require('../internals/to-length');
        var toAbsoluteIndex = require('../internals/to-absolute-index');
        var speciesConstructor = require('../internals/species-constructor');

        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

        // `%TypedArray%.prototype.subarray` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
        exportTypedArrayMethod('subarray', function subarray(begin, end) {
          var O = aTypedArray(this);
          var length = O.length;
          var beginIndex = toAbsoluteIndex(begin, length);
          return new (speciesConstructor(O, O.constructor))(
            O.buffer,
            O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
            toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
          );
        });
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/to-length': '../../../node_modules/core-js/internals/to-length.js',
        '../internals/to-absolute-index': '../../../node_modules/core-js/internals/to-absolute-index.js',
        '../internals/species-constructor': '../../../node_modules/core-js/internals/species-constructor.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.to-locale-string.js': [
      function(require, module, exports) {
        'use strict';
        var global = require('../internals/global');
        var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
        var fails = require('../internals/fails');

        var Int8Array = global.Int8Array;
        var aTypedArray = ArrayBufferViewCore.aTypedArray;
        var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
        var $toLocaleString = [].toLocaleString;
        var $slice = [].slice;

        // iOS Safari 6.x fails here
        var TO_LOCALE_STRING_BUG =
          !!Int8Array &&
          fails(function() {
            $toLocaleString.call(new Int8Array(1));
          });

        var FORCED =
          fails(function() {
            return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
          }) ||
          !fails(function() {
            Int8Array.prototype.toLocaleString.call([1, 2]);
          });

        // `%TypedArray%.prototype.toLocaleString` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
        exportTypedArrayMethod(
          'toLocaleString',
          function toLocaleString() {
            return $toLocaleString.apply(
              TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this),
              arguments
            );
          },
          FORCED
        );
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.typed-array.to-string.js': [
      function(require, module, exports) {
        'use strict';
        var exportTypedArrayMethod = require('../internals/array-buffer-view-core').exportTypedArrayMethod;
        var fails = require('../internals/fails');
        var global = require('../internals/global');

        var Uint8Array = global.Uint8Array;
        var Uint8ArrayPrototype = (Uint8Array && Uint8Array.prototype) || {};
        var arrayToString = [].toString;
        var arrayJoin = [].join;

        if (
          fails(function() {
            arrayToString.call({});
          })
        ) {
          arrayToString = function toString() {
            return arrayJoin.call(this);
          };
        }

        var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

        // `%TypedArray%.prototype.toString` method
        // https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
        exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);
      },
      {
        '../internals/array-buffer-view-core': '../../../node_modules/core-js/internals/array-buffer-view-core.js',
        '../internals/fails': '../../../node_modules/core-js/internals/fails.js',
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
      },
    ],
    '../../../node_modules/core-js/internals/array-for-each.js': [
      function(require, module, exports) {
        'use strict';
        var $forEach = require('../internals/array-iteration').forEach;
        var arrayMethodIsStrict = require('../internals/array-method-is-strict');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var STRICT_METHOD = arrayMethodIsStrict('forEach');
        var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

        // `Array.prototype.forEach` method implementation
        // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
        module.exports =
          !STRICT_METHOD || !USES_TO_LENGTH
            ? function forEach(callbackfn /* , thisArg */) {
                return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
              }
            : [].forEach;
      },
      {
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/array-method-is-strict': '../../../node_modules/core-js/internals/array-method-is-strict.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../node_modules/core-js/modules/web.dom-collections.for-each.js': [
      function(require, module, exports) {
        var global = require('../internals/global');
        var DOMIterables = require('../internals/dom-iterables');
        var forEach = require('../internals/array-for-each');
        var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

        for (var COLLECTION_NAME in DOMIterables) {
          var Collection = global[COLLECTION_NAME];
          var CollectionPrototype = Collection && Collection.prototype;
          // some Chrome versions have non-configurable methods on DOMTokenList
          if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
            try {
              createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
            } catch (error) {
              CollectionPrototype.forEach = forEach;
            }
        }
      },
      {
        '../internals/global': '../../../node_modules/core-js/internals/global.js',
        '../internals/dom-iterables': '../../../node_modules/core-js/internals/dom-iterables.js',
        '../internals/array-for-each': '../../../node_modules/core-js/internals/array-for-each.js',
        '../internals/create-non-enumerable-property':
          '../../../node_modules/core-js/internals/create-non-enumerable-property.js',
      },
    ],
    '../../../node_modules/tslib/tslib.es6.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.__extends = __extends;
        exports.__rest = __rest;
        exports.__decorate = __decorate;
        exports.__param = __param;
        exports.__metadata = __metadata;
        exports.__awaiter = __awaiter;
        exports.__generator = __generator;
        exports.__exportStar = __exportStar;
        exports.__values = __values;
        exports.__read = __read;
        exports.__spread = __spread;
        exports.__spreadArrays = __spreadArrays;
        exports.__await = __await;
        exports.__asyncGenerator = __asyncGenerator;
        exports.__asyncDelegator = __asyncDelegator;
        exports.__asyncValues = __asyncValues;
        exports.__makeTemplateObject = __makeTemplateObject;
        exports.__importStar = __importStar;
        exports.__importDefault = __importDefault;
        exports.__assign = void 0;

        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

        /* global Reflect, Promise */
        var extendStatics = function(d, b) {
          extendStatics =
            Object.setPrototypeOf ||
            ({
              __proto__: [],
            } instanceof Array &&
              function(d, b) {
                d.__proto__ = b;
              }) ||
            function(d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };

          return extendStatics(d, b);
        };

        function __extends(d, b) {
          extendStatics(d, b);

          function __() {
            this.constructor = d;
          }

          d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
        }

        var __assign = function() {
          exports.__assign = __assign =
            Object.assign ||
            function __assign(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];

                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }

              return t;
            };

          return __assign.apply(this, arguments);
        };

        exports.__assign = __assign;

        function __rest(s, e) {
          var t = {};

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

          if (s != null && typeof Object.getOwnPropertySymbols === 'function')
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
            }
          return t;
        }

        function __decorate(decorators, target, key, desc) {
          var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
          if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        }

        function __param(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        }

        function __metadata(metadataKey, metadataValue) {
          if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
            return Reflect.metadata(metadataKey, metadataValue);
        }

        function __awaiter(thisArg, _arguments, P, generator) {
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }

            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }

            function step(result) {
              result.done
                ? resolve(result.value)
                : new P(function(resolve) {
                    resolve(result.value);
                  }).then(fulfilled, rejected);
            }

            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }

        function __generator(thisArg, body) {
          var _ = {
              label: 0,
              sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
              },
              trys: [],
              ops: [],
            },
            f,
            y,
            t,
            g;
          return (
            (g = {
              next: verb(0),
              throw: verb(1),
              return: verb(2),
            }),
            typeof Symbol === 'function' &&
              (g[Symbol.iterator] = function() {
                return this;
              }),
            g
          );

          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }

          function step(op) {
            if (f) throw new TypeError('Generator is already executing.');

            while (_)
              try {
                if (
                  ((f = 1),
                  y &&
                    (t =
                      op[0] & 2 ? y['return'] : op[0] ? y['throw'] || ((t = y['return']) && t.call(y), 0) : y.next) &&
                    !(t = t.call(y, op[1])).done)
                )
                  return t;
                if (((y = 0), t)) op = [op[0] & 2, t.value];

                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;

                  case 4:
                    _.label++;
                    return {
                      value: op[1],
                      done: false,
                    };

                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;

                  case 7:
                    op = _.ops.pop();

                    _.trys.pop();

                    continue;

                  default:
                    if (!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }

                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                      _.label = op[1];
                      break;
                    }

                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }

                    if (t && _.label < t[2]) {
                      _.label = t[2];

                      _.ops.push(op);

                      break;
                    }

                    if (t[2]) _.ops.pop();

                    _.trys.pop();

                    continue;
                }

                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }

            if (op[0] & 5) throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true,
            };
          }
        }

        function __exportStar(m, exports) {
          for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }

        function __values(o) {
          var m = typeof Symbol === 'function' && o[Symbol.iterator],
            i = 0;
          if (m) return m.call(o);
          return {
            next: function() {
              if (o && i >= o.length) o = void 0;
              return {
                value: o && o[i++],
                done: !o,
              };
            },
          };
        }

        function __read(o, n) {
          var m = typeof Symbol === 'function' && o[Symbol.iterator];
          if (!m) return o;
          var i = m.call(o),
            r,
            ar = [],
            e;

          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
          } catch (error) {
            e = {
              error: error,
            };
          } finally {
            try {
              if (r && !r.done && (m = i['return'])) m.call(i);
            } finally {
              if (e) throw e.error;
            }
          }

          return ar;
        }

        function __spread() {
          for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

          return ar;
        }

        function __spreadArrays() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

          return r;
        }

        function __await(v) {
          return this instanceof __await ? ((this.v = v), this) : new __await(v);
        }

        function __asyncGenerator(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
          var g = generator.apply(thisArg, _arguments || []),
            i,
            q = [];
          return (
            (i = {}),
            verb('next'),
            verb('throw'),
            verb('return'),
            (i[Symbol.asyncIterator] = function() {
              return this;
            }),
            i
          );

          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }

          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }

          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }

          function fulfill(value) {
            resume('next', value);
          }

          function reject(value) {
            resume('throw', value);
          }

          function settle(f, v) {
            if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
          }
        }

        function __asyncDelegator(o) {
          var i, p;
          return (
            (i = {}),
            verb('next'),
            verb('throw', function(e) {
              throw e;
            }),
            verb('return'),
            (i[Symbol.iterator] = function() {
              return this;
            }),
            i
          );

          function verb(n, f) {
            i[n] = o[n]
              ? function(v) {
                  return (p = !p)
                    ? {
                        value: __await(o[n](v)),
                        done: n === 'return',
                      }
                    : f
                    ? f(v)
                    : v;
                }
              : f;
          }
        }

        function __asyncValues(o) {
          if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
          var m = o[Symbol.asyncIterator],
            i;
          return m
            ? m.call(o)
            : ((o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator]()),
              (i = {}),
              verb('next'),
              verb('throw'),
              verb('return'),
              (i[Symbol.asyncIterator] = function() {
                return this;
              }),
              i);

          function verb(n) {
            i[n] =
              o[n] &&
              function(v) {
                return new Promise(function(resolve, reject) {
                  (v = o[n](v)), settle(resolve, reject, v.done, v.value);
                });
              };
          }

          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v) {
              resolve({
                value: v,
                done: d,
              });
            }, reject);
          }
        }

        function __makeTemplateObject(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, 'raw', {
              value: raw,
            });
          } else {
            cooked.raw = raw;
          }

          return cooked;
        }

        function __importStar(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          result.default = mod;
          return result;
        }

        function __importDefault(mod) {
          return mod && mod.__esModule
            ? mod
            : {
                default: mod,
              };
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isFunction.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isFunction = isFunction;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isFunction(x) {
          return typeof x === 'function';
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/config.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.config = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var _enable_super_gross_mode_that_will_cause_bad_things = false;
        var config = {
          Promise: undefined,

          set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
              var error =
                /*@__PURE__*/
                new Error();
              /*@__PURE__*/

              console.warn(
                'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
                  error.stack
              );
            } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
              /*@__PURE__*/
              console.log('RxJS: Back to a better error behavior. Thank you. <3');
            }

            _enable_super_gross_mode_that_will_cause_bad_things = value;
          },

          get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
          },
        };
        exports.config = config;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.hostReportError = hostReportError;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function hostReportError(err) {
          setTimeout(function() {
            throw err;
          }, 0);
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/Observer.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.empty = void 0;

        var _config = require('./config');

        var _hostReportError = require('./util/hostReportError');

        /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
        var empty = {
          closed: true,
          next: function(value) {},
          error: function(err) {
            if (_config.config.useDeprecatedSynchronousErrorHandling) {
              throw err;
            } else {
              (0, _hostReportError.hostReportError)(err);
            }
          },
          complete: function() {},
        };
        exports.empty = empty;
      },
      {
        './config': '../../../node_modules/rxjs/_esm5/internal/config.js',
        './util/hostReportError': '../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isArray.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isArray = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArray =
          /*@__PURE__*/
          (function() {
            return (
              Array.isArray ||
              function(x) {
                return x && typeof x.length === 'number';
              }
            );
          })();

        exports.isArray = isArray;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isObject.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isObject = isObject;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isObject(x) {
          return x !== null && typeof x === 'object';
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.UnsubscriptionError = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var UnsubscriptionErrorImpl =
          /*@__PURE__*/
          (function() {
            function UnsubscriptionErrorImpl(errors) {
              Error.call(this);
              this.message = errors
                ? errors.length +
                  ' errors occurred during unsubscription:\n' +
                  errors
                    .map(function(err, i) {
                      return i + 1 + ') ' + err.toString();
                    })
                    .join('\n  ')
                : '';
              this.name = 'UnsubscriptionError';
              this.errors = errors;
              return this;
            }

            UnsubscriptionErrorImpl.prototype =
              /*@__PURE__*/
              Object.create(Error.prototype);
            return UnsubscriptionErrorImpl;
          })();

        var UnsubscriptionError = UnsubscriptionErrorImpl;
        exports.UnsubscriptionError = UnsubscriptionError;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/Subscription.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.Subscription = void 0;

        var _isArray = require('./util/isArray');

        var _isObject = require('./util/isObject');

        var _isFunction = require('./util/isFunction');

        var _UnsubscriptionError = require('./util/UnsubscriptionError');

        /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
        var Subscription =
          /*@__PURE__*/
          (function() {
            function Subscription(unsubscribe) {
              this.closed = false;
              this._parentOrParents = null;
              this._subscriptions = null;

              if (unsubscribe) {
                this._unsubscribe = unsubscribe;
              }
            }

            Subscription.prototype.unsubscribe = function() {
              var errors;

              if (this.closed) {
                return;
              }

              var _a = this,
                _parentOrParents = _a._parentOrParents,
                _unsubscribe = _a._unsubscribe,
                _subscriptions = _a._subscriptions;

              this.closed = true;
              this._parentOrParents = null;
              this._subscriptions = null;

              if (_parentOrParents instanceof Subscription) {
                _parentOrParents.remove(this);
              } else if (_parentOrParents !== null) {
                for (var index = 0; index < _parentOrParents.length; ++index) {
                  var parent_1 = _parentOrParents[index];
                  parent_1.remove(this);
                }
              }

              if ((0, _isFunction.isFunction)(_unsubscribe)) {
                try {
                  _unsubscribe.call(this);
                } catch (e) {
                  errors =
                    e instanceof _UnsubscriptionError.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
              }

              if ((0, _isArray.isArray)(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;

                while (++index < len) {
                  var sub = _subscriptions[index];

                  if ((0, _isObject.isObject)(sub)) {
                    try {
                      sub.unsubscribe();
                    } catch (e) {
                      errors = errors || [];

                      if (e instanceof _UnsubscriptionError.UnsubscriptionError) {
                        errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                      } else {
                        errors.push(e);
                      }
                    }
                  }
                }
              }

              if (errors) {
                throw new _UnsubscriptionError.UnsubscriptionError(errors);
              }
            };

            Subscription.prototype.add = function(teardown) {
              var subscription = teardown;

              if (!teardown) {
                return Subscription.EMPTY;
              }

              switch (typeof teardown) {
                case 'function':
                  subscription = new Subscription(teardown);

                case 'object':
                  if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                  } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                  } else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                  }

                  break;

                default: {
                  throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
              }

              var _parentOrParents = subscription._parentOrParents;

              if (_parentOrParents === null) {
                subscription._parentOrParents = this;
              } else if (_parentOrParents instanceof Subscription) {
                if (_parentOrParents === this) {
                  return subscription;
                }

                subscription._parentOrParents = [_parentOrParents, this];
              } else if (_parentOrParents.indexOf(this) === -1) {
                _parentOrParents.push(this);
              } else {
                return subscription;
              }

              var subscriptions = this._subscriptions;

              if (subscriptions === null) {
                this._subscriptions = [subscription];
              } else {
                subscriptions.push(subscription);
              }

              return subscription;
            };

            Subscription.prototype.remove = function(subscription) {
              var subscriptions = this._subscriptions;

              if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);

                if (subscriptionIndex !== -1) {
                  subscriptions.splice(subscriptionIndex, 1);
                }
              }
            };

            Subscription.EMPTY = (function(empty) {
              empty.closed = true;
              return empty;
            })(new Subscription());

            return Subscription;
          })();

        exports.Subscription = Subscription;

        function flattenUnsubscriptionErrors(errors) {
          return errors.reduce(function(errs, err) {
            return errs.concat(err instanceof _UnsubscriptionError.UnsubscriptionError ? err.errors : err);
          }, []);
        }
      },
      {
        './util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        './util/isObject': '../../../node_modules/rxjs/_esm5/internal/util/isObject.js',
        './util/isFunction': '../../../node_modules/rxjs/_esm5/internal/util/isFunction.js',
        './util/UnsubscriptionError': '../../../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.$$rxSubscriber = exports.rxSubscriber = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var rxSubscriber =
          /*@__PURE__*/
          (function() {
            return typeof Symbol === 'function'
              ? /*@__PURE__*/
                Symbol('rxSubscriber')
              : '@@rxSubscriber_' +
                  /*@__PURE__*/
                  Math.random();
          })();

        exports.rxSubscriber = rxSubscriber;
        var $$rxSubscriber = rxSubscriber;
        exports.$$rxSubscriber = $$rxSubscriber;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/Subscriber.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.SafeSubscriber = exports.Subscriber = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _isFunction = require('./util/isFunction');

        var _Observer = require('./Observer');

        var _Subscription = require('./Subscription');

        var _rxSubscriber = require('../internal/symbol/rxSubscriber');

        var _config = require('./config');

        var _hostReportError = require('./util/hostReportError');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
        var Subscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(Subscriber, _super);

            function Subscriber(destinationOrNext, error, complete) {
              var _this = _super.call(this) || this;

              _this.syncErrorValue = null;
              _this.syncErrorThrown = false;
              _this.syncErrorThrowable = false;
              _this.isStopped = false;

              switch (arguments.length) {
                case 0:
                  _this.destination = _Observer.empty;
                  break;

                case 1:
                  if (!destinationOrNext) {
                    _this.destination = _Observer.empty;
                    break;
                  }

                  if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                      _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                      _this.destination = destinationOrNext;
                      destinationOrNext.add(_this);
                    } else {
                      _this.syncErrorThrowable = true;
                      _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }

                    break;
                  }

                default:
                  _this.syncErrorThrowable = true;
                  _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                  break;
              }

              return _this;
            }

            Subscriber.prototype[_rxSubscriber.rxSubscriber] = function() {
              return this;
            };

            Subscriber.create = function(next, error, complete) {
              var subscriber = new Subscriber(next, error, complete);
              subscriber.syncErrorThrowable = false;
              return subscriber;
            };

            Subscriber.prototype.next = function(value) {
              if (!this.isStopped) {
                this._next(value);
              }
            };

            Subscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                this.isStopped = true;

                this._error(err);
              }
            };

            Subscriber.prototype.complete = function() {
              if (!this.isStopped) {
                this.isStopped = true;

                this._complete();
              }
            };

            Subscriber.prototype.unsubscribe = function() {
              if (this.closed) {
                return;
              }

              this.isStopped = true;

              _super.prototype.unsubscribe.call(this);
            };

            Subscriber.prototype._next = function(value) {
              this.destination.next(value);
            };

            Subscriber.prototype._error = function(err) {
              this.destination.error(err);
              this.unsubscribe();
            };

            Subscriber.prototype._complete = function() {
              this.destination.complete();
              this.unsubscribe();
            };

            Subscriber.prototype._unsubscribeAndRecycle = function() {
              var _parentOrParents = this._parentOrParents;
              this._parentOrParents = null;
              this.unsubscribe();
              this.closed = false;
              this.isStopped = false;
              this._parentOrParents = _parentOrParents;
              return this;
            };

            return Subscriber;
          })(_Subscription.Subscription);

        exports.Subscriber = Subscriber;

        var SafeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SafeSubscriber, _super);

            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
              var _this = _super.call(this) || this;

              _this._parentSubscriber = _parentSubscriber;
              var next;
              var context = _this;

              if ((0, _isFunction.isFunction)(observerOrNext)) {
                next = observerOrNext;
              } else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;

                if (observerOrNext !== _Observer.empty) {
                  context = Object.create(observerOrNext);

                  if ((0, _isFunction.isFunction)(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                  }

                  context.unsubscribe = _this.unsubscribe.bind(_this);
                }
              }

              _this._context = context;
              _this._next = next;
              _this._error = error;
              _this._complete = complete;
              return _this;
            }

            SafeSubscriber.prototype.next = function(value) {
              if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;

                if (!_config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                  this.__tryOrUnsub(this._next, value);
                } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                  this.unsubscribe();
                }
              }
            };

            SafeSubscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = _config.config.useDeprecatedSynchronousErrorHandling;

                if (this._error) {
                  if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);

                    this.unsubscribe();
                  } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);

                    this.unsubscribe();
                  }
                } else if (!_parentSubscriber.syncErrorThrowable) {
                  this.unsubscribe();

                  if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                  }

                  (0, _hostReportError.hostReportError)(err);
                } else {
                  if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                  } else {
                    (0, _hostReportError.hostReportError)(err);
                  }

                  this.unsubscribe();
                }
              }
            };

            SafeSubscriber.prototype.complete = function() {
              var _this = this;

              if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;

                if (this._complete) {
                  var wrappedComplete = function() {
                    return _this._complete.call(_this._context);
                  };

                  if (!_config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);

                    this.unsubscribe();
                  } else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);

                    this.unsubscribe();
                  }
                } else {
                  this.unsubscribe();
                }
              }
            };

            SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
              try {
                fn.call(this._context, value);
              } catch (err) {
                this.unsubscribe();

                if (_config.config.useDeprecatedSynchronousErrorHandling) {
                  throw err;
                } else {
                  (0, _hostReportError.hostReportError)(err);
                }
              }
            };

            SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
              if (!_config.config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
              }

              try {
                fn.call(this._context, value);
              } catch (err) {
                if (_config.config.useDeprecatedSynchronousErrorHandling) {
                  parent.syncErrorValue = err;
                  parent.syncErrorThrown = true;
                  return true;
                } else {
                  (0, _hostReportError.hostReportError)(err);
                  return true;
                }
              }

              return false;
            };

            SafeSubscriber.prototype._unsubscribe = function() {
              var _parentSubscriber = this._parentSubscriber;
              this._context = null;
              this._parentSubscriber = null;

              _parentSubscriber.unsubscribe();
            };

            return SafeSubscriber;
          })(Subscriber);

        exports.SafeSubscriber = SafeSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './util/isFunction': '../../../node_modules/rxjs/_esm5/internal/util/isFunction.js',
        './Observer': '../../../node_modules/rxjs/_esm5/internal/Observer.js',
        './Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../internal/symbol/rxSubscriber': '../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js',
        './config': '../../../node_modules/rxjs/_esm5/internal/config.js',
        './util/hostReportError': '../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/canReportError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.canReportError = canReportError;

        var _Subscriber = require('../Subscriber');

        /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
        function canReportError(observer) {
          while (observer) {
            var _a = observer,
              closed_1 = _a.closed,
              destination = _a.destination,
              isStopped = _a.isStopped;

            if (closed_1 || isStopped) {
              return false;
            } else if (destination && destination instanceof _Subscriber.Subscriber) {
              observer = destination;
            } else {
              observer = null;
            }
          }

          return true;
        }
      },
      { '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/toSubscriber.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.toSubscriber = toSubscriber;

        var _Subscriber = require('../Subscriber');

        var _rxSubscriber = require('../symbol/rxSubscriber');

        var _Observer = require('../Observer');

        /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
        function toSubscriber(nextOrObserver, error, complete) {
          if (nextOrObserver) {
            if (nextOrObserver instanceof _Subscriber.Subscriber) {
              return nextOrObserver;
            }

            if (nextOrObserver[_rxSubscriber.rxSubscriber]) {
              return nextOrObserver[_rxSubscriber.rxSubscriber]();
            }
          }

          if (!nextOrObserver && !error && !complete) {
            return new _Subscriber.Subscriber(_Observer.empty);
          }

          return new _Subscriber.Subscriber(nextOrObserver, error, complete);
        }
      },
      {
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../symbol/rxSubscriber': '../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js',
        '../Observer': '../../../node_modules/rxjs/_esm5/internal/Observer.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.observable = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var observable =
          /*@__PURE__*/
          (function() {
            return (typeof Symbol === 'function' && Symbol.observable) || '@@observable';
          })();

        exports.observable = observable;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/noop.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.noop = noop;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function noop() {}
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/pipe.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.pipe = pipe;
        exports.pipeFromArray = pipeFromArray;

        var _noop = require('./noop');

        /** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
        function pipe() {
          var fns = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
          }

          return pipeFromArray(fns);
        }

        function pipeFromArray(fns) {
          if (!fns) {
            return _noop.noop;
          }

          if (fns.length === 1) {
            return fns[0];
          }

          return function piped(input) {
            return fns.reduce(function(prev, fn) {
              return fn(prev);
            }, input);
          };
        }
      },
      { './noop': '../../../node_modules/rxjs/_esm5/internal/util/noop.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/Observable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.Observable = void 0;

        var _canReportError = require('./util/canReportError');

        var _toSubscriber = require('./util/toSubscriber');

        var _observable = require('./symbol/observable');

        var _pipe = require('./util/pipe');

        var _config = require('./config');

        /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
        var Observable =
          /*@__PURE__*/
          (function() {
            function Observable(subscribe) {
              this._isScalar = false;

              if (subscribe) {
                this._subscribe = subscribe;
              }
            }

            Observable.prototype.lift = function(operator) {
              var observable = new Observable();
              observable.source = this;
              observable.operator = operator;
              return observable;
            };

            Observable.prototype.subscribe = function(observerOrNext, error, complete) {
              var operator = this.operator;
              var sink = (0, _toSubscriber.toSubscriber)(observerOrNext, error, complete);

              if (operator) {
                sink.add(operator.call(sink, this.source));
              } else {
                sink.add(
                  this.source || (_config.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable)
                    ? this._subscribe(sink)
                    : this._trySubscribe(sink)
                );
              }

              if (_config.config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                  sink.syncErrorThrowable = false;

                  if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                  }
                }
              }

              return sink;
            };

            Observable.prototype._trySubscribe = function(sink) {
              try {
                return this._subscribe(sink);
              } catch (err) {
                if (_config.config.useDeprecatedSynchronousErrorHandling) {
                  sink.syncErrorThrown = true;
                  sink.syncErrorValue = err;
                }

                if ((0, _canReportError.canReportError)(sink)) {
                  sink.error(err);
                } else {
                  console.warn(err);
                }
              }
            };

            Observable.prototype.forEach = function(next, promiseCtor) {
              var _this = this;

              promiseCtor = getPromiseCtor(promiseCtor);
              return new promiseCtor(function(resolve, reject) {
                var subscription;
                subscription = _this.subscribe(
                  function(value) {
                    try {
                      next(value);
                    } catch (err) {
                      reject(err);

                      if (subscription) {
                        subscription.unsubscribe();
                      }
                    }
                  },
                  reject,
                  resolve
                );
              });
            };

            Observable.prototype._subscribe = function(subscriber) {
              var source = this.source;
              return source && source.subscribe(subscriber);
            };

            Observable.prototype[_observable.observable] = function() {
              return this;
            };

            Observable.prototype.pipe = function() {
              var operations = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
              }

              if (operations.length === 0) {
                return this;
              }

              return (0, _pipe.pipeFromArray)(operations)(this);
            };

            Observable.prototype.toPromise = function(promiseCtor) {
              var _this = this;

              promiseCtor = getPromiseCtor(promiseCtor);
              return new promiseCtor(function(resolve, reject) {
                var value;

                _this.subscribe(
                  function(x) {
                    return (value = x);
                  },
                  function(err) {
                    return reject(err);
                  },
                  function() {
                    return resolve(value);
                  }
                );
              });
            };

            Observable.create = function(subscribe) {
              return new Observable(subscribe);
            };

            return Observable;
          })();

        exports.Observable = Observable;

        function getPromiseCtor(promiseCtor) {
          if (!promiseCtor) {
            promiseCtor = _config.config.Promise || Promise;
          }

          if (!promiseCtor) {
            throw new Error('no Promise impl found');
          }

          return promiseCtor;
        }
      },
      {
        './util/canReportError': '../../../node_modules/rxjs/_esm5/internal/util/canReportError.js',
        './util/toSubscriber': '../../../node_modules/rxjs/_esm5/internal/util/toSubscriber.js',
        './symbol/observable': '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js',
        './util/pipe': '../../../node_modules/rxjs/_esm5/internal/util/pipe.js',
        './config': '../../../node_modules/rxjs/_esm5/internal/config.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.ObjectUnsubscribedError = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var ObjectUnsubscribedErrorImpl =
          /*@__PURE__*/
          (function() {
            function ObjectUnsubscribedErrorImpl() {
              Error.call(this);
              this.message = 'object unsubscribed';
              this.name = 'ObjectUnsubscribedError';
              return this;
            }

            ObjectUnsubscribedErrorImpl.prototype =
              /*@__PURE__*/
              Object.create(Error.prototype);
            return ObjectUnsubscribedErrorImpl;
          })();

        var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
        exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/SubjectSubscription.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.SubjectSubscription = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscription = require('./Subscription');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
        var SubjectSubscription =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SubjectSubscription, _super);

            function SubjectSubscription(subject, subscriber) {
              var _this = _super.call(this) || this;

              _this.subject = subject;
              _this.subscriber = subscriber;
              _this.closed = false;
              return _this;
            }

            SubjectSubscription.prototype.unsubscribe = function() {
              if (this.closed) {
                return;
              }

              this.closed = true;
              var subject = this.subject;
              var observers = subject.observers;
              this.subject = null;

              if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
                return;
              }

              var subscriberIndex = observers.indexOf(this.subscriber);

              if (subscriberIndex !== -1) {
                observers.splice(subscriberIndex, 1);
              }
            };

            return SubjectSubscription;
          })(_Subscription.Subscription);

        exports.SubjectSubscription = SubjectSubscription;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/Subject.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AnonymousSubject = exports.Subject = exports.SubjectSubscriber = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Observable = require('./Observable');

        var _Subscriber = require('./Subscriber');

        var _Subscription = require('./Subscription');

        var _ObjectUnsubscribedError = require('./util/ObjectUnsubscribedError');

        var _SubjectSubscription = require('./SubjectSubscription');

        var _rxSubscriber = require('../internal/symbol/rxSubscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
        var SubjectSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SubjectSubscriber, _super);

            function SubjectSubscriber(destination) {
              var _this = _super.call(this, destination) || this;

              _this.destination = destination;
              return _this;
            }

            return SubjectSubscriber;
          })(_Subscriber.Subscriber);

        exports.SubjectSubscriber = SubjectSubscriber;

        var Subject =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(Subject, _super);

            function Subject() {
              var _this = _super.call(this) || this;

              _this.observers = [];
              _this.closed = false;
              _this.isStopped = false;
              _this.hasError = false;
              _this.thrownError = null;
              return _this;
            }

            Subject.prototype[_rxSubscriber.rxSubscriber] = function() {
              return new SubjectSubscriber(this);
            };

            Subject.prototype.lift = function(operator) {
              var subject = new AnonymousSubject(this, this);
              subject.operator = operator;
              return subject;
            };

            Subject.prototype.next = function(value) {
              if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              }

              if (!this.isStopped) {
                var observers = this.observers;
                var len = observers.length;
                var copy = observers.slice();

                for (var i = 0; i < len; i++) {
                  copy[i].next(value);
                }
              }
            };

            Subject.prototype.error = function(err) {
              if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              }

              this.hasError = true;
              this.thrownError = err;
              this.isStopped = true;
              var observers = this.observers;
              var len = observers.length;
              var copy = observers.slice();

              for (var i = 0; i < len; i++) {
                copy[i].error(err);
              }

              this.observers.length = 0;
            };

            Subject.prototype.complete = function() {
              if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              }

              this.isStopped = true;
              var observers = this.observers;
              var len = observers.length;
              var copy = observers.slice();

              for (var i = 0; i < len; i++) {
                copy[i].complete();
              }

              this.observers.length = 0;
            };

            Subject.prototype.unsubscribe = function() {
              this.isStopped = true;
              this.closed = true;
              this.observers = null;
            };

            Subject.prototype._trySubscribe = function(subscriber) {
              if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              } else {
                return _super.prototype._trySubscribe.call(this, subscriber);
              }
            };

            Subject.prototype._subscribe = function(subscriber) {
              if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              } else if (this.hasError) {
                subscriber.error(this.thrownError);
                return _Subscription.Subscription.EMPTY;
              } else if (this.isStopped) {
                subscriber.complete();
                return _Subscription.Subscription.EMPTY;
              } else {
                this.observers.push(subscriber);
                return new _SubjectSubscription.SubjectSubscription(this, subscriber);
              }
            };

            Subject.prototype.asObservable = function() {
              var observable = new _Observable.Observable();
              observable.source = this;
              return observable;
            };

            Subject.create = function(destination, source) {
              return new AnonymousSubject(destination, source);
            };

            return Subject;
          })(_Observable.Observable);

        exports.Subject = Subject;

        var AnonymousSubject =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AnonymousSubject, _super);

            function AnonymousSubject(destination, source) {
              var _this = _super.call(this) || this;

              _this.destination = destination;
              _this.source = source;
              return _this;
            }

            AnonymousSubject.prototype.next = function(value) {
              var destination = this.destination;

              if (destination && destination.next) {
                destination.next(value);
              }
            };

            AnonymousSubject.prototype.error = function(err) {
              var destination = this.destination;

              if (destination && destination.error) {
                this.destination.error(err);
              }
            };

            AnonymousSubject.prototype.complete = function() {
              var destination = this.destination;

              if (destination && destination.complete) {
                this.destination.complete();
              }
            };

            AnonymousSubject.prototype._subscribe = function(subscriber) {
              var source = this.source;

              if (source) {
                return this.source.subscribe(subscriber);
              } else {
                return _Subscription.Subscription.EMPTY;
              }
            };

            return AnonymousSubject;
          })(Subject);

        exports.AnonymousSubject = AnonymousSubject;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        './Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        './Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        './util/ObjectUnsubscribedError': '../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
        './SubjectSubscription': '../../../node_modules/rxjs/_esm5/internal/SubjectSubscription.js',
        '../internal/symbol/rxSubscriber': '../../../node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/refCount.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.refCount = refCount;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function refCount() {
          return function refCountOperatorFunction(source) {
            return source.lift(new RefCountOperator(source));
          };
        }

        var RefCountOperator =
          /*@__PURE__*/
          (function() {
            function RefCountOperator(connectable) {
              this.connectable = connectable;
            }

            RefCountOperator.prototype.call = function(subscriber, source) {
              var connectable = this.connectable;
              connectable._refCount++;
              var refCounter = new RefCountSubscriber(subscriber, connectable);
              var subscription = source.subscribe(refCounter);

              if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
              }

              return subscription;
            };

            return RefCountOperator;
          })();

        var RefCountSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RefCountSubscriber, _super);

            function RefCountSubscriber(destination, connectable) {
              var _this = _super.call(this, destination) || this;

              _this.connectable = connectable;
              return _this;
            }

            RefCountSubscriber.prototype._unsubscribe = function() {
              var connectable = this.connectable;

              if (!connectable) {
                this.connection = null;
                return;
              }

              this.connectable = null;
              var refCount = connectable._refCount;

              if (refCount <= 0) {
                this.connection = null;
                return;
              }

              connectable._refCount = refCount - 1;

              if (refCount > 1) {
                this.connection = null;
                return;
              }

              var connection = this.connection;
              var sharedConnection = connectable._connection;
              this.connection = null;

              if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
              }
            };

            return RefCountSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.connectableObservableDescriptor = exports.ConnectableObservable = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _Observable = require('../Observable');

        var _Subscriber = require('../Subscriber');

        var _Subscription = require('../Subscription');

        var _refCount = require('../operators/refCount');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
        var ConnectableObservable =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ConnectableObservable, _super);

            function ConnectableObservable(source, subjectFactory) {
              var _this = _super.call(this) || this;

              _this.source = source;
              _this.subjectFactory = subjectFactory;
              _this._refCount = 0;
              _this._isComplete = false;
              return _this;
            }

            ConnectableObservable.prototype._subscribe = function(subscriber) {
              return this.getSubject().subscribe(subscriber);
            };

            ConnectableObservable.prototype.getSubject = function() {
              var subject = this._subject;

              if (!subject || subject.isStopped) {
                this._subject = this.subjectFactory();
              }

              return this._subject;
            };

            ConnectableObservable.prototype.connect = function() {
              var connection = this._connection;

              if (!connection) {
                this._isComplete = false;
                connection = this._connection = new _Subscription.Subscription();
                connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

                if (connection.closed) {
                  this._connection = null;
                  connection = _Subscription.Subscription.EMPTY;
                }
              }

              return connection;
            };

            ConnectableObservable.prototype.refCount = function() {
              return (0, _refCount.refCount)()(this);
            };

            return ConnectableObservable;
          })(_Observable.Observable);

        exports.ConnectableObservable = ConnectableObservable;

        var connectableObservableDescriptor =
          /*@__PURE__*/
          (function() {
            var connectableProto = ConnectableObservable.prototype;
            return {
              operator: {
                value: null,
              },
              _refCount: {
                value: 0,
                writable: true,
              },
              _subject: {
                value: null,
                writable: true,
              },
              _connection: {
                value: null,
                writable: true,
              },
              _subscribe: {
                value: connectableProto._subscribe,
              },
              _isComplete: {
                value: connectableProto._isComplete,
                writable: true,
              },
              getSubject: {
                value: connectableProto.getSubject,
              },
              connect: {
                value: connectableProto.connect,
              },
              refCount: {
                value: connectableProto.refCount,
              },
            };
          })();

        exports.connectableObservableDescriptor = connectableObservableDescriptor;

        var ConnectableSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ConnectableSubscriber, _super);

            function ConnectableSubscriber(destination, connectable) {
              var _this = _super.call(this, destination) || this;

              _this.connectable = connectable;
              return _this;
            }

            ConnectableSubscriber.prototype._error = function(err) {
              this._unsubscribe();

              _super.prototype._error.call(this, err);
            };

            ConnectableSubscriber.prototype._complete = function() {
              this.connectable._isComplete = true;

              this._unsubscribe();

              _super.prototype._complete.call(this);
            };

            ConnectableSubscriber.prototype._unsubscribe = function() {
              var connectable = this.connectable;

              if (connectable) {
                this.connectable = null;
                var connection = connectable._connection;
                connectable._refCount = 0;
                connectable._subject = null;
                connectable._connection = null;

                if (connection) {
                  connection.unsubscribe();
                }
              }
            };

            return ConnectableSubscriber;
          })(_Subject.SubjectSubscriber);

        var RefCountOperator =
          /*@__PURE__*/
          (function() {
            function RefCountOperator(connectable) {
              this.connectable = connectable;
            }

            RefCountOperator.prototype.call = function(subscriber, source) {
              var connectable = this.connectable;
              connectable._refCount++;
              var refCounter = new RefCountSubscriber(subscriber, connectable);
              var subscription = source.subscribe(refCounter);

              if (!refCounter.closed) {
                refCounter.connection = connectable.connect();
              }

              return subscription;
            };

            return RefCountOperator;
          })();

        var RefCountSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RefCountSubscriber, _super);

            function RefCountSubscriber(destination, connectable) {
              var _this = _super.call(this, destination) || this;

              _this.connectable = connectable;
              return _this;
            }

            RefCountSubscriber.prototype._unsubscribe = function() {
              var connectable = this.connectable;

              if (!connectable) {
                this.connection = null;
                return;
              }

              this.connectable = null;
              var refCount = connectable._refCount;

              if (refCount <= 0) {
                this.connection = null;
                return;
              }

              connectable._refCount = refCount - 1;

              if (refCount > 1) {
                this.connection = null;
                return;
              }

              var connection = this.connection;
              var sharedConnection = connectable._connection;
              this.connection = null;

              if (sharedConnection && (!connection || sharedConnection === connection)) {
                sharedConnection.unsubscribe();
              }
            };

            return RefCountSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../operators/refCount': '../../../node_modules/rxjs/_esm5/internal/operators/refCount.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/groupBy.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.groupBy = groupBy;
        exports.GroupedObservable = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _Subscription = require('../Subscription');

        var _Observable = require('../Observable');

        var _Subject = require('../Subject');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
        function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
          return function(source) {
            return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
          };
        }

        var GroupByOperator =
          /*@__PURE__*/
          (function() {
            function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
              this.keySelector = keySelector;
              this.elementSelector = elementSelector;
              this.durationSelector = durationSelector;
              this.subjectSelector = subjectSelector;
            }

            GroupByOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new GroupBySubscriber(
                  subscriber,
                  this.keySelector,
                  this.elementSelector,
                  this.durationSelector,
                  this.subjectSelector
                )
              );
            };

            return GroupByOperator;
          })();

        var GroupBySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(GroupBySubscriber, _super);

            function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
              var _this = _super.call(this, destination) || this;

              _this.keySelector = keySelector;
              _this.elementSelector = elementSelector;
              _this.durationSelector = durationSelector;
              _this.subjectSelector = subjectSelector;
              _this.groups = null;
              _this.attemptedToUnsubscribe = false;
              _this.count = 0;
              return _this;
            }

            GroupBySubscriber.prototype._next = function(value) {
              var key;

              try {
                key = this.keySelector(value);
              } catch (err) {
                this.error(err);
                return;
              }

              this._group(value, key);
            };

            GroupBySubscriber.prototype._group = function(value, key) {
              var groups = this.groups;

              if (!groups) {
                groups = this.groups = new Map();
              }

              var group = groups.get(key);
              var element;

              if (this.elementSelector) {
                try {
                  element = this.elementSelector(value);
                } catch (err) {
                  this.error(err);
                }
              } else {
                element = value;
              }

              if (!group) {
                group = this.subjectSelector ? this.subjectSelector() : new _Subject.Subject();
                groups.set(key, group);
                var groupedObservable = new GroupedObservable(key, group, this);
                this.destination.next(groupedObservable);

                if (this.durationSelector) {
                  var duration = void 0;

                  try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                  } catch (err) {
                    this.error(err);
                    return;
                  }

                  this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
                }
              }

              if (!group.closed) {
                group.next(element);
              }
            };

            GroupBySubscriber.prototype._error = function(err) {
              var groups = this.groups;

              if (groups) {
                groups.forEach(function(group, key) {
                  group.error(err);
                });
                groups.clear();
              }

              this.destination.error(err);
            };

            GroupBySubscriber.prototype._complete = function() {
              var groups = this.groups;

              if (groups) {
                groups.forEach(function(group, key) {
                  group.complete();
                });
                groups.clear();
              }

              this.destination.complete();
            };

            GroupBySubscriber.prototype.removeGroup = function(key) {
              this.groups.delete(key);
            };

            GroupBySubscriber.prototype.unsubscribe = function() {
              if (!this.closed) {
                this.attemptedToUnsubscribe = true;

                if (this.count === 0) {
                  _super.prototype.unsubscribe.call(this);
                }
              }
            };

            return GroupBySubscriber;
          })(_Subscriber.Subscriber);

        var GroupDurationSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(GroupDurationSubscriber, _super);

            function GroupDurationSubscriber(key, group, parent) {
              var _this = _super.call(this, group) || this;

              _this.key = key;
              _this.group = group;
              _this.parent = parent;
              return _this;
            }

            GroupDurationSubscriber.prototype._next = function(value) {
              this.complete();
            };

            GroupDurationSubscriber.prototype._unsubscribe = function() {
              var _a = this,
                parent = _a.parent,
                key = _a.key;

              this.key = this.parent = null;

              if (parent) {
                parent.removeGroup(key);
              }
            };

            return GroupDurationSubscriber;
          })(_Subscriber.Subscriber);

        var GroupedObservable =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(GroupedObservable, _super);

            function GroupedObservable(key, groupSubject, refCountSubscription) {
              var _this = _super.call(this) || this;

              _this.key = key;
              _this.groupSubject = groupSubject;
              _this.refCountSubscription = refCountSubscription;
              return _this;
            }

            GroupedObservable.prototype._subscribe = function(subscriber) {
              var subscription = new _Subscription.Subscription();

              var _a = this,
                refCountSubscription = _a.refCountSubscription,
                groupSubject = _a.groupSubject;

              if (refCountSubscription && !refCountSubscription.closed) {
                subscription.add(new InnerRefCountSubscription(refCountSubscription));
              }

              subscription.add(groupSubject.subscribe(subscriber));
              return subscription;
            };

            return GroupedObservable;
          })(_Observable.Observable);

        exports.GroupedObservable = GroupedObservable;

        var InnerRefCountSubscription =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(InnerRefCountSubscription, _super);

            function InnerRefCountSubscription(parent) {
              var _this = _super.call(this) || this;

              _this.parent = parent;
              parent.count++;
              return _this;
            }

            InnerRefCountSubscription.prototype.unsubscribe = function() {
              var parent = this.parent;

              if (!parent.closed && !this.closed) {
                _super.prototype.unsubscribe.call(this);

                parent.count -= 1;

                if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                  parent.unsubscribe();
                }
              }
            };

            return InnerRefCountSubscription;
          })(_Subscription.Subscription);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.BehaviorSubject = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('./Subject');

        var _ObjectUnsubscribedError = require('./util/ObjectUnsubscribedError');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
        var BehaviorSubject =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BehaviorSubject, _super);

            function BehaviorSubject(_value) {
              var _this = _super.call(this) || this;

              _this._value = _value;
              return _this;
            }

            Object.defineProperty(BehaviorSubject.prototype, 'value', {
              get: function() {
                return this.getValue();
              },
              enumerable: true,
              configurable: true,
            });

            BehaviorSubject.prototype._subscribe = function(subscriber) {
              var subscription = _super.prototype._subscribe.call(this, subscriber);

              if (subscription && !subscription.closed) {
                subscriber.next(this._value);
              }

              return subscription;
            };

            BehaviorSubject.prototype.getValue = function() {
              if (this.hasError) {
                throw this.thrownError;
              } else if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              } else {
                return this._value;
              }
            };

            BehaviorSubject.prototype.next = function(value) {
              _super.prototype.next.call(this, (this._value = value));
            };

            return BehaviorSubject;
          })(_Subject.Subject);

        exports.BehaviorSubject = BehaviorSubject;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        './util/ObjectUnsubscribedError': '../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/Action.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.Action = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscription = require('../Subscription');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
        var Action =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(Action, _super);

            function Action(scheduler, work) {
              return _super.call(this) || this;
            }

            Action.prototype.schedule = function(state, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              return this;
            };

            return Action;
          })(_Subscription.Subscription);

        exports.Action = Action;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AsyncAction = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Action = require('./Action');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
        var AsyncAction =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AsyncAction, _super);

            function AsyncAction(scheduler, work) {
              var _this = _super.call(this, scheduler, work) || this;

              _this.scheduler = scheduler;
              _this.work = work;
              _this.pending = false;
              return _this;
            }

            AsyncAction.prototype.schedule = function(state, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if (this.closed) {
                return this;
              }

              this.state = state;
              var id = this.id;
              var scheduler = this.scheduler;

              if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
              }

              this.pending = true;
              this.delay = delay;
              this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
              return this;
            };

            AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              return setInterval(scheduler.flush.bind(scheduler, this), delay);
            };

            AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if (delay !== null && this.delay === delay && this.pending === false) {
                return id;
              }

              clearInterval(id);
              return undefined;
            };

            AsyncAction.prototype.execute = function(state, delay) {
              if (this.closed) {
                return new Error('executing a cancelled action');
              }

              this.pending = false;

              var error = this._execute(state, delay);

              if (error) {
                return error;
              } else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
              }
            };

            AsyncAction.prototype._execute = function(state, delay) {
              var errored = false;
              var errorValue = undefined;

              try {
                this.work(state);
              } catch (e) {
                errored = true;
                errorValue = (!!e && e) || new Error(e);
              }

              if (errored) {
                this.unsubscribe();
                return errorValue;
              }
            };

            AsyncAction.prototype._unsubscribe = function() {
              var id = this.id;
              var scheduler = this.scheduler;
              var actions = scheduler.actions;
              var index = actions.indexOf(this);
              this.work = null;
              this.state = null;
              this.pending = false;
              this.scheduler = null;

              if (index !== -1) {
                actions.splice(index, 1);
              }

              if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
              }

              this.delay = null;
            };

            return AsyncAction;
          })(_Action.Action);

        exports.AsyncAction = AsyncAction;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Action': '../../../node_modules/rxjs/_esm5/internal/scheduler/Action.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.QueueAction = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _AsyncAction = require('./AsyncAction');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
        var QueueAction =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(QueueAction, _super);

            function QueueAction(scheduler, work) {
              var _this = _super.call(this, scheduler, work) || this;

              _this.scheduler = scheduler;
              _this.work = work;
              return _this;
            }

            QueueAction.prototype.schedule = function(state, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if (delay > 0) {
                return _super.prototype.schedule.call(this, state, delay);
              }

              this.delay = delay;
              this.state = state;
              this.scheduler.flush(this);
              return this;
            };

            QueueAction.prototype.execute = function(state, delay) {
              return delay > 0 || this.closed
                ? _super.prototype.execute.call(this, state, delay)
                : this._execute(state, delay);
            };

            QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
              }

              return scheduler.flush(this);
            };

            return QueueAction;
          })(_AsyncAction.AsyncAction);

        exports.QueueAction = QueueAction;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './AsyncAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/Scheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.Scheduler = void 0;

        var Scheduler =
          /*@__PURE__*/
          (function() {
            function Scheduler(SchedulerAction, now) {
              if (now === void 0) {
                now = Scheduler.now;
              }

              this.SchedulerAction = SchedulerAction;
              this.now = now;
            }

            Scheduler.prototype.schedule = function(work, delay, state) {
              if (delay === void 0) {
                delay = 0;
              }

              return new this.SchedulerAction(this, work).schedule(state, delay);
            };

            Scheduler.now = function() {
              return Date.now();
            };

            return Scheduler;
          })();

        exports.Scheduler = Scheduler;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AsyncScheduler = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Scheduler = require('../Scheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
        var AsyncScheduler =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AsyncScheduler, _super);

            function AsyncScheduler(SchedulerAction, now) {
              if (now === void 0) {
                now = _Scheduler.Scheduler.now;
              }

              var _this =
                _super.call(this, SchedulerAction, function() {
                  if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                    return AsyncScheduler.delegate.now();
                  } else {
                    return now();
                  }
                }) || this;

              _this.actions = [];
              _this.active = false;
              _this.scheduled = undefined;
              return _this;
            }

            AsyncScheduler.prototype.schedule = function(work, delay, state) {
              if (delay === void 0) {
                delay = 0;
              }

              if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
                return AsyncScheduler.delegate.schedule(work, delay, state);
              } else {
                return _super.prototype.schedule.call(this, work, delay, state);
              }
            };

            AsyncScheduler.prototype.flush = function(action) {
              var actions = this.actions;

              if (this.active) {
                actions.push(action);
                return;
              }

              var error;
              this.active = true;

              do {
                if ((error = action.execute(action.state, action.delay))) {
                  break;
                }
              } while ((action = actions.shift()));

              this.active = false;

              if (error) {
                while ((action = actions.shift())) {
                  action.unsubscribe();
                }

                throw error;
              }
            };

            return AsyncScheduler;
          })(_Scheduler.Scheduler);

        exports.AsyncScheduler = AsyncScheduler;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Scheduler': '../../../node_modules/rxjs/_esm5/internal/Scheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.QueueScheduler = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _AsyncScheduler = require('./AsyncScheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
        var QueueScheduler =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(QueueScheduler, _super);

            function QueueScheduler() {
              return (_super !== null && _super.apply(this, arguments)) || this;
            }

            return QueueScheduler;
          })(_AsyncScheduler.AsyncScheduler);

        exports.QueueScheduler = QueueScheduler;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './AsyncScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/queue.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.queue = void 0;

        var _QueueAction = require('./QueueAction');

        var _QueueScheduler = require('./QueueScheduler');

        /** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
        var queue =
          /*@__PURE__*/
          new _QueueScheduler.QueueScheduler(_QueueAction.QueueAction);
        exports.queue = queue;
      },
      {
        './QueueAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js',
        './QueueScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/empty.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.empty = empty;
        exports.EMPTY = void 0;

        var _Observable = require('../Observable');

        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
        var EMPTY =
          /*@__PURE__*/
          new _Observable.Observable(function(subscriber) {
            return subscriber.complete();
          });
        exports.EMPTY = EMPTY;

        function empty(scheduler) {
          return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }

        function emptyScheduled(scheduler) {
          return new _Observable.Observable(function(subscriber) {
            return scheduler.schedule(function() {
              return subscriber.complete();
            });
          });
        }
      },
      { '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isScheduler = isScheduler;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isScheduler(value) {
          return value && typeof value.schedule === 'function';
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeToArray = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var subscribeToArray = function(array) {
          return function(subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
              subscriber.next(array[i]);
            }

            subscriber.complete();
          };
        };

        exports.subscribeToArray = subscribeToArray;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.scheduleArray = scheduleArray;

        var _Observable = require('../Observable');

        var _Subscription = require('../Subscription');

        /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
        function scheduleArray(input, scheduler) {
          return new _Observable.Observable(function(subscriber) {
            var sub = new _Subscription.Subscription();
            var i = 0;
            sub.add(
              scheduler.schedule(function() {
                if (i === input.length) {
                  subscriber.complete();
                  return;
                }

                subscriber.next(input[i++]);

                if (!subscriber.closed) {
                  sub.add(this.schedule());
                }
              })
            );
            return sub;
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.fromArray = fromArray;

        var _Observable = require('../Observable');

        var _subscribeToArray = require('../util/subscribeToArray');

        var _scheduleArray = require('../scheduled/scheduleArray');

        /** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
        function fromArray(input, scheduler) {
          if (!scheduler) {
            return new _Observable.Observable((0, _subscribeToArray.subscribeToArray)(input));
          } else {
            return (0, _scheduleArray.scheduleArray)(input, scheduler);
          }
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/subscribeToArray': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js',
        '../scheduled/scheduleArray': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/of.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.of = of;

        var _isScheduler = require('../util/isScheduler');

        var _fromArray = require('./fromArray');

        var _scheduleArray = require('../scheduled/scheduleArray');

        /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
        function of() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          var scheduler = args[args.length - 1];

          if ((0, _isScheduler.isScheduler)(scheduler)) {
            args.pop();
            return (0, _scheduleArray.scheduleArray)(args, scheduler);
          } else {
            return (0, _fromArray.fromArray)(args);
          }
        }
      },
      {
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
        './fromArray': '../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
        '../scheduled/scheduleArray': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/throwError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.throwError = throwError;

        var _Observable = require('../Observable');

        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
        function throwError(error, scheduler) {
          if (!scheduler) {
            return new _Observable.Observable(function(subscriber) {
              return subscriber.error(error);
            });
          } else {
            return new _Observable.Observable(function(subscriber) {
              return scheduler.schedule(dispatch, 0, {
                error: error,
                subscriber: subscriber,
              });
            });
          }
        }

        function dispatch(_a) {
          var error = _a.error,
            subscriber = _a.subscriber;
          subscriber.error(error);
        }
      },
      { '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/Notification.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.Notification = exports.NotificationKind = void 0;

        var _empty = require('./observable/empty');

        var _of = require('./observable/of');

        var _throwError = require('./observable/throwError');

        /** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
        var NotificationKind;
        /*@__PURE__*/

        exports.NotificationKind = NotificationKind;

        (function(NotificationKind) {
          NotificationKind['NEXT'] = 'N';
          NotificationKind['ERROR'] = 'E';
          NotificationKind['COMPLETE'] = 'C';
        })(NotificationKind || (exports.NotificationKind = NotificationKind = {}));

        var Notification =
          /*@__PURE__*/
          (function() {
            function Notification(kind, value, error) {
              this.kind = kind;
              this.value = value;
              this.error = error;
              this.hasValue = kind === 'N';
            }

            Notification.prototype.observe = function(observer) {
              switch (this.kind) {
                case 'N':
                  return observer.next && observer.next(this.value);

                case 'E':
                  return observer.error && observer.error(this.error);

                case 'C':
                  return observer.complete && observer.complete();
              }
            };

            Notification.prototype.do = function(next, error, complete) {
              var kind = this.kind;

              switch (kind) {
                case 'N':
                  return next && next(this.value);

                case 'E':
                  return error && error(this.error);

                case 'C':
                  return complete && complete();
              }
            };

            Notification.prototype.accept = function(nextOrObserver, error, complete) {
              if (nextOrObserver && typeof nextOrObserver.next === 'function') {
                return this.observe(nextOrObserver);
              } else {
                return this.do(nextOrObserver, error, complete);
              }
            };

            Notification.prototype.toObservable = function() {
              var kind = this.kind;

              switch (kind) {
                case 'N':
                  return (0, _of.of)(this.value);

                case 'E':
                  return (0, _throwError.throwError)(this.error);

                case 'C':
                  return (0, _empty.empty)();
              }

              throw new Error('unexpected notification kind value');
            };

            Notification.createNext = function(value) {
              if (typeof value !== 'undefined') {
                return new Notification('N', value);
              }

              return Notification.undefinedValueNotification;
            };

            Notification.createError = function(err) {
              return new Notification('E', undefined, err);
            };

            Notification.createComplete = function() {
              return Notification.completeNotification;
            };

            Notification.completeNotification = new Notification('C');
            Notification.undefinedValueNotification = new Notification('N', undefined);
            return Notification;
          })();

        exports.Notification = Notification;
      },
      {
        './observable/empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
        './observable/of': '../../../node_modules/rxjs/_esm5/internal/observable/of.js',
        './observable/throwError': '../../../node_modules/rxjs/_esm5/internal/observable/throwError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/observeOn.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.observeOn = observeOn;
        exports.ObserveOnMessage = exports.ObserveOnSubscriber = exports.ObserveOnOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _Notification = require('../Notification');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
        function observeOn(scheduler, delay) {
          if (delay === void 0) {
            delay = 0;
          }

          return function observeOnOperatorFunction(source) {
            return source.lift(new ObserveOnOperator(scheduler, delay));
          };
        }

        var ObserveOnOperator =
          /*@__PURE__*/
          (function() {
            function ObserveOnOperator(scheduler, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              this.scheduler = scheduler;
              this.delay = delay;
            }

            ObserveOnOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
            };

            return ObserveOnOperator;
          })();

        exports.ObserveOnOperator = ObserveOnOperator;

        var ObserveOnSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ObserveOnSubscriber, _super);

            function ObserveOnSubscriber(destination, scheduler, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              var _this = _super.call(this, destination) || this;

              _this.scheduler = scheduler;
              _this.delay = delay;
              return _this;
            }

            ObserveOnSubscriber.dispatch = function(arg) {
              var notification = arg.notification,
                destination = arg.destination;
              notification.observe(destination);
              this.unsubscribe();
            };

            ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
              var destination = this.destination;
              destination.add(
                this.scheduler.schedule(
                  ObserveOnSubscriber.dispatch,
                  this.delay,
                  new ObserveOnMessage(notification, this.destination)
                )
              );
            };

            ObserveOnSubscriber.prototype._next = function(value) {
              this.scheduleMessage(_Notification.Notification.createNext(value));
            };

            ObserveOnSubscriber.prototype._error = function(err) {
              this.scheduleMessage(_Notification.Notification.createError(err));
              this.unsubscribe();
            };

            ObserveOnSubscriber.prototype._complete = function() {
              this.scheduleMessage(_Notification.Notification.createComplete());
              this.unsubscribe();
            };

            return ObserveOnSubscriber;
          })(_Subscriber.Subscriber);

        exports.ObserveOnSubscriber = ObserveOnSubscriber;

        var ObserveOnMessage =
          /*@__PURE__*/
          (function() {
            function ObserveOnMessage(notification, destination) {
              this.notification = notification;
              this.destination = destination;
            }

            return ObserveOnMessage;
          })();

        exports.ObserveOnMessage = ObserveOnMessage;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Notification': '../../../node_modules/rxjs/_esm5/internal/Notification.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.ReplaySubject = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('./Subject');

        var _queue = require('./scheduler/queue');

        var _Subscription = require('./Subscription');

        var _observeOn = require('./operators/observeOn');

        var _ObjectUnsubscribedError = require('./util/ObjectUnsubscribedError');

        var _SubjectSubscription = require('./SubjectSubscription');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
        var ReplaySubject =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ReplaySubject, _super);

            function ReplaySubject(bufferSize, windowTime, scheduler) {
              if (bufferSize === void 0) {
                bufferSize = Number.POSITIVE_INFINITY;
              }

              if (windowTime === void 0) {
                windowTime = Number.POSITIVE_INFINITY;
              }

              var _this = _super.call(this) || this;

              _this.scheduler = scheduler;
              _this._events = [];
              _this._infiniteTimeWindow = false;
              _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
              _this._windowTime = windowTime < 1 ? 1 : windowTime;

              if (windowTime === Number.POSITIVE_INFINITY) {
                _this._infiniteTimeWindow = true;
                _this.next = _this.nextInfiniteTimeWindow;
              } else {
                _this.next = _this.nextTimeWindow;
              }

              return _this;
            }

            ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
              var _events = this._events;

              _events.push(value);

              if (_events.length > this._bufferSize) {
                _events.shift();
              }

              _super.prototype.next.call(this, value);
            };

            ReplaySubject.prototype.nextTimeWindow = function(value) {
              this._events.push(new ReplayEvent(this._getNow(), value));

              this._trimBufferThenGetEvents();

              _super.prototype.next.call(this, value);
            };

            ReplaySubject.prototype._subscribe = function(subscriber) {
              var _infiniteTimeWindow = this._infiniteTimeWindow;

              var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

              var scheduler = this.scheduler;
              var len = _events.length;
              var subscription;

              if (this.closed) {
                throw new _ObjectUnsubscribedError.ObjectUnsubscribedError();
              } else if (this.isStopped || this.hasError) {
                subscription = _Subscription.Subscription.EMPTY;
              } else {
                this.observers.push(subscriber);
                subscription = new _SubjectSubscription.SubjectSubscription(this, subscriber);
              }

              if (scheduler) {
                subscriber.add((subscriber = new _observeOn.ObserveOnSubscriber(subscriber, scheduler)));
              }

              if (_infiniteTimeWindow) {
                for (var i = 0; i < len && !subscriber.closed; i++) {
                  subscriber.next(_events[i]);
                }
              } else {
                for (var i = 0; i < len && !subscriber.closed; i++) {
                  subscriber.next(_events[i].value);
                }
              }

              if (this.hasError) {
                subscriber.error(this.thrownError);
              } else if (this.isStopped) {
                subscriber.complete();
              }

              return subscription;
            };

            ReplaySubject.prototype._getNow = function() {
              return (this.scheduler || _queue.queue).now();
            };

            ReplaySubject.prototype._trimBufferThenGetEvents = function() {
              var now = this._getNow();

              var _bufferSize = this._bufferSize;
              var _windowTime = this._windowTime;
              var _events = this._events;
              var eventsCount = _events.length;
              var spliceCount = 0;

              while (spliceCount < eventsCount) {
                if (now - _events[spliceCount].time < _windowTime) {
                  break;
                }

                spliceCount++;
              }

              if (eventsCount > _bufferSize) {
                spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
              }

              if (spliceCount > 0) {
                _events.splice(0, spliceCount);
              }

              return _events;
            };

            return ReplaySubject;
          })(_Subject.Subject);

        exports.ReplaySubject = ReplaySubject;

        var ReplayEvent =
          /*@__PURE__*/
          (function() {
            function ReplayEvent(time, value) {
              this.time = time;
              this.value = value;
            }

            return ReplayEvent;
          })();
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        './scheduler/queue': '../../../node_modules/rxjs/_esm5/internal/scheduler/queue.js',
        './Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        './operators/observeOn': '../../../node_modules/rxjs/_esm5/internal/operators/observeOn.js',
        './util/ObjectUnsubscribedError': '../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
        './SubjectSubscription': '../../../node_modules/rxjs/_esm5/internal/SubjectSubscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AsyncSubject = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('./Subject');

        var _Subscription = require('./Subscription');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
        var AsyncSubject =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AsyncSubject, _super);

            function AsyncSubject() {
              var _this = (_super !== null && _super.apply(this, arguments)) || this;

              _this.value = null;
              _this.hasNext = false;
              _this.hasCompleted = false;
              return _this;
            }

            AsyncSubject.prototype._subscribe = function(subscriber) {
              if (this.hasError) {
                subscriber.error(this.thrownError);
                return _Subscription.Subscription.EMPTY;
              } else if (this.hasCompleted && this.hasNext) {
                subscriber.next(this.value);
                subscriber.complete();
                return _Subscription.Subscription.EMPTY;
              }

              return _super.prototype._subscribe.call(this, subscriber);
            };

            AsyncSubject.prototype.next = function(value) {
              if (!this.hasCompleted) {
                this.value = value;
                this.hasNext = true;
              }
            };

            AsyncSubject.prototype.error = function(error) {
              if (!this.hasCompleted) {
                _super.prototype.error.call(this, error);
              }
            };

            AsyncSubject.prototype.complete = function() {
              this.hasCompleted = true;

              if (this.hasNext) {
                _super.prototype.next.call(this, this.value);
              }

              _super.prototype.complete.call(this);
            };

            return AsyncSubject;
          })(_Subject.Subject);

        exports.AsyncSubject = AsyncSubject;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        './Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/Immediate.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.TestTools = exports.Immediate = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var nextHandle = 1;

        var RESOLVED =
          /*@__PURE__*/
          (function() {
            return (
              /*@__PURE__*/
              Promise.resolve()
            );
          })();

        var activeHandles = {};

        function findAndClearHandle(handle) {
          if (handle in activeHandles) {
            delete activeHandles[handle];
            return true;
          }

          return false;
        }

        var Immediate = {
          setImmediate: function(cb) {
            var handle = nextHandle++;
            activeHandles[handle] = true;
            RESOLVED.then(function() {
              return findAndClearHandle(handle) && cb();
            });
            return handle;
          },
          clearImmediate: function(handle) {
            findAndClearHandle(handle);
          },
        };
        exports.Immediate = Immediate;
        var TestTools = {
          pending: function() {
            return Object.keys(activeHandles).length;
          },
        };
        exports.TestTools = TestTools;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AsapAction = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Immediate = require('../util/Immediate');

        var _AsyncAction = require('./AsyncAction');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
        var AsapAction =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AsapAction, _super);

            function AsapAction(scheduler, work) {
              var _this = _super.call(this, scheduler, work) || this;

              _this.scheduler = scheduler;
              _this.work = work;
              return _this;
            }

            AsapAction.prototype.requestAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
              }

              scheduler.actions.push(this);
              return (
                scheduler.scheduled ||
                (scheduler.scheduled = _Immediate.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)))
              );
            };

            AsapAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
              }

              if (scheduler.actions.length === 0) {
                _Immediate.Immediate.clearImmediate(id);

                scheduler.scheduled = undefined;
              }

              return undefined;
            };

            return AsapAction;
          })(_AsyncAction.AsyncAction);

        exports.AsapAction = AsapAction;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../util/Immediate': '../../../node_modules/rxjs/_esm5/internal/util/Immediate.js',
        './AsyncAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AsapScheduler = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _AsyncScheduler = require('./AsyncScheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
        var AsapScheduler =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AsapScheduler, _super);

            function AsapScheduler() {
              return (_super !== null && _super.apply(this, arguments)) || this;
            }

            AsapScheduler.prototype.flush = function(action) {
              this.active = true;
              this.scheduled = undefined;
              var actions = this.actions;
              var error;
              var index = -1;
              var count = actions.length;
              action = action || actions.shift();

              do {
                if ((error = action.execute(action.state, action.delay))) {
                  break;
                }
              } while (++index < count && (action = actions.shift()));

              this.active = false;

              if (error) {
                while (++index < count && (action = actions.shift())) {
                  action.unsubscribe();
                }

                throw error;
              }
            };

            return AsapScheduler;
          })(_AsyncScheduler.AsyncScheduler);

        exports.AsapScheduler = AsapScheduler;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './AsyncScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/asap.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.asap = void 0;

        var _AsapAction = require('./AsapAction');

        var _AsapScheduler = require('./AsapScheduler');

        /** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
        var asap =
          /*@__PURE__*/
          new _AsapScheduler.AsapScheduler(_AsapAction.AsapAction);
        exports.asap = asap;
      },
      {
        './AsapAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js',
        './AsapScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.async = void 0;

        var _AsyncAction = require('./AsyncAction');

        var _AsyncScheduler = require('./AsyncScheduler');

        /** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
        var async =
          /*@__PURE__*/
          new _AsyncScheduler.AsyncScheduler(_AsyncAction.AsyncAction);
        exports.async = async;
      },
      {
        './AsyncAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
        './AsyncScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AnimationFrameAction = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _AsyncAction = require('./AsyncAction');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
        var AnimationFrameAction =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AnimationFrameAction, _super);

            function AnimationFrameAction(scheduler, work) {
              var _this = _super.call(this, scheduler, work) || this;

              _this.scheduler = scheduler;
              _this.work = work;
              return _this;
            }

            AnimationFrameAction.prototype.requestAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if (delay !== null && delay > 0) {
                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
              }

              scheduler.actions.push(this);
              return (
                scheduler.scheduled ||
                (scheduler.scheduled = requestAnimationFrame(function() {
                  return scheduler.flush(null);
                }))
              );
            };

            AnimationFrameAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
              }

              if (scheduler.actions.length === 0) {
                cancelAnimationFrame(id);
                scheduler.scheduled = undefined;
              }

              return undefined;
            };

            return AnimationFrameAction;
          })(_AsyncAction.AsyncAction);

        exports.AnimationFrameAction = AnimationFrameAction;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './AsyncAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.AnimationFrameScheduler = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _AsyncScheduler = require('./AsyncScheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
        var AnimationFrameScheduler =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AnimationFrameScheduler, _super);

            function AnimationFrameScheduler() {
              return (_super !== null && _super.apply(this, arguments)) || this;
            }

            AnimationFrameScheduler.prototype.flush = function(action) {
              this.active = true;
              this.scheduled = undefined;
              var actions = this.actions;
              var error;
              var index = -1;
              var count = actions.length;
              action = action || actions.shift();

              do {
                if ((error = action.execute(action.state, action.delay))) {
                  break;
                }
              } while (++index < count && (action = actions.shift()));

              this.active = false;

              if (error) {
                while (++index < count && (action = actions.shift())) {
                  action.unsubscribe();
                }

                throw error;
              }
            };

            return AnimationFrameScheduler;
          })(_AsyncScheduler.AsyncScheduler);

        exports.AnimationFrameScheduler = AnimationFrameScheduler;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './AsyncScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.animationFrame = void 0;

        var _AnimationFrameAction = require('./AnimationFrameAction');

        var _AnimationFrameScheduler = require('./AnimationFrameScheduler');

        /** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
        var animationFrame =
          /*@__PURE__*/
          new _AnimationFrameScheduler.AnimationFrameScheduler(_AnimationFrameAction.AnimationFrameAction);
        exports.animationFrame = animationFrame;
      },
      {
        './AnimationFrameAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js',
        './AnimationFrameScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.VirtualAction = exports.VirtualTimeScheduler = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _AsyncAction = require('./AsyncAction');

        var _AsyncScheduler = require('./AsyncScheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
        var VirtualTimeScheduler =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(VirtualTimeScheduler, _super);

            function VirtualTimeScheduler(SchedulerAction, maxFrames) {
              if (SchedulerAction === void 0) {
                SchedulerAction = VirtualAction;
              }

              if (maxFrames === void 0) {
                maxFrames = Number.POSITIVE_INFINITY;
              }

              var _this =
                _super.call(this, SchedulerAction, function() {
                  return _this.frame;
                }) || this;

              _this.maxFrames = maxFrames;
              _this.frame = 0;
              _this.index = -1;
              return _this;
            }

            VirtualTimeScheduler.prototype.flush = function() {
              var _a = this,
                actions = _a.actions,
                maxFrames = _a.maxFrames;

              var error, action;

              while ((action = actions[0]) && action.delay <= maxFrames) {
                actions.shift();
                this.frame = action.delay;

                if ((error = action.execute(action.state, action.delay))) {
                  break;
                }
              }

              if (error) {
                while ((action = actions.shift())) {
                  action.unsubscribe();
                }

                throw error;
              }
            };

            VirtualTimeScheduler.frameTimeFactor = 10;
            return VirtualTimeScheduler;
          })(_AsyncScheduler.AsyncScheduler);

        exports.VirtualTimeScheduler = VirtualTimeScheduler;

        var VirtualAction =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(VirtualAction, _super);

            function VirtualAction(scheduler, work, index) {
              if (index === void 0) {
                index = scheduler.index += 1;
              }

              var _this = _super.call(this, scheduler, work) || this;

              _this.scheduler = scheduler;
              _this.work = work;
              _this.index = index;
              _this.active = true;
              _this.index = scheduler.index = index;
              return _this;
            }

            VirtualAction.prototype.schedule = function(state, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              if (!this.id) {
                return _super.prototype.schedule.call(this, state, delay);
              }

              this.active = false;
              var action = new VirtualAction(this.scheduler, this.work);
              this.add(action);
              return action.schedule(state, delay);
            };

            VirtualAction.prototype.requestAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              this.delay = scheduler.frame + delay;
              var actions = scheduler.actions;
              actions.push(this);
              actions.sort(VirtualAction.sortActions);
              return true;
            };

            VirtualAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
              if (delay === void 0) {
                delay = 0;
              }

              return undefined;
            };

            VirtualAction.prototype._execute = function(state, delay) {
              if (this.active === true) {
                return _super.prototype._execute.call(this, state, delay);
              }
            };

            VirtualAction.sortActions = function(a, b) {
              if (a.delay === b.delay) {
                if (a.index === b.index) {
                  return 0;
                } else if (a.index > b.index) {
                  return 1;
                } else {
                  return -1;
                }
              } else if (a.delay > b.delay) {
                return 1;
              } else {
                return -1;
              }
            };

            return VirtualAction;
          })(_AsyncAction.AsyncAction);

        exports.VirtualAction = VirtualAction;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './AsyncAction': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js',
        './AsyncScheduler': '../../../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/identity.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.identity = identity;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function identity(x) {
          return x;
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isObservable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isObservable = isObservable;

        var _Observable = require('../Observable');

        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
        function isObservable(obj) {
          return (
            !!obj &&
            (obj instanceof _Observable.Observable ||
              (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'))
          );
        }
      },
      { '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.ArgumentOutOfRangeError = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var ArgumentOutOfRangeErrorImpl =
          /*@__PURE__*/
          (function() {
            function ArgumentOutOfRangeErrorImpl() {
              Error.call(this);
              this.message = 'argument out of range';
              this.name = 'ArgumentOutOfRangeError';
              return this;
            }

            ArgumentOutOfRangeErrorImpl.prototype =
              /*@__PURE__*/
              Object.create(Error.prototype);
            return ArgumentOutOfRangeErrorImpl;
          })();

        var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
        exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.EmptyError = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var EmptyErrorImpl =
          /*@__PURE__*/
          (function() {
            function EmptyErrorImpl() {
              Error.call(this);
              this.message = 'no elements in sequence';
              this.name = 'EmptyError';
              return this;
            }

            EmptyErrorImpl.prototype =
              /*@__PURE__*/
              Object.create(Error.prototype);
            return EmptyErrorImpl;
          })();

        var EmptyError = EmptyErrorImpl;
        exports.EmptyError = EmptyError;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.TimeoutError = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var TimeoutErrorImpl =
          /*@__PURE__*/
          (function() {
            function TimeoutErrorImpl() {
              Error.call(this);
              this.message = 'Timeout has occurred';
              this.name = 'TimeoutError';
              return this;
            }

            TimeoutErrorImpl.prototype =
              /*@__PURE__*/
              Object.create(Error.prototype);
            return TimeoutErrorImpl;
          })();

        var TimeoutError = TimeoutErrorImpl;
        exports.TimeoutError = TimeoutError;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/map.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.map = map;
        exports.MapOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function map(project, thisArg) {
          return function mapOperation(source) {
            if (typeof project !== 'function') {
              throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }

            return source.lift(new MapOperator(project, thisArg));
          };
        }

        var MapOperator =
          /*@__PURE__*/
          (function() {
            function MapOperator(project, thisArg) {
              this.project = project;
              this.thisArg = thisArg;
            }

            MapOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
            };

            return MapOperator;
          })();

        exports.MapOperator = MapOperator;

        var MapSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(MapSubscriber, _super);

            function MapSubscriber(destination, project, thisArg) {
              var _this = _super.call(this, destination) || this;

              _this.project = project;
              _this.count = 0;
              _this.thisArg = thisArg || _this;
              return _this;
            }

            MapSubscriber.prototype._next = function(value) {
              var result;

              try {
                result = this.project.call(this.thisArg, value, this.count++);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.next(result);
            };

            return MapSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/bindCallback.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.bindCallback = bindCallback;

        var _Observable = require('../Observable');

        var _AsyncSubject = require('../AsyncSubject');

        var _map = require('../operators/map');

        var _canReportError = require('../util/canReportError');

        var _isArray = require('../util/isArray');

        var _isScheduler = require('../util/isScheduler');

        /** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
        function bindCallback(callbackFunc, resultSelector, scheduler) {
          if (resultSelector) {
            if ((0, _isScheduler.isScheduler)(resultSelector)) {
              scheduler = resultSelector;
            } else {
              return function() {
                var args = [];

                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }

                return bindCallback(callbackFunc, scheduler)
                  .apply(void 0, args)
                  .pipe(
                    (0, _map.map)(function(args) {
                      return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
                    })
                  );
              };
            }
          }

          return function() {
            var args = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }

            var context = this;
            var subject;
            var params = {
              context: context,
              subject: subject,
              callbackFunc: callbackFunc,
              scheduler: scheduler,
            };
            return new _Observable.Observable(function(subscriber) {
              if (!scheduler) {
                if (!subject) {
                  subject = new _AsyncSubject.AsyncSubject();

                  var handler = function() {
                    var innerArgs = [];

                    for (var _i = 0; _i < arguments.length; _i++) {
                      innerArgs[_i] = arguments[_i];
                    }

                    subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                    subject.complete();
                  };

                  try {
                    callbackFunc.apply(context, args.concat([handler]));
                  } catch (err) {
                    if ((0, _canReportError.canReportError)(subject)) {
                      subject.error(err);
                    } else {
                      console.warn(err);
                    }
                  }
                }

                return subject.subscribe(subscriber);
              } else {
                var state = {
                  args: args,
                  subscriber: subscriber,
                  params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
              }
            });
          };
        }

        function dispatch(state) {
          var _this = this;

          var self = this;
          var args = state.args,
            subscriber = state.subscriber,
            params = state.params;
          var callbackFunc = params.callbackFunc,
            context = params.context,
            scheduler = params.scheduler;
          var subject = params.subject;

          if (!subject) {
            subject = params.subject = new _AsyncSubject.AsyncSubject();

            var handler = function() {
              var innerArgs = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
              }

              var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

              _this.add(
                scheduler.schedule(dispatchNext, 0, {
                  value: value,
                  subject: subject,
                })
              );
            };

            try {
              callbackFunc.apply(context, args.concat([handler]));
            } catch (err) {
              subject.error(err);
            }
          }

          this.add(subject.subscribe(subscriber));
        }

        function dispatchNext(state) {
          var value = state.value,
            subject = state.subject;
          subject.next(value);
          subject.complete();
        }

        function dispatchError(state) {
          var err = state.err,
            subject = state.subject;
          subject.error(err);
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../AsyncSubject': '../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
        '../operators/map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../util/canReportError': '../../../node_modules/rxjs/_esm5/internal/util/canReportError.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.bindNodeCallback = bindNodeCallback;

        var _Observable = require('../Observable');

        var _AsyncSubject = require('../AsyncSubject');

        var _map = require('../operators/map');

        var _canReportError = require('../util/canReportError');

        var _isScheduler = require('../util/isScheduler');

        var _isArray = require('../util/isArray');

        /** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
        function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
          if (resultSelector) {
            if ((0, _isScheduler.isScheduler)(resultSelector)) {
              scheduler = resultSelector;
            } else {
              return function() {
                var args = [];

                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }

                return bindNodeCallback(callbackFunc, scheduler)
                  .apply(void 0, args)
                  .pipe(
                    (0, _map.map)(function(args) {
                      return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
                    })
                  );
              };
            }
          }

          return function() {
            var args = [];

            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }

            var params = {
              subject: undefined,
              args: args,
              callbackFunc: callbackFunc,
              scheduler: scheduler,
              context: this,
            };
            return new _Observable.Observable(function(subscriber) {
              var context = params.context;
              var subject = params.subject;

              if (!scheduler) {
                if (!subject) {
                  subject = params.subject = new _AsyncSubject.AsyncSubject();

                  var handler = function() {
                    var innerArgs = [];

                    for (var _i = 0; _i < arguments.length; _i++) {
                      innerArgs[_i] = arguments[_i];
                    }

                    var err = innerArgs.shift();

                    if (err) {
                      subject.error(err);
                      return;
                    }

                    subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                    subject.complete();
                  };

                  try {
                    callbackFunc.apply(context, args.concat([handler]));
                  } catch (err) {
                    if ((0, _canReportError.canReportError)(subject)) {
                      subject.error(err);
                    } else {
                      console.warn(err);
                    }
                  }
                }

                return subject.subscribe(subscriber);
              } else {
                return scheduler.schedule(dispatch, 0, {
                  params: params,
                  subscriber: subscriber,
                  context: context,
                });
              }
            });
          };
        }

        function dispatch(state) {
          var _this = this;

          var params = state.params,
            subscriber = state.subscriber,
            context = state.context;
          var callbackFunc = params.callbackFunc,
            args = params.args,
            scheduler = params.scheduler;
          var subject = params.subject;

          if (!subject) {
            subject = params.subject = new _AsyncSubject.AsyncSubject();

            var handler = function() {
              var innerArgs = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
              }

              var err = innerArgs.shift();

              if (err) {
                _this.add(
                  scheduler.schedule(dispatchError, 0, {
                    err: err,
                    subject: subject,
                  })
                );
              } else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;

                _this.add(
                  scheduler.schedule(dispatchNext, 0, {
                    value: value,
                    subject: subject,
                  })
                );
              }
            };

            try {
              callbackFunc.apply(context, args.concat([handler]));
            } catch (err) {
              this.add(
                scheduler.schedule(dispatchError, 0, {
                  err: err,
                  subject: subject,
                })
              );
            }
          }

          this.add(subject.subscribe(subscriber));
        }

        function dispatchNext(arg) {
          var value = arg.value,
            subject = arg.subject;
          subject.next(value);
          subject.complete();
        }

        function dispatchError(arg) {
          var err = arg.err,
            subject = arg.subject;
          subject.error(err);
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../AsyncSubject': '../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
        '../operators/map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../util/canReportError': '../../../node_modules/rxjs/_esm5/internal/util/canReportError.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.OuterSubscriber = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('./Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        var OuterSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(OuterSubscriber, _super);

            function OuterSubscriber() {
              return (_super !== null && _super.apply(this, arguments)) || this;
            }

            OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              this.destination.next(innerValue);
            };

            OuterSubscriber.prototype.notifyError = function(error, innerSub) {
              this.destination.error(error);
            };

            OuterSubscriber.prototype.notifyComplete = function(innerSub) {
              this.destination.complete();
            };

            return OuterSubscriber;
          })(_Subscriber.Subscriber);

        exports.OuterSubscriber = OuterSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.InnerSubscriber = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('./Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        var InnerSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(InnerSubscriber, _super);

            function InnerSubscriber(parent, outerValue, outerIndex) {
              var _this = _super.call(this) || this;

              _this.parent = parent;
              _this.outerValue = outerValue;
              _this.outerIndex = outerIndex;
              _this.index = 0;
              return _this;
            }

            InnerSubscriber.prototype._next = function(value) {
              this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
            };

            InnerSubscriber.prototype._error = function(error) {
              this.parent.notifyError(error, this);
              this.unsubscribe();
            };

            InnerSubscriber.prototype._complete = function() {
              this.parent.notifyComplete(this);
              this.unsubscribe();
            };

            return InnerSubscriber;
          })(_Subscriber.Subscriber);

        exports.InnerSubscriber = InnerSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeToPromise = void 0;

        var _hostReportError = require('./hostReportError');

        /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
        var subscribeToPromise = function(promise) {
          return function(subscriber) {
            promise
              .then(
                function(value) {
                  if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                  }
                },
                function(err) {
                  return subscriber.error(err);
                }
              )
              .then(null, _hostReportError.hostReportError);
            return subscriber;
          };
        };

        exports.subscribeToPromise = subscribeToPromise;
      },
      { './hostReportError': '../../../node_modules/rxjs/_esm5/internal/util/hostReportError.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.getSymbolIterator = getSymbolIterator;
        exports.$$iterator = exports.iterator = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function getSymbolIterator() {
          if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
          }

          return Symbol.iterator;
        }

        var iterator =
          /*@__PURE__*/
          getSymbolIterator();
        exports.iterator = iterator;
        var $$iterator = iterator;
        exports.$$iterator = $$iterator;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeToIterable = void 0;

        var _iterator = require('../symbol/iterator');

        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
        var subscribeToIterable = function(iterable) {
          return function(subscriber) {
            var iterator = iterable[_iterator.iterator]();

            do {
              var item = iterator.next();

              if (item.done) {
                subscriber.complete();
                break;
              }

              subscriber.next(item.value);

              if (subscriber.closed) {
                break;
              }
            } while (true);

            if (typeof iterator.return === 'function') {
              subscriber.add(function() {
                if (iterator.return) {
                  iterator.return();
                }
              });
            }

            return subscriber;
          };
        };

        exports.subscribeToIterable = subscribeToIterable;
      },
      { '../symbol/iterator': '../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeToObservable = void 0;

        var _observable = require('../symbol/observable');

        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
        var subscribeToObservable = function(obj) {
          return function(subscriber) {
            var obs = obj[_observable.observable]();

            if (typeof obs.subscribe !== 'function') {
              throw new TypeError('Provided object does not correctly implement Symbol.observable');
            } else {
              return obs.subscribe(subscriber);
            }
          };
        };

        exports.subscribeToObservable = subscribeToObservable;
      },
      { '../symbol/observable': '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isArrayLike.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isArrayLike = void 0;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        var isArrayLike = function(x) {
          return x && typeof x.length === 'number' && typeof x !== 'function';
        };

        exports.isArrayLike = isArrayLike;
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isPromise.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isPromise = isPromise;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isPromise(value) {
          return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeTo = void 0;

        var _subscribeToArray = require('./subscribeToArray');

        var _subscribeToPromise = require('./subscribeToPromise');

        var _subscribeToIterable = require('./subscribeToIterable');

        var _subscribeToObservable = require('./subscribeToObservable');

        var _isArrayLike = require('./isArrayLike');

        var _isPromise = require('./isPromise');

        var _isObject = require('./isObject');

        var _iterator = require('../symbol/iterator');

        var _observable = require('../symbol/observable');

        /** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
        var subscribeTo = function(result) {
          if (!!result && typeof result[_observable.observable] === 'function') {
            return (0, _subscribeToObservable.subscribeToObservable)(result);
          } else if ((0, _isArrayLike.isArrayLike)(result)) {
            return (0, _subscribeToArray.subscribeToArray)(result);
          } else if ((0, _isPromise.isPromise)(result)) {
            return (0, _subscribeToPromise.subscribeToPromise)(result);
          } else if (!!result && typeof result[_iterator.iterator] === 'function') {
            return (0, _subscribeToIterable.subscribeToIterable)(result);
          } else {
            var value = (0, _isObject.isObject)(result) ? 'an invalid object' : "'" + result + "'";
            var msg =
              'You provided ' +
              value +
              ' where a stream was expected.' +
              ' You can provide an Observable, Promise, Array, or Iterable.';
            throw new TypeError(msg);
          }
        };

        exports.subscribeTo = subscribeTo;
      },
      {
        './subscribeToArray': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToArray.js',
        './subscribeToPromise': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js',
        './subscribeToIterable': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js',
        './subscribeToObservable': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js',
        './isArrayLike': '../../../node_modules/rxjs/_esm5/internal/util/isArrayLike.js',
        './isPromise': '../../../node_modules/rxjs/_esm5/internal/util/isPromise.js',
        './isObject': '../../../node_modules/rxjs/_esm5/internal/util/isObject.js',
        '../symbol/iterator': '../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js',
        '../symbol/observable': '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeToResult = subscribeToResult;

        var _InnerSubscriber = require('../InnerSubscriber');

        var _subscribeTo = require('./subscribeTo');

        var _Observable = require('../Observable');

        /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
        function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
          if (innerSubscriber === void 0) {
            innerSubscriber = new _InnerSubscriber.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
          }

          if (innerSubscriber.closed) {
            return undefined;
          }

          if (result instanceof _Observable.Observable) {
            return result.subscribe(innerSubscriber);
          }

          return (0, _subscribeTo.subscribeTo)(result)(innerSubscriber);
        }
      },
      {
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        './subscribeTo': '../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js',
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.combineLatest = combineLatest;
        exports.CombineLatestSubscriber = exports.CombineLatestOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _isScheduler = require('../util/isScheduler');

        var _isArray = require('../util/isArray');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        var _fromArray = require('./fromArray');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
        var NONE = {};

        function combineLatest() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          var resultSelector = null;
          var scheduler = null;

          if ((0, _isScheduler.isScheduler)(observables[observables.length - 1])) {
            scheduler = observables.pop();
          }

          if (typeof observables[observables.length - 1] === 'function') {
            resultSelector = observables.pop();
          }

          if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
            observables = observables[0];
          }

          return (0, _fromArray.fromArray)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
        }

        var CombineLatestOperator =
          /*@__PURE__*/
          (function() {
            function CombineLatestOperator(resultSelector) {
              this.resultSelector = resultSelector;
            }

            CombineLatestOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
            };

            return CombineLatestOperator;
          })();

        exports.CombineLatestOperator = CombineLatestOperator;

        var CombineLatestSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(CombineLatestSubscriber, _super);

            function CombineLatestSubscriber(destination, resultSelector) {
              var _this = _super.call(this, destination) || this;

              _this.resultSelector = resultSelector;
              _this.active = 0;
              _this.values = [];
              _this.observables = [];
              return _this;
            }

            CombineLatestSubscriber.prototype._next = function(observable) {
              this.values.push(NONE);
              this.observables.push(observable);
            };

            CombineLatestSubscriber.prototype._complete = function() {
              var observables = this.observables;
              var len = observables.length;

              if (len === 0) {
                this.destination.complete();
              } else {
                this.active = len;
                this.toRespond = len;

                for (var i = 0; i < len; i++) {
                  var observable = observables[i];
                  this.add((0, _subscribeToResult.subscribeToResult)(this, observable, observable, i));
                }
              }
            };

            CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
              if ((this.active -= 1) === 0) {
                this.destination.complete();
              }
            };

            CombineLatestSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              var values = this.values;
              var oldVal = values[outerIndex];
              var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
              values[outerIndex] = innerValue;

              if (toRespond === 0) {
                if (this.resultSelector) {
                  this._tryResultSelector(values);
                } else {
                  this.destination.next(values.slice());
                }
              }
            };

            CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
              var result;

              try {
                result = this.resultSelector.apply(this, values);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.next(result);
            };

            return CombineLatestSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        exports.CombineLatestSubscriber = CombineLatestSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        './fromArray': '../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.scheduleObservable = scheduleObservable;

        var _Observable = require('../Observable');

        var _Subscription = require('../Subscription');

        var _observable = require('../symbol/observable');

        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
        function scheduleObservable(input, scheduler) {
          return new _Observable.Observable(function(subscriber) {
            var sub = new _Subscription.Subscription();
            sub.add(
              scheduler.schedule(function() {
                var observable = input[_observable.observable]();

                sub.add(
                  observable.subscribe({
                    next: function(value) {
                      sub.add(
                        scheduler.schedule(function() {
                          return subscriber.next(value);
                        })
                      );
                    },
                    error: function(err) {
                      sub.add(
                        scheduler.schedule(function() {
                          return subscriber.error(err);
                        })
                      );
                    },
                    complete: function() {
                      sub.add(
                        scheduler.schedule(function() {
                          return subscriber.complete();
                        })
                      );
                    },
                  })
                );
              })
            );
            return sub;
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../symbol/observable': '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.schedulePromise = schedulePromise;

        var _Observable = require('../Observable');

        var _Subscription = require('../Subscription');

        /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
        function schedulePromise(input, scheduler) {
          return new _Observable.Observable(function(subscriber) {
            var sub = new _Subscription.Subscription();
            sub.add(
              scheduler.schedule(function() {
                return input.then(
                  function(value) {
                    sub.add(
                      scheduler.schedule(function() {
                        subscriber.next(value);
                        sub.add(
                          scheduler.schedule(function() {
                            return subscriber.complete();
                          })
                        );
                      })
                    );
                  },
                  function(err) {
                    sub.add(
                      scheduler.schedule(function() {
                        return subscriber.error(err);
                      })
                    );
                  }
                );
              })
            );
            return sub;
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.scheduleIterable = scheduleIterable;

        var _Observable = require('../Observable');

        var _Subscription = require('../Subscription');

        var _iterator = require('../symbol/iterator');

        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
        function scheduleIterable(input, scheduler) {
          if (!input) {
            throw new Error('Iterable cannot be null');
          }

          return new _Observable.Observable(function(subscriber) {
            var sub = new _Subscription.Subscription();
            var iterator;
            sub.add(function() {
              if (iterator && typeof iterator.return === 'function') {
                iterator.return();
              }
            });
            sub.add(
              scheduler.schedule(function() {
                iterator = input[_iterator.iterator]();
                sub.add(
                  scheduler.schedule(function() {
                    if (subscriber.closed) {
                      return;
                    }

                    var value;
                    var done;

                    try {
                      var result = iterator.next();
                      value = result.value;
                      done = result.done;
                    } catch (err) {
                      subscriber.error(err);
                      return;
                    }

                    if (done) {
                      subscriber.complete();
                    } else {
                      subscriber.next(value);
                      this.schedule();
                    }
                  })
                );
              })
            );
            return sub;
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../symbol/iterator': '../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isInteropObservable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isInteropObservable = isInteropObservable;

        var _observable = require('../symbol/observable');

        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
        function isInteropObservable(input) {
          return input && typeof input[_observable.observable] === 'function';
        }
      },
      { '../symbol/observable': '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isIterable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isIterable = isIterable;

        var _iterator = require('../symbol/iterator');

        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
        function isIterable(input) {
          return input && typeof input[_iterator.iterator] === 'function';
        }
      },
      { '../symbol/iterator': '../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.scheduled = scheduled;

        var _scheduleObservable = require('./scheduleObservable');

        var _schedulePromise = require('./schedulePromise');

        var _scheduleArray = require('./scheduleArray');

        var _scheduleIterable = require('./scheduleIterable');

        var _isInteropObservable = require('../util/isInteropObservable');

        var _isPromise = require('../util/isPromise');

        var _isArrayLike = require('../util/isArrayLike');

        var _isIterable = require('../util/isIterable');

        /** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
        function scheduled(input, scheduler) {
          if (input != null) {
            if ((0, _isInteropObservable.isInteropObservable)(input)) {
              return (0, _scheduleObservable.scheduleObservable)(input, scheduler);
            } else if ((0, _isPromise.isPromise)(input)) {
              return (0, _schedulePromise.schedulePromise)(input, scheduler);
            } else if ((0, _isArrayLike.isArrayLike)(input)) {
              return (0, _scheduleArray.scheduleArray)(input, scheduler);
            } else if ((0, _isIterable.isIterable)(input) || typeof input === 'string') {
              return (0, _scheduleIterable.scheduleIterable)(input, scheduler);
            }
          }

          throw new TypeError(((input !== null && typeof input) || input) + ' is not observable');
        }
      },
      {
        './scheduleObservable': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js',
        './schedulePromise': '../../../node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js',
        './scheduleArray': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js',
        './scheduleIterable': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js',
        '../util/isInteropObservable': '../../../node_modules/rxjs/_esm5/internal/util/isInteropObservable.js',
        '../util/isPromise': '../../../node_modules/rxjs/_esm5/internal/util/isPromise.js',
        '../util/isArrayLike': '../../../node_modules/rxjs/_esm5/internal/util/isArrayLike.js',
        '../util/isIterable': '../../../node_modules/rxjs/_esm5/internal/util/isIterable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/from.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.from = from;

        var _Observable = require('../Observable');

        var _subscribeTo = require('../util/subscribeTo');

        var _scheduled = require('../scheduled/scheduled');

        /** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
        function from(input, scheduler) {
          if (!scheduler) {
            if (input instanceof _Observable.Observable) {
              return input;
            }

            return new _Observable.Observable((0, _subscribeTo.subscribeTo)(input));
          } else {
            return (0, _scheduled.scheduled)(input, scheduler);
          }
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/subscribeTo': '../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js',
        '../scheduled/scheduled': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.mergeMap = mergeMap;
        exports.MergeMapSubscriber = exports.MergeMapOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _subscribeToResult = require('../util/subscribeToResult');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        var _map = require('./map');

        var _from = require('../observable/from');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
        function mergeMap(project, resultSelector, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }

          if (typeof resultSelector === 'function') {
            return function(source) {
              return source.pipe(
                mergeMap(function(a, i) {
                  return (0, _from.from)(project(a, i)).pipe(
                    (0, _map.map)(function(b, ii) {
                      return resultSelector(a, b, i, ii);
                    })
                  );
                }, concurrent)
              );
            };
          } else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
          }

          return function(source) {
            return source.lift(new MergeMapOperator(project, concurrent));
          };
        }

        var MergeMapOperator =
          /*@__PURE__*/
          (function() {
            function MergeMapOperator(project, concurrent) {
              if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
              }

              this.project = project;
              this.concurrent = concurrent;
            }

            MergeMapOperator.prototype.call = function(observer, source) {
              return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
            };

            return MergeMapOperator;
          })();

        exports.MergeMapOperator = MergeMapOperator;

        var MergeMapSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(MergeMapSubscriber, _super);

            function MergeMapSubscriber(destination, project, concurrent) {
              if (concurrent === void 0) {
                concurrent = Number.POSITIVE_INFINITY;
              }

              var _this = _super.call(this, destination) || this;

              _this.project = project;
              _this.concurrent = concurrent;
              _this.hasCompleted = false;
              _this.buffer = [];
              _this.active = 0;
              _this.index = 0;
              return _this;
            }

            MergeMapSubscriber.prototype._next = function(value) {
              if (this.active < this.concurrent) {
                this._tryNext(value);
              } else {
                this.buffer.push(value);
              }
            };

            MergeMapSubscriber.prototype._tryNext = function(value) {
              var result;
              var index = this.index++;

              try {
                result = this.project(value, index);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.active++;

              this._innerSub(result, value, index);
            };

            MergeMapSubscriber.prototype._innerSub = function(ish, value, index) {
              var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, value, index);
              var destination = this.destination;
              destination.add(innerSubscriber);
              var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                this,
                ish,
                undefined,
                undefined,
                innerSubscriber
              );

              if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
              }
            };

            MergeMapSubscriber.prototype._complete = function() {
              this.hasCompleted = true;

              if (this.active === 0 && this.buffer.length === 0) {
                this.destination.complete();
              }

              this.unsubscribe();
            };

            MergeMapSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.destination.next(innerValue);
            };

            MergeMapSubscriber.prototype.notifyComplete = function(innerSub) {
              var buffer = this.buffer;
              this.remove(innerSub);
              this.active--;

              if (buffer.length > 0) {
                this._next(buffer.shift());
              } else if (this.active === 0 && this.hasCompleted) {
                this.destination.complete();
              }
            };

            return MergeMapSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        exports.MergeMapSubscriber = MergeMapSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        './map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../observable/from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.mergeAll = mergeAll;

        var _mergeMap = require('./mergeMap');

        var _identity = require('../util/identity');

        /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
        function mergeAll(concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }

          return (0, _mergeMap.mergeMap)(_identity.identity, concurrent);
        }
      },
      {
        './mergeMap': '../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js',
        '../util/identity': '../../../node_modules/rxjs/_esm5/internal/util/identity.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/concatAll.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.concatAll = concatAll;

        var _mergeAll = require('./mergeAll');

        /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
        function concatAll() {
          return (0, _mergeAll.mergeAll)(1);
        }
      },
      { './mergeAll': '../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/concat.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.concat = concat;

        var _of = require('./of');

        var _concatAll = require('../operators/concatAll');

        /** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
        function concat() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          return (0, _concatAll.concatAll)()(_of.of.apply(void 0, observables));
        }
      },
      {
        './of': '../../../node_modules/rxjs/_esm5/internal/observable/of.js',
        '../operators/concatAll': '../../../node_modules/rxjs/_esm5/internal/operators/concatAll.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/defer.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.defer = defer;

        var _Observable = require('../Observable');

        var _from = require('./from');

        var _empty = require('./empty');

        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
        function defer(observableFactory) {
          return new _Observable.Observable(function(subscriber) {
            var input;

            try {
              input = observableFactory();
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            var source = input ? (0, _from.from)(input) : (0, _empty.empty)();
            return source.subscribe(subscriber);
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        './from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
        './empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/forkJoin.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.forkJoin = forkJoin;

        var _Observable = require('../Observable');

        var _isArray = require('../util/isArray');

        var _map = require('../operators/map');

        var _isObject = require('../util/isObject');

        var _from = require('./from');

        /** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */
        function forkJoin() {
          var sources = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
          }

          if (sources.length === 1) {
            var first_1 = sources[0];

            if ((0, _isArray.isArray)(first_1)) {
              return forkJoinInternal(first_1, null);
            }

            if ((0, _isObject.isObject)(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
              var keys = Object.keys(first_1);
              return forkJoinInternal(
                keys.map(function(key) {
                  return first_1[key];
                }),
                keys
              );
            }
          }

          if (typeof sources[sources.length - 1] === 'function') {
            var resultSelector_1 = sources.pop();
            sources = sources.length === 1 && (0, _isArray.isArray)(sources[0]) ? sources[0] : sources;
            return forkJoinInternal(sources, null).pipe(
              (0, _map.map)(function(args) {
                return resultSelector_1.apply(void 0, args);
              })
            );
          }

          return forkJoinInternal(sources, null);
        }

        function forkJoinInternal(sources, keys) {
          return new _Observable.Observable(function(subscriber) {
            var len = sources.length;

            if (len === 0) {
              subscriber.complete();
              return;
            }

            var values = new Array(len);
            var completed = 0;
            var emitted = 0;

            var _loop_1 = function(i) {
              var source = (0, _from.from)(sources[i]);
              var hasValue = false;
              subscriber.add(
                source.subscribe({
                  next: function(value) {
                    if (!hasValue) {
                      hasValue = true;
                      emitted++;
                    }

                    values[i] = value;
                  },
                  error: function(err) {
                    return subscriber.error(err);
                  },
                  complete: function() {
                    completed++;

                    if (completed === len || !hasValue) {
                      if (emitted === len) {
                        subscriber.next(
                          keys
                            ? keys.reduce(function(result, key, i) {
                                return (result[key] = values[i]), result;
                              }, {})
                            : values
                        );
                      }

                      subscriber.complete();
                    }
                  },
                })
              );
            };

            for (var i = 0; i < len; i++) {
              _loop_1(i);
            }
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../operators/map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../util/isObject': '../../../node_modules/rxjs/_esm5/internal/util/isObject.js',
        './from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/fromEvent.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.fromEvent = fromEvent;

        var _Observable = require('../Observable');

        var _isArray = require('../util/isArray');

        var _isFunction = require('../util/isFunction');

        var _map = require('../operators/map');

        /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
        var toString =
          /*@__PURE__*/
          (function() {
            return Object.prototype.toString;
          })();

        function fromEvent(target, eventName, options, resultSelector) {
          if ((0, _isFunction.isFunction)(options)) {
            resultSelector = options;
            options = undefined;
          }

          if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(
              (0, _map.map)(function(args) {
                return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
              })
            );
          }

          return new _Observable.Observable(function(subscriber) {
            function handler(e) {
              if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
              } else {
                subscriber.next(e);
              }
            }

            setupSubscription(target, eventName, handler, subscriber, options);
          });
        }

        function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
          var unsubscribe;

          if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);

            unsubscribe = function() {
              return source_1.removeEventListener(eventName, handler, options);
            };
          } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);

            unsubscribe = function() {
              return source_2.off(eventName, handler);
            };
          } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);

            unsubscribe = function() {
              return source_3.removeListener(eventName, handler);
            };
          } else if (sourceObj && sourceObj.length) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
              setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
          } else {
            throw new TypeError('Invalid event target');
          }

          subscriber.add(unsubscribe);
        }

        function isNodeStyleEventEmitter(sourceObj) {
          return (
            sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function'
          );
        }

        function isJQueryStyleEventEmitter(sourceObj) {
          return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
        }

        function isEventTarget(sourceObj) {
          return (
            sourceObj &&
            typeof sourceObj.addEventListener === 'function' &&
            typeof sourceObj.removeEventListener === 'function'
          );
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../util/isFunction': '../../../node_modules/rxjs/_esm5/internal/util/isFunction.js',
        '../operators/map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.fromEventPattern = fromEventPattern;

        var _Observable = require('../Observable');

        var _isArray = require('../util/isArray');

        var _isFunction = require('../util/isFunction');

        var _map = require('../operators/map');

        /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
        function fromEventPattern(addHandler, removeHandler, resultSelector) {
          if (resultSelector) {
            return fromEventPattern(addHandler, removeHandler).pipe(
              (0, _map.map)(function(args) {
                return (0, _isArray.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
              })
            );
          }

          return new _Observable.Observable(function(subscriber) {
            var handler = function() {
              var e = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
              }

              return subscriber.next(e.length === 1 ? e[0] : e);
            };

            var retValue;

            try {
              retValue = addHandler(handler);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            if (!(0, _isFunction.isFunction)(removeHandler)) {
              return undefined;
            }

            return function() {
              return removeHandler(handler, retValue);
            };
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../util/isFunction': '../../../node_modules/rxjs/_esm5/internal/util/isFunction.js',
        '../operators/map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/generate.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.generate = generate;

        var _Observable = require('../Observable');

        var _identity = require('../util/identity');

        var _isScheduler = require('../util/isScheduler');

        /** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
        function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
          var resultSelector;
          var initialState;

          if (arguments.length == 1) {
            var options = initialStateOrOptions;
            initialState = options.initialState;
            condition = options.condition;
            iterate = options.iterate;
            resultSelector = options.resultSelector || _identity.identity;
            scheduler = options.scheduler;
          } else if (
            resultSelectorOrObservable === undefined ||
            (0, _isScheduler.isScheduler)(resultSelectorOrObservable)
          ) {
            initialState = initialStateOrOptions;
            resultSelector = _identity.identity;
            scheduler = resultSelectorOrObservable;
          } else {
            initialState = initialStateOrOptions;
            resultSelector = resultSelectorOrObservable;
          }

          return new _Observable.Observable(function(subscriber) {
            var state = initialState;

            if (scheduler) {
              return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state,
              });
            }

            do {
              if (condition) {
                var conditionResult = void 0;

                try {
                  conditionResult = condition(state);
                } catch (err) {
                  subscriber.error(err);
                  return undefined;
                }

                if (!conditionResult) {
                  subscriber.complete();
                  break;
                }
              }

              var value = void 0;

              try {
                value = resultSelector(state);
              } catch (err) {
                subscriber.error(err);
                return undefined;
              }

              subscriber.next(value);

              if (subscriber.closed) {
                break;
              }

              try {
                state = iterate(state);
              } catch (err) {
                subscriber.error(err);
                return undefined;
              }
            } while (true);

            return undefined;
          });
        }

        function dispatch(state) {
          var subscriber = state.subscriber,
            condition = state.condition;

          if (subscriber.closed) {
            return undefined;
          }

          if (state.needIterate) {
            try {
              state.state = state.iterate(state.state);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }
          } else {
            state.needIterate = true;
          }

          if (condition) {
            var conditionResult = void 0;

            try {
              conditionResult = condition(state.state);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            if (!conditionResult) {
              subscriber.complete();
              return undefined;
            }

            if (subscriber.closed) {
              return undefined;
            }
          }

          var value;

          try {
            value = state.resultSelector(state.state);
          } catch (err) {
            subscriber.error(err);
            return undefined;
          }

          if (subscriber.closed) {
            return undefined;
          }

          subscriber.next(value);

          if (subscriber.closed) {
            return undefined;
          }

          return this.schedule(state);
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/identity': '../../../node_modules/rxjs/_esm5/internal/util/identity.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/iif.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.iif = iif;

        var _defer = require('./defer');

        var _empty = require('./empty');

        /** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
        function iif(condition, trueResult, falseResult) {
          if (trueResult === void 0) {
            trueResult = _empty.EMPTY;
          }

          if (falseResult === void 0) {
            falseResult = _empty.EMPTY;
          }

          return (0, _defer.defer)(function() {
            return condition() ? trueResult : falseResult;
          });
        }
      },
      {
        './defer': '../../../node_modules/rxjs/_esm5/internal/observable/defer.js',
        './empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isNumeric = isNumeric;

        var _isArray = require('./isArray');

        /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
        function isNumeric(val) {
          return !(0, _isArray.isArray)(val) && val - parseFloat(val) + 1 >= 0;
        }
      },
      { './isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/interval.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.interval = interval;

        var _Observable = require('../Observable');

        var _async = require('../scheduler/async');

        var _isNumeric = require('../util/isNumeric');

        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
        function interval(period, scheduler) {
          if (period === void 0) {
            period = 0;
          }

          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          if (!(0, _isNumeric.isNumeric)(period) || period < 0) {
            period = 0;
          }

          if (!scheduler || typeof scheduler.schedule !== 'function') {
            scheduler = _async.async;
          }

          return new _Observable.Observable(function(subscriber) {
            subscriber.add(
              scheduler.schedule(dispatch, period, {
                subscriber: subscriber,
                counter: 0,
                period: period,
              })
            );
            return subscriber;
          });
        }

        function dispatch(state) {
          var subscriber = state.subscriber,
            counter = state.counter,
            period = state.period;
          subscriber.next(counter);
          this.schedule(
            {
              subscriber: subscriber,
              counter: counter + 1,
              period: period,
            },
            period
          );
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../util/isNumeric': '../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/merge.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.merge = merge;

        var _Observable = require('../Observable');

        var _isScheduler = require('../util/isScheduler');

        var _mergeAll = require('../operators/mergeAll');

        var _fromArray = require('./fromArray');

        /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
        function merge() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          var concurrent = Number.POSITIVE_INFINITY;
          var scheduler = null;
          var last = observables[observables.length - 1];

          if ((0, _isScheduler.isScheduler)(last)) {
            scheduler = observables.pop();

            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
              concurrent = observables.pop();
            }
          } else if (typeof last === 'number') {
            concurrent = observables.pop();
          }

          if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable.Observable) {
            return observables[0];
          }

          return (0, _mergeAll.mergeAll)(concurrent)((0, _fromArray.fromArray)(observables, scheduler));
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
        '../operators/mergeAll': '../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js',
        './fromArray': '../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/never.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.never = never;
        exports.NEVER = void 0;

        var _Observable = require('../Observable');

        var _noop = require('../util/noop');

        /** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
        var NEVER =
          /*@__PURE__*/
          new _Observable.Observable(_noop.noop);
        exports.NEVER = NEVER;

        function never() {
          return NEVER;
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../util/noop': '../../../node_modules/rxjs/_esm5/internal/util/noop.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.onErrorResumeNext = onErrorResumeNext;

        var _Observable = require('../Observable');

        var _from = require('./from');

        var _isArray = require('../util/isArray');

        var _empty = require('./empty');

        /** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
        function onErrorResumeNext() {
          var sources = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
          }

          if (sources.length === 0) {
            return _empty.EMPTY;
          }

          var first = sources[0],
            remainder = sources.slice(1);

          if (sources.length === 1 && (0, _isArray.isArray)(first)) {
            return onErrorResumeNext.apply(void 0, first);
          }

          return new _Observable.Observable(function(subscriber) {
            var subNext = function() {
              return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
            };

            return (0, _from.from)(first).subscribe({
              next: function(value) {
                subscriber.next(value);
              },
              error: subNext,
              complete: subNext,
            });
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        './from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        './empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/pairs.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.pairs = pairs;
        exports.dispatch = dispatch;

        var _Observable = require('../Observable');

        var _Subscription = require('../Subscription');

        /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
        function pairs(obj, scheduler) {
          if (!scheduler) {
            return new _Observable.Observable(function(subscriber) {
              var keys = Object.keys(obj);

              for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];

                if (obj.hasOwnProperty(key)) {
                  subscriber.next([key, obj[key]]);
                }
              }

              subscriber.complete();
            });
          } else {
            return new _Observable.Observable(function(subscriber) {
              var keys = Object.keys(obj);
              var subscription = new _Subscription.Subscription();
              subscription.add(
                scheduler.schedule(dispatch, 0, {
                  keys: keys,
                  index: 0,
                  subscriber: subscriber,
                  subscription: subscription,
                  obj: obj,
                })
              );
              return subscription;
            });
          }
        }

        function dispatch(state) {
          var keys = state.keys,
            index = state.index,
            subscriber = state.subscriber,
            subscription = state.subscription,
            obj = state.obj;

          if (!subscriber.closed) {
            if (index < keys.length) {
              var key = keys[index];
              subscriber.next([key, obj[key]]);
              subscription.add(
                this.schedule({
                  keys: keys,
                  index: index + 1,
                  subscriber: subscriber,
                  subscription: subscription,
                  obj: obj,
                })
              );
            } else {
              subscriber.complete();
            }
          }
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/not.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.not = not;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function not(pred, thisArg) {
          function notPred() {
            return !notPred.pred.apply(notPred.thisArg, arguments);
          }

          notPred.pred = pred;
          notPred.thisArg = thisArg;
          return notPred;
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/filter.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.filter = filter;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function filter(predicate, thisArg) {
          return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
          };
        }

        var FilterOperator =
          /*@__PURE__*/
          (function() {
            function FilterOperator(predicate, thisArg) {
              this.predicate = predicate;
              this.thisArg = thisArg;
            }

            FilterOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
            };

            return FilterOperator;
          })();

        var FilterSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(FilterSubscriber, _super);

            function FilterSubscriber(destination, predicate, thisArg) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.thisArg = thisArg;
              _this.count = 0;
              return _this;
            }

            FilterSubscriber.prototype._next = function(value) {
              var result;

              try {
                result = this.predicate.call(this.thisArg, value, this.count++);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              if (result) {
                this.destination.next(value);
              }
            };

            return FilterSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/partition.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.partition = partition;

        var _not = require('../util/not');

        var _subscribeTo = require('../util/subscribeTo');

        var _filter = require('../operators/filter');

        var _Observable = require('../Observable');

        /** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */
        function partition(source, predicate, thisArg) {
          return [
            (0, _filter.filter)(predicate, thisArg)(new _Observable.Observable((0, _subscribeTo.subscribeTo)(source))),
            (0, _filter.filter)((0, _not.not)(predicate, thisArg))(
              new _Observable.Observable((0, _subscribeTo.subscribeTo)(source))
            ),
          ];
        }
      },
      {
        '../util/not': '../../../node_modules/rxjs/_esm5/internal/util/not.js',
        '../util/subscribeTo': '../../../node_modules/rxjs/_esm5/internal/util/subscribeTo.js',
        '../operators/filter': '../../../node_modules/rxjs/_esm5/internal/operators/filter.js',
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/race.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.race = race;
        exports.RaceSubscriber = exports.RaceOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _isArray = require('../util/isArray');

        var _fromArray = require('./fromArray');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function race() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          if (observables.length === 1) {
            if ((0, _isArray.isArray)(observables[0])) {
              observables = observables[0];
            } else {
              return observables[0];
            }
          }

          return (0, _fromArray.fromArray)(observables, undefined).lift(new RaceOperator());
        }

        var RaceOperator =
          /*@__PURE__*/
          (function() {
            function RaceOperator() {}

            RaceOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new RaceSubscriber(subscriber));
            };

            return RaceOperator;
          })();

        exports.RaceOperator = RaceOperator;

        var RaceSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RaceSubscriber, _super);

            function RaceSubscriber(destination) {
              var _this = _super.call(this, destination) || this;

              _this.hasFirst = false;
              _this.observables = [];
              _this.subscriptions = [];
              return _this;
            }

            RaceSubscriber.prototype._next = function(observable) {
              this.observables.push(observable);
            };

            RaceSubscriber.prototype._complete = function() {
              var observables = this.observables;
              var len = observables.length;

              if (len === 0) {
                this.destination.complete();
              } else {
                for (var i = 0; i < len && !this.hasFirst; i++) {
                  var observable = observables[i];
                  var subscription = (0, _subscribeToResult.subscribeToResult)(this, observable, observable, i);

                  if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                  }

                  this.add(subscription);
                }

                this.observables = null;
              }
            };

            RaceSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              if (!this.hasFirst) {
                this.hasFirst = true;

                for (var i = 0; i < this.subscriptions.length; i++) {
                  if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                  }
                }

                this.subscriptions = null;
              }

              this.destination.next(innerValue);
            };

            return RaceSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        exports.RaceSubscriber = RaceSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        './fromArray': '../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/range.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.range = range;
        exports.dispatch = dispatch;

        var _Observable = require('../Observable');

        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
        function range(start, count, scheduler) {
          if (start === void 0) {
            start = 0;
          }

          return new _Observable.Observable(function(subscriber) {
            if (count === undefined) {
              count = start;
              start = 0;
            }

            var index = 0;
            var current = start;

            if (scheduler) {
              return scheduler.schedule(dispatch, 0, {
                index: index,
                count: count,
                start: start,
                subscriber: subscriber,
              });
            } else {
              do {
                if (index++ >= count) {
                  subscriber.complete();
                  break;
                }

                subscriber.next(current++);

                if (subscriber.closed) {
                  break;
                }
              } while (true);
            }

            return undefined;
          });
        }

        function dispatch(state) {
          var start = state.start,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;

          if (index >= count) {
            subscriber.complete();
            return;
          }

          subscriber.next(start);

          if (subscriber.closed) {
            return;
          }

          state.index = index + 1;
          state.start = start + 1;
          this.schedule(state);
        }
      },
      { '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/timer.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.timer = timer;

        var _Observable = require('../Observable');

        var _async = require('../scheduler/async');

        var _isNumeric = require('../util/isNumeric');

        var _isScheduler = require('../util/isScheduler');

        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
        function timer(dueTime, periodOrScheduler, scheduler) {
          if (dueTime === void 0) {
            dueTime = 0;
          }

          var period = -1;

          if ((0, _isNumeric.isNumeric)(periodOrScheduler)) {
            period = (Number(periodOrScheduler) < 1 && 1) || Number(periodOrScheduler);
          } else if ((0, _isScheduler.isScheduler)(periodOrScheduler)) {
            scheduler = periodOrScheduler;
          }

          if (!(0, _isScheduler.isScheduler)(scheduler)) {
            scheduler = _async.async;
          }

          return new _Observable.Observable(function(subscriber) {
            var due = (0, _isNumeric.isNumeric)(dueTime) ? dueTime : +dueTime - scheduler.now();
            return scheduler.schedule(dispatch, due, {
              index: 0,
              period: period,
              subscriber: subscriber,
            });
          });
        }

        function dispatch(state) {
          var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
          subscriber.next(index);

          if (subscriber.closed) {
            return;
          } else if (period === -1) {
            return subscriber.complete();
          }

          state.index = index + 1;
          this.schedule(state, period);
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../util/isNumeric': '../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/using.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.using = using;

        var _Observable = require('../Observable');

        var _from = require('./from');

        var _empty = require('./empty');

        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
        function using(resourceFactory, observableFactory) {
          return new _Observable.Observable(function(subscriber) {
            var resource;

            try {
              resource = resourceFactory();
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            var result;

            try {
              result = observableFactory(resource);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            var source = result ? (0, _from.from)(result) : _empty.EMPTY;
            var subscription = source.subscribe(subscriber);
            return function() {
              subscription.unsubscribe();

              if (resource) {
                resource.unsubscribe();
              }
            };
          });
        }
      },
      {
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        './from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
        './empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/zip.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.zip = zip;
        exports.ZipSubscriber = exports.ZipOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _fromArray = require('./fromArray');

        var _isArray = require('../util/isArray');

        var _Subscriber = require('../Subscriber');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        var _iterator = require('../../internal/symbol/iterator');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
        function zip() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          var resultSelector = observables[observables.length - 1];

          if (typeof resultSelector === 'function') {
            observables.pop();
          }

          return (0, _fromArray.fromArray)(observables, undefined).lift(new ZipOperator(resultSelector));
        }

        var ZipOperator =
          /*@__PURE__*/
          (function() {
            function ZipOperator(resultSelector) {
              this.resultSelector = resultSelector;
            }

            ZipOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
            };

            return ZipOperator;
          })();

        exports.ZipOperator = ZipOperator;

        var ZipSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ZipSubscriber, _super);

            function ZipSubscriber(destination, resultSelector, values) {
              if (values === void 0) {
                values = Object.create(null);
              }

              var _this = _super.call(this, destination) || this;

              _this.iterators = [];
              _this.active = 0;
              _this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
              _this.values = values;
              return _this;
            }

            ZipSubscriber.prototype._next = function(value) {
              var iterators = this.iterators;

              if ((0, _isArray.isArray)(value)) {
                iterators.push(new StaticArrayIterator(value));
              } else if (typeof value[_iterator.iterator] === 'function') {
                iterators.push(new StaticIterator(value[_iterator.iterator]()));
              } else {
                iterators.push(new ZipBufferIterator(this.destination, this, value));
              }
            };

            ZipSubscriber.prototype._complete = function() {
              var iterators = this.iterators;
              var len = iterators.length;
              this.unsubscribe();

              if (len === 0) {
                this.destination.complete();
                return;
              }

              this.active = len;

              for (var i = 0; i < len; i++) {
                var iterator = iterators[i];

                if (iterator.stillUnsubscribed) {
                  var destination = this.destination;
                  destination.add(iterator.subscribe(iterator, i));
                } else {
                  this.active--;
                }
              }
            };

            ZipSubscriber.prototype.notifyInactive = function() {
              this.active--;

              if (this.active === 0) {
                this.destination.complete();
              }
            };

            ZipSubscriber.prototype.checkIterators = function() {
              var iterators = this.iterators;
              var len = iterators.length;
              var destination = this.destination;

              for (var i = 0; i < len; i++) {
                var iterator = iterators[i];

                if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                  return;
                }
              }

              var shouldComplete = false;
              var args = [];

              for (var i = 0; i < len; i++) {
                var iterator = iterators[i];
                var result = iterator.next();

                if (iterator.hasCompleted()) {
                  shouldComplete = true;
                }

                if (result.done) {
                  destination.complete();
                  return;
                }

                args.push(result.value);
              }

              if (this.resultSelector) {
                this._tryresultSelector(args);
              } else {
                destination.next(args);
              }

              if (shouldComplete) {
                destination.complete();
              }
            };

            ZipSubscriber.prototype._tryresultSelector = function(args) {
              var result;

              try {
                result = this.resultSelector.apply(this, args);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.next(result);
            };

            return ZipSubscriber;
          })(_Subscriber.Subscriber);

        exports.ZipSubscriber = ZipSubscriber;

        var StaticIterator =
          /*@__PURE__*/
          (function() {
            function StaticIterator(iterator) {
              this.iterator = iterator;
              this.nextResult = iterator.next();
            }

            StaticIterator.prototype.hasValue = function() {
              return true;
            };

            StaticIterator.prototype.next = function() {
              var result = this.nextResult;
              this.nextResult = this.iterator.next();
              return result;
            };

            StaticIterator.prototype.hasCompleted = function() {
              var nextResult = this.nextResult;
              return nextResult && nextResult.done;
            };

            return StaticIterator;
          })();

        var StaticArrayIterator =
          /*@__PURE__*/
          (function() {
            function StaticArrayIterator(array) {
              this.array = array;
              this.index = 0;
              this.length = 0;
              this.length = array.length;
            }

            StaticArrayIterator.prototype[_iterator.iterator] = function() {
              return this;
            };

            StaticArrayIterator.prototype.next = function(value) {
              var i = this.index++;
              var array = this.array;
              return i < this.length
                ? {
                    value: array[i],
                    done: false,
                  }
                : {
                    value: null,
                    done: true,
                  };
            };

            StaticArrayIterator.prototype.hasValue = function() {
              return this.array.length > this.index;
            };

            StaticArrayIterator.prototype.hasCompleted = function() {
              return this.array.length === this.index;
            };

            return StaticArrayIterator;
          })();

        var ZipBufferIterator =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ZipBufferIterator, _super);

            function ZipBufferIterator(destination, parent, observable) {
              var _this = _super.call(this, destination) || this;

              _this.parent = parent;
              _this.observable = observable;
              _this.stillUnsubscribed = true;
              _this.buffer = [];
              _this.isComplete = false;
              return _this;
            }

            ZipBufferIterator.prototype[_iterator.iterator] = function() {
              return this;
            };

            ZipBufferIterator.prototype.next = function() {
              var buffer = this.buffer;

              if (buffer.length === 0 && this.isComplete) {
                return {
                  value: null,
                  done: true,
                };
              } else {
                return {
                  value: buffer.shift(),
                  done: false,
                };
              }
            };

            ZipBufferIterator.prototype.hasValue = function() {
              return this.buffer.length > 0;
            };

            ZipBufferIterator.prototype.hasCompleted = function() {
              return this.buffer.length === 0 && this.isComplete;
            };

            ZipBufferIterator.prototype.notifyComplete = function() {
              if (this.buffer.length > 0) {
                this.isComplete = true;
                this.parent.notifyInactive();
              } else {
                this.destination.complete();
              }
            };

            ZipBufferIterator.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.buffer.push(innerValue);
              this.parent.checkIterators();
            };

            ZipBufferIterator.prototype.subscribe = function(value, index) {
              return (0, _subscribeToResult.subscribeToResult)(this, this.observable, this, index);
            };

            return ZipBufferIterator;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        './fromArray': '../../../node_modules/rxjs/_esm5/internal/observable/fromArray.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        '../../internal/symbol/iterator': '../../../node_modules/rxjs/_esm5/internal/symbol/iterator.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/index.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        Object.defineProperty(exports, 'Observable', {
          enumerable: true,
          get: function() {
            return _Observable.Observable;
          },
        });
        Object.defineProperty(exports, 'ConnectableObservable', {
          enumerable: true,
          get: function() {
            return _ConnectableObservable.ConnectableObservable;
          },
        });
        Object.defineProperty(exports, 'GroupedObservable', {
          enumerable: true,
          get: function() {
            return _groupBy.GroupedObservable;
          },
        });
        Object.defineProperty(exports, 'observable', {
          enumerable: true,
          get: function() {
            return _observable.observable;
          },
        });
        Object.defineProperty(exports, 'Subject', {
          enumerable: true,
          get: function() {
            return _Subject.Subject;
          },
        });
        Object.defineProperty(exports, 'BehaviorSubject', {
          enumerable: true,
          get: function() {
            return _BehaviorSubject.BehaviorSubject;
          },
        });
        Object.defineProperty(exports, 'ReplaySubject', {
          enumerable: true,
          get: function() {
            return _ReplaySubject.ReplaySubject;
          },
        });
        Object.defineProperty(exports, 'AsyncSubject', {
          enumerable: true,
          get: function() {
            return _AsyncSubject.AsyncSubject;
          },
        });
        Object.defineProperty(exports, 'asapScheduler', {
          enumerable: true,
          get: function() {
            return _asap.asap;
          },
        });
        Object.defineProperty(exports, 'asyncScheduler', {
          enumerable: true,
          get: function() {
            return _async.async;
          },
        });
        Object.defineProperty(exports, 'queueScheduler', {
          enumerable: true,
          get: function() {
            return _queue.queue;
          },
        });
        Object.defineProperty(exports, 'animationFrameScheduler', {
          enumerable: true,
          get: function() {
            return _animationFrame.animationFrame;
          },
        });
        Object.defineProperty(exports, 'VirtualTimeScheduler', {
          enumerable: true,
          get: function() {
            return _VirtualTimeScheduler.VirtualTimeScheduler;
          },
        });
        Object.defineProperty(exports, 'VirtualAction', {
          enumerable: true,
          get: function() {
            return _VirtualTimeScheduler.VirtualAction;
          },
        });
        Object.defineProperty(exports, 'Scheduler', {
          enumerable: true,
          get: function() {
            return _Scheduler.Scheduler;
          },
        });
        Object.defineProperty(exports, 'Subscription', {
          enumerable: true,
          get: function() {
            return _Subscription.Subscription;
          },
        });
        Object.defineProperty(exports, 'Subscriber', {
          enumerable: true,
          get: function() {
            return _Subscriber.Subscriber;
          },
        });
        Object.defineProperty(exports, 'Notification', {
          enumerable: true,
          get: function() {
            return _Notification.Notification;
          },
        });
        Object.defineProperty(exports, 'NotificationKind', {
          enumerable: true,
          get: function() {
            return _Notification.NotificationKind;
          },
        });
        Object.defineProperty(exports, 'pipe', {
          enumerable: true,
          get: function() {
            return _pipe.pipe;
          },
        });
        Object.defineProperty(exports, 'noop', {
          enumerable: true,
          get: function() {
            return _noop.noop;
          },
        });
        Object.defineProperty(exports, 'identity', {
          enumerable: true,
          get: function() {
            return _identity.identity;
          },
        });
        Object.defineProperty(exports, 'isObservable', {
          enumerable: true,
          get: function() {
            return _isObservable.isObservable;
          },
        });
        Object.defineProperty(exports, 'ArgumentOutOfRangeError', {
          enumerable: true,
          get: function() {
            return _ArgumentOutOfRangeError.ArgumentOutOfRangeError;
          },
        });
        Object.defineProperty(exports, 'EmptyError', {
          enumerable: true,
          get: function() {
            return _EmptyError.EmptyError;
          },
        });
        Object.defineProperty(exports, 'ObjectUnsubscribedError', {
          enumerable: true,
          get: function() {
            return _ObjectUnsubscribedError.ObjectUnsubscribedError;
          },
        });
        Object.defineProperty(exports, 'UnsubscriptionError', {
          enumerable: true,
          get: function() {
            return _UnsubscriptionError.UnsubscriptionError;
          },
        });
        Object.defineProperty(exports, 'TimeoutError', {
          enumerable: true,
          get: function() {
            return _TimeoutError.TimeoutError;
          },
        });
        Object.defineProperty(exports, 'bindCallback', {
          enumerable: true,
          get: function() {
            return _bindCallback.bindCallback;
          },
        });
        Object.defineProperty(exports, 'bindNodeCallback', {
          enumerable: true,
          get: function() {
            return _bindNodeCallback.bindNodeCallback;
          },
        });
        Object.defineProperty(exports, 'combineLatest', {
          enumerable: true,
          get: function() {
            return _combineLatest.combineLatest;
          },
        });
        Object.defineProperty(exports, 'concat', {
          enumerable: true,
          get: function() {
            return _concat.concat;
          },
        });
        Object.defineProperty(exports, 'defer', {
          enumerable: true,
          get: function() {
            return _defer.defer;
          },
        });
        Object.defineProperty(exports, 'empty', {
          enumerable: true,
          get: function() {
            return _empty.empty;
          },
        });
        Object.defineProperty(exports, 'EMPTY', {
          enumerable: true,
          get: function() {
            return _empty.EMPTY;
          },
        });
        Object.defineProperty(exports, 'forkJoin', {
          enumerable: true,
          get: function() {
            return _forkJoin.forkJoin;
          },
        });
        Object.defineProperty(exports, 'from', {
          enumerable: true,
          get: function() {
            return _from.from;
          },
        });
        Object.defineProperty(exports, 'fromEvent', {
          enumerable: true,
          get: function() {
            return _fromEvent.fromEvent;
          },
        });
        Object.defineProperty(exports, 'fromEventPattern', {
          enumerable: true,
          get: function() {
            return _fromEventPattern.fromEventPattern;
          },
        });
        Object.defineProperty(exports, 'generate', {
          enumerable: true,
          get: function() {
            return _generate.generate;
          },
        });
        Object.defineProperty(exports, 'iif', {
          enumerable: true,
          get: function() {
            return _iif.iif;
          },
        });
        Object.defineProperty(exports, 'interval', {
          enumerable: true,
          get: function() {
            return _interval.interval;
          },
        });
        Object.defineProperty(exports, 'merge', {
          enumerable: true,
          get: function() {
            return _merge.merge;
          },
        });
        Object.defineProperty(exports, 'never', {
          enumerable: true,
          get: function() {
            return _never.never;
          },
        });
        Object.defineProperty(exports, 'NEVER', {
          enumerable: true,
          get: function() {
            return _never.NEVER;
          },
        });
        Object.defineProperty(exports, 'of', {
          enumerable: true,
          get: function() {
            return _of.of;
          },
        });
        Object.defineProperty(exports, 'onErrorResumeNext', {
          enumerable: true,
          get: function() {
            return _onErrorResumeNext.onErrorResumeNext;
          },
        });
        Object.defineProperty(exports, 'pairs', {
          enumerable: true,
          get: function() {
            return _pairs.pairs;
          },
        });
        Object.defineProperty(exports, 'partition', {
          enumerable: true,
          get: function() {
            return _partition.partition;
          },
        });
        Object.defineProperty(exports, 'race', {
          enumerable: true,
          get: function() {
            return _race.race;
          },
        });
        Object.defineProperty(exports, 'range', {
          enumerable: true,
          get: function() {
            return _range.range;
          },
        });
        Object.defineProperty(exports, 'throwError', {
          enumerable: true,
          get: function() {
            return _throwError.throwError;
          },
        });
        Object.defineProperty(exports, 'timer', {
          enumerable: true,
          get: function() {
            return _timer.timer;
          },
        });
        Object.defineProperty(exports, 'using', {
          enumerable: true,
          get: function() {
            return _using.using;
          },
        });
        Object.defineProperty(exports, 'zip', {
          enumerable: true,
          get: function() {
            return _zip.zip;
          },
        });
        Object.defineProperty(exports, 'scheduled', {
          enumerable: true,
          get: function() {
            return _scheduled.scheduled;
          },
        });
        Object.defineProperty(exports, 'config', {
          enumerable: true,
          get: function() {
            return _config.config;
          },
        });

        var _Observable = require('./internal/Observable');

        var _ConnectableObservable = require('./internal/observable/ConnectableObservable');

        var _groupBy = require('./internal/operators/groupBy');

        var _observable = require('./internal/symbol/observable');

        var _Subject = require('./internal/Subject');

        var _BehaviorSubject = require('./internal/BehaviorSubject');

        var _ReplaySubject = require('./internal/ReplaySubject');

        var _AsyncSubject = require('./internal/AsyncSubject');

        var _asap = require('./internal/scheduler/asap');

        var _async = require('./internal/scheduler/async');

        var _queue = require('./internal/scheduler/queue');

        var _animationFrame = require('./internal/scheduler/animationFrame');

        var _VirtualTimeScheduler = require('./internal/scheduler/VirtualTimeScheduler');

        var _Scheduler = require('./internal/Scheduler');

        var _Subscription = require('./internal/Subscription');

        var _Subscriber = require('./internal/Subscriber');

        var _Notification = require('./internal/Notification');

        var _pipe = require('./internal/util/pipe');

        var _noop = require('./internal/util/noop');

        var _identity = require('./internal/util/identity');

        var _isObservable = require('./internal/util/isObservable');

        var _ArgumentOutOfRangeError = require('./internal/util/ArgumentOutOfRangeError');

        var _EmptyError = require('./internal/util/EmptyError');

        var _ObjectUnsubscribedError = require('./internal/util/ObjectUnsubscribedError');

        var _UnsubscriptionError = require('./internal/util/UnsubscriptionError');

        var _TimeoutError = require('./internal/util/TimeoutError');

        var _bindCallback = require('./internal/observable/bindCallback');

        var _bindNodeCallback = require('./internal/observable/bindNodeCallback');

        var _combineLatest = require('./internal/observable/combineLatest');

        var _concat = require('./internal/observable/concat');

        var _defer = require('./internal/observable/defer');

        var _empty = require('./internal/observable/empty');

        var _forkJoin = require('./internal/observable/forkJoin');

        var _from = require('./internal/observable/from');

        var _fromEvent = require('./internal/observable/fromEvent');

        var _fromEventPattern = require('./internal/observable/fromEventPattern');

        var _generate = require('./internal/observable/generate');

        var _iif = require('./internal/observable/iif');

        var _interval = require('./internal/observable/interval');

        var _merge = require('./internal/observable/merge');

        var _never = require('./internal/observable/never');

        var _of = require('./internal/observable/of');

        var _onErrorResumeNext = require('./internal/observable/onErrorResumeNext');

        var _pairs = require('./internal/observable/pairs');

        var _partition = require('./internal/observable/partition');

        var _race = require('./internal/observable/race');

        var _range = require('./internal/observable/range');

        var _throwError = require('./internal/observable/throwError');

        var _timer = require('./internal/observable/timer');

        var _using = require('./internal/observable/using');

        var _zip = require('./internal/observable/zip');

        var _scheduled = require('./internal/scheduled/scheduled');

        var _config = require('./internal/config');
      },
      {
        './internal/Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        './internal/observable/ConnectableObservable':
          '../../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js',
        './internal/operators/groupBy': '../../../node_modules/rxjs/_esm5/internal/operators/groupBy.js',
        './internal/symbol/observable': '../../../node_modules/rxjs/_esm5/internal/symbol/observable.js',
        './internal/Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        './internal/BehaviorSubject': '../../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js',
        './internal/ReplaySubject': '../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js',
        './internal/AsyncSubject': '../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
        './internal/scheduler/asap': '../../../node_modules/rxjs/_esm5/internal/scheduler/asap.js',
        './internal/scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        './internal/scheduler/queue': '../../../node_modules/rxjs/_esm5/internal/scheduler/queue.js',
        './internal/scheduler/animationFrame': '../../../node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js',
        './internal/scheduler/VirtualTimeScheduler':
          '../../../node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js',
        './internal/Scheduler': '../../../node_modules/rxjs/_esm5/internal/Scheduler.js',
        './internal/Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        './internal/Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        './internal/Notification': '../../../node_modules/rxjs/_esm5/internal/Notification.js',
        './internal/util/pipe': '../../../node_modules/rxjs/_esm5/internal/util/pipe.js',
        './internal/util/noop': '../../../node_modules/rxjs/_esm5/internal/util/noop.js',
        './internal/util/identity': '../../../node_modules/rxjs/_esm5/internal/util/identity.js',
        './internal/util/isObservable': '../../../node_modules/rxjs/_esm5/internal/util/isObservable.js',
        './internal/util/ArgumentOutOfRangeError':
          '../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
        './internal/util/EmptyError': '../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
        './internal/util/ObjectUnsubscribedError':
          '../../../node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js',
        './internal/util/UnsubscriptionError': '../../../node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js',
        './internal/util/TimeoutError': '../../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js',
        './internal/observable/bindCallback': '../../../node_modules/rxjs/_esm5/internal/observable/bindCallback.js',
        './internal/observable/bindNodeCallback':
          '../../../node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js',
        './internal/observable/combineLatest': '../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js',
        './internal/observable/concat': '../../../node_modules/rxjs/_esm5/internal/observable/concat.js',
        './internal/observable/defer': '../../../node_modules/rxjs/_esm5/internal/observable/defer.js',
        './internal/observable/empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
        './internal/observable/forkJoin': '../../../node_modules/rxjs/_esm5/internal/observable/forkJoin.js',
        './internal/observable/from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
        './internal/observable/fromEvent': '../../../node_modules/rxjs/_esm5/internal/observable/fromEvent.js',
        './internal/observable/fromEventPattern':
          '../../../node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js',
        './internal/observable/generate': '../../../node_modules/rxjs/_esm5/internal/observable/generate.js',
        './internal/observable/iif': '../../../node_modules/rxjs/_esm5/internal/observable/iif.js',
        './internal/observable/interval': '../../../node_modules/rxjs/_esm5/internal/observable/interval.js',
        './internal/observable/merge': '../../../node_modules/rxjs/_esm5/internal/observable/merge.js',
        './internal/observable/never': '../../../node_modules/rxjs/_esm5/internal/observable/never.js',
        './internal/observable/of': '../../../node_modules/rxjs/_esm5/internal/observable/of.js',
        './internal/observable/onErrorResumeNext':
          '../../../node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js',
        './internal/observable/pairs': '../../../node_modules/rxjs/_esm5/internal/observable/pairs.js',
        './internal/observable/partition': '../../../node_modules/rxjs/_esm5/internal/observable/partition.js',
        './internal/observable/race': '../../../node_modules/rxjs/_esm5/internal/observable/race.js',
        './internal/observable/range': '../../../node_modules/rxjs/_esm5/internal/observable/range.js',
        './internal/observable/throwError': '../../../node_modules/rxjs/_esm5/internal/observable/throwError.js',
        './internal/observable/timer': '../../../node_modules/rxjs/_esm5/internal/observable/timer.js',
        './internal/observable/using': '../../../node_modules/rxjs/_esm5/internal/observable/using.js',
        './internal/observable/zip': '../../../node_modules/rxjs/_esm5/internal/observable/zip.js',
        './internal/scheduled/scheduled': '../../../node_modules/rxjs/_esm5/internal/scheduled/scheduled.js',
        './internal/config': '../../../node_modules/rxjs/_esm5/internal/config.js',
      },
    ],
    '../../../node_modules/core-js/modules/es.array.find-index.js': [
      function(require, module, exports) {
        'use strict';
        var $ = require('../internals/export');
        var $findIndex = require('../internals/array-iteration').findIndex;
        var addToUnscopables = require('../internals/add-to-unscopables');
        var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

        var FIND_INDEX = 'findIndex';
        var SKIPS_HOLES = true;

        var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

        // Shouldn't skip holes
        if (FIND_INDEX in [])
          Array(1)[FIND_INDEX](function() {
            SKIPS_HOLES = false;
          });

        // `Array.prototype.findIndex` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.findindex
        $(
          { target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH },
          {
            findIndex: function findIndex(callbackfn /* , that = undefined */) {
              return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            },
          }
        );

        // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
        addToUnscopables(FIND_INDEX);
      },
      {
        '../internals/export': '../../../node_modules/core-js/internals/export.js',
        '../internals/array-iteration': '../../../node_modules/core-js/internals/array-iteration.js',
        '../internals/add-to-unscopables': '../../../node_modules/core-js/internals/add-to-unscopables.js',
        '../internals/array-method-uses-to-length':
          '../../../node_modules/core-js/internals/array-method-uses-to-length.js',
      },
    ],
    '../../../../../../.config/yarn/global/node_modules/base64-js/index.js': [
      function(require, module, exports) {
        'use strict';

        exports.byteLength = byteLength;
        exports.toByteArray = toByteArray;
        exports.fromByteArray = fromByteArray;

        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }

        // Support decoding URL-safe base64 strings, as Node.js does.
        // See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup['-'.charCodeAt(0)] = 62;
        revLookup['_'.charCodeAt(0)] = 63;

        function getLens(b64) {
          var len = b64.length;

          if (len % 4 > 0) {
            throw new Error('Invalid string. Length must be a multiple of 4');
          }

          // Trim off extra bytes after placeholder bytes are found
          // See: https://github.com/beatgammit/base64-js/issues/42
          var validLen = b64.indexOf('=');
          if (validLen === -1) validLen = len;

          var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);

          return [validLen, placeHoldersLen];
        }

        // base64 is 4/3 + up to two characters of the original data
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function _byteLength(b64, validLen, placeHoldersLen) {
          return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;
        }

        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];

          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

          var curByte = 0;

          // if there are placeholders, only get up to the last complete 4 chars
          var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

          var i;
          for (i = 0; i < len; i += 4) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 18) |
              (revLookup[b64.charCodeAt(i + 1)] << 12) |
              (revLookup[b64.charCodeAt(i + 2)] << 6) |
              revLookup[b64.charCodeAt(i + 3)];
            arr[curByte++] = (tmp >> 16) & 0xff;
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 2) {
            tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
            arr[curByte++] = tmp & 0xff;
          }

          if (placeHoldersLen === 1) {
            tmp =
              (revLookup[b64.charCodeAt(i)] << 10) |
              (revLookup[b64.charCodeAt(i + 1)] << 4) |
              (revLookup[b64.charCodeAt(i + 2)] >> 2);
            arr[curByte++] = (tmp >> 8) & 0xff;
            arr[curByte++] = tmp & 0xff;
          }

          return arr;
        }

        function tripletToBase64(num) {
          return (
            lookup[(num >> 18) & 0x3f] + lookup[(num >> 12) & 0x3f] + lookup[(num >> 6) & 0x3f] + lookup[num & 0x3f]
          );
        }

        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i = start; i < end; i += 3) {
            tmp = ((uint8[i] << 16) & 0xff0000) + ((uint8[i + 1] << 8) & 0xff00) + (uint8[i + 2] & 0xff);
            output.push(tripletToBase64(tmp));
          }
          return output.join('');
        }

        function fromByteArray(uint8) {
          var tmp;
          var len = uint8.length;
          var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
          var parts = [];
          var maxChunkLength = 16383; // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1];
            parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + '==');
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + uint8[len - 1];
            parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f] + '=');
          }

          return parts.join('');
        }
      },
      {},
    ],
    '../../../../../../.config/yarn/global/node_modules/ieee754/index.js': [
      function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];

          i += d;

          e = s & ((1 << -nBits) - 1);
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

          m = e & ((1 << -nBits) - 1);
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };

        exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

          value = Math.abs(value);

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }

            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }

          for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

          e = (e << mLen) | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

          buffer[offset + i - d] |= s * 128;
        };
      },
      {},
    ],
    '../../../../../../.config/yarn/global/node_modules/isarray/index.js': [
      function(require, module, exports) {
        var toString = {}.toString;

        module.exports =
          Array.isArray ||
          function(arr) {
            return toString.call(arr) == '[object Array]';
          };
      },
      {},
    ],
    '../../../../../../.config/yarn/global/node_modules/buffer/index.js': [
      function(require, module, exports) {
        var global = arguments[3];
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <http://feross.org>
         * @license  MIT
         */
        /* eslint-disable no-proto */

        ('use strict');

        var base64 = require('base64-js');
        var ieee754 = require('ieee754');
        var isArray = require('isarray');

        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;

        /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
        Buffer.TYPED_ARRAY_SUPPORT =
          global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

        /*
         * Export kMaxLength after typed array support is determined.
         */
        exports.kMaxLength = kMaxLength();

        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function() {
                return 42;
              },
            };
            return (
              arr.foo() === 42 && // typed array instances can be augmented
              typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
              arr.subarray(1, 1).byteLength === 0
            ); // ie10 has broken `subarray`
          } catch (e) {
            return false;
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
        }

        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError('Invalid typed array length');
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = new Uint8Array(length);
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            if (that === null) {
              that = new Buffer(length);
            }
            that.length = length;
          }

          return that;
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
            return new Buffer(arg, encodingOrOffset, length);
          }

          // Common case.
          if (typeof arg === 'number') {
            if (typeof encodingOrOffset === 'string') {
              throw new Error('If encoding is specified then the first argument must be a string');
            }
            return allocUnsafe(this, arg);
          }
          return from(this, arg, encodingOrOffset, length);
        }

        Buffer.poolSize = 8192; // not used by this implementation

        // TODO: Legacy, not needed anymore. Remove in next major version.
        Buffer._augment = function(arr) {
          arr.__proto__ = Buffer.prototype;
          return arr;
        };

        function from(that, value, encodingOrOffset, length) {
          if (typeof value === 'number') {
            throw new TypeError('"value" argument must not be a number');
          }

          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }

          if (typeof value === 'string') {
            return fromString(that, value, encodingOrOffset);
          }

          return fromObject(that, value);
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function(value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };

        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
            });
          }
        }

        function assertSize(size) {
          if (typeof size !== 'number') {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }

        function alloc(that, size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(that, size);
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === 'string'
              ? createBuffer(that, size).fill(fill, encoding)
              : createBuffer(that, size).fill(fill);
          }
          return createBuffer(that, size);
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function(size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };

        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }
          return that;
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function(size) {
          return allocUnsafe(null, size);
        };
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function(size) {
          return allocUnsafe(null, size);
        };

        function fromString(that, string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') {
            encoding = 'utf8';
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }

          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);

          var actual = that.write(string, encoding);

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            that = that.slice(0, actual);
          }

          return that;
        }

        function fromArrayLike(that, array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          that = createBuffer(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255;
          }
          return that;
        }

        function fromArrayBuffer(that, array, byteOffset, length) {
          array.byteLength; // this throws if `array` is not a valid ArrayBuffer

          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError("'offset' is out of bounds");
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError("'length' is out of bounds");
          }

          if (byteOffset === undefined && length === undefined) {
            array = new Uint8Array(array);
          } else if (length === undefined) {
            array = new Uint8Array(array, byteOffset);
          } else {
            array = new Uint8Array(array, byteOffset, length);
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = array;
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            that = fromArrayLike(that, array);
          }
          return that;
        }

        function fromObject(that, obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);

            if (that.length === 0) {
              return that;
            }

            obj.copy(that, 0, 0, len);
            return that;
          }

          if (obj) {
            if ((typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
              if (typeof obj.length !== 'number' || isnan(obj.length)) {
                return createBuffer(that, 0);
              }
              return fromArrayLike(that, obj);
            }

            if (obj.type === 'Buffer' && isArray(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }

          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
        }

        function checked(length) {
          // Note: cannot use `length < kMaxLength()` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= kMaxLength()) {
            throw new RangeError(
              'Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes'
            );
          }
          return length | 0;
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0;
          }
          return Buffer.alloc(+length);
        }

        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer);
        };

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError('Arguments must be Buffers');
          }

          if (a === b) return 0;

          var x = a.length;
          var y = b.length;

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;
            default:
              return false;
          }
        };

        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }

          if (list.length === 0) {
            return Buffer.alloc(0);
          }

          var i;
          if (length === undefined) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }

          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list.length; ++i) {
            var buf = list[i];
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length;
          }
          if (
            typeof ArrayBuffer !== 'undefined' &&
            typeof ArrayBuffer.isView === 'function' &&
            (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)
          ) {
            return string.byteLength;
          }
          if (typeof string !== 'string') {
            string = '' + string;
          }

          var len = string.length;
          if (len === 0) return 0;

          // Use a for loop to avoid recursion
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return len;
              case 'utf8':
              case 'utf-8':
              case undefined:
                return utf8ToBytes(string).length;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2;
              case 'hex':
                return len >>> 1;
              case 'base64':
                return base64ToBytes(string).length;
              default:
                if (loweredCase) return utf8ToBytes(string).length; // assume utf8
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.byteLength = byteLength;

        function slowToString(encoding, start, end) {
          var loweredCase = false;

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0;
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return '';
          }

          if (end === undefined || end > this.length) {
            end = this.length;
          }

          if (end <= 0) {
            return '';
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0;
          start >>>= 0;

          if (end <= start) {
            return '';
          }

          if (!encoding) encoding = 'utf8';

          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end);

              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end);

              case 'ascii':
                return asciiSlice(this, start, end);

              case 'latin1':
              case 'binary':
                return latin1Slice(this, start, end);

              case 'base64':
                return base64Slice(this, start, end);

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end);

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
            }
          }
        }

        // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
        // Buffer instances.
        Buffer.prototype._isBuffer = true;

        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 16-bits');
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }
          return this;
        };

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 32-bits');
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 64-bits');
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };

        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return '';
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
          if (this === b) return true;
          return Buffer.compare(this, b) === 0;
        };

        Buffer.prototype.inspect = function inspect() {
          var str = '';
          var max = exports.INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString('hex', 0, max)
              .match(/.{2}/g)
              .join(' ');
            if (this.length > max) str += ' ... ';
          }
          return '<Buffer ' + str + '>';
        };

        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError('Argument must be a Buffer');
          }

          if (start === undefined) {
            start = 0;
          }
          if (end === undefined) {
            end = target ? target.length : 0;
          }
          if (thisStart === undefined) {
            thisStart = 0;
          }
          if (thisEnd === undefined) {
            thisEnd = this.length;
          }

          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError('out of range index');
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }

          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;

          if (this === target) return 0;

          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);

          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1;

          // Normalize byteOffset
          if (typeof byteOffset === 'string') {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff;
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000;
          }
          byteOffset = +byteOffset; // Coerce to Number.
          if (isNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1;
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir) return -1;
            else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;
            else return -1;
          }

          // Normalize val
          if (typeof val === 'string') {
            val = Buffer.from(val, encoding);
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === 'number') {
            val = val & 0xff; // Search for a byte value [0-255]
            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }

          throw new TypeError('val must be string, number or Buffer');
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase();
            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i];
            } else {
              return buf.readUInt16BE(i * indexSize);
            }
          }

          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found) return i;
            }
          }

          return -1;
        }

        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };

        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }

          // must be an even number of digits
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }

        Buffer.prototype.write = function write(string, offset, length, encoding) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = 'utf8';
            length = this.length;
            offset = 0;
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset;
            length = this.length;
            offset = 0;
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = 'utf8';
            } else {
              encoding = length;
              length = undefined;
            }
            // legacy write(string, encoding, offset, length) - remove in v0.13
          } else {
            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
          }

          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;

          if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
            throw new RangeError('Attempt to write outside buffer bounds');
          }

          if (!encoding) encoding = 'utf8';

          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length);

              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length);

              case 'ascii':
                return asciiWrite(this, string, offset, length);

              case 'latin1':
              case 'binary':
                return latin1Write(this, string, offset, length);

              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length);

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        };

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];

          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 0xc0) === 0x80) {
                    tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);
                    if (tempCodePoint > 0x7f) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
                    tempCodePoint = ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);
                    if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {
                    tempCodePoint =
                      ((firstByte & 0xf) << 0x12) |
                      ((secondByte & 0x3f) << 0xc) |
                      ((thirdByte & 0x3f) << 0x6) |
                      (fourthByte & 0x3f);
                    if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xfffd;
              bytesPerSequence = 1;
            } else if (codePoint > 0xffff) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000;
              res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
              codePoint = 0xdc00 | (codePoint & 0x3ff);
            }

            res.push(codePoint);
            i += bytesPerSequence;
          }

          return decodeCodePointsArray(res);
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000;

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = '';
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));
          }
          return res;
        }

        function asciiSlice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7f);
          }
          return ret;
        }

        function latin1Slice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }

        function hexSlice(buf, start, end) {
          var len = buf.length;

          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;

          var out = '';
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }
          return out;
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = '';
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;

          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }

          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }

          if (end < start) end = start;

          var newBuf;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);
            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }

          return newBuf;
        };

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
        }

        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);

          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }

          return val;
        };

        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length);
          }

          var val = this[offset + --byteLength];
          var mul = 1;
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul;
          }

          return val;
        };

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };

        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | (this[offset + 1] << 8);
        };

        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return (this[offset] << 8) | this[offset + 1];
        };

        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + this[offset + 3] * 0x1000000;
        };

        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return this[offset] * 0x1000000 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
        };

        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);

          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }
          mul *= 0x80;

          if (val >= mul) val -= Math.pow(2, 8 * byteLength);

          return val;
        };

        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);

          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul;
          }
          mul *= 0x80;

          if (val >= mul) val -= Math.pow(2, 8 * byteLength);

          return val;
        };

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 0x80)) return this[offset];
          return (0xff - this[offset] + 1) * -1;
        };

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | (this[offset + 1] << 8);
          return val & 0x8000 ? val | 0xffff0000 : val;
        };

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | (this[offset] << 8);
          return val & 0x8000 ? val | 0xffff0000 : val;
        };

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
        };

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);

          return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3];
        };

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };

        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };

        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var mul = 1;
          var i = 0;
          this[offset] = value & 0xff;
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 0xff;
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 0xff;
          return offset + 1;
        };

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffff + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> ((littleEndian ? i : 1 - i) * 8);
          }
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffffffff + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = (value >>> ((littleEndian ? i : 3 - i) * 8)) & 0xff;
          }
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };

        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);

            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 0xff;
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);

            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = byteLength - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 0xff;
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 0xff + value + 1;
          this[offset] = value & 0xff;
          return offset + 1;
        };

        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };

        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };

        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };

        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (value < 0) value = 0xffffffff + value + 1;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
          if (offset < 0) throw new RangeError('Index out of range');
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38);
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308);
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;

          // Copy 0 bytes; we're done
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds');
          }
          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
          if (end < 0) throw new RangeError('sourceEnd out of bounds');

          // Are we oob?
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }

          var len = end - start;
          var i;

          if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            // ascending copy from start
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
          }

          return len;
        };

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === 'string') {
            if (typeof start === 'string') {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === 'string') {
              encoding = end;
              end = this.length;
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (code < 256) {
                val = code;
              }
            }
            if (encoding !== undefined && typeof encoding !== 'string') {
              throw new TypeError('encoding must be a string');
            }
            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }
          } else if (typeof val === 'number') {
            val = val & 255;
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError('Out of range index');
          }

          if (end <= start) {
            return this;
          }

          start = start >>> 0;
          end = end === undefined ? this.length : end >>> 0;

          if (!val) val = 0;

          var i;
          if (typeof val === 'number') {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
            var len = bytes.length;
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }

          return this;
        };

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

        function base64clean(str) {
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = stringtrim(str).replace(INVALID_BASE64_RE, '');
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return '';
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + '=';
          }
          return str;
        }

        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, '');
        }

        function toHex(n) {
          if (n < 16) return '0' + n.toString(16);
          return n.toString(16);
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);

            // is surrogate component
            if (codePoint > 0xd7ff && codePoint < 0xe000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xdbff) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  continue;
                }

                // valid lead
                leadSurrogate = codePoint;

                continue;
              }

              // 2 leads in a row
              if (codePoint < 0xdc00) {
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                leadSurrogate = codePoint;
                continue;
              }

              // valid surrogate pair
              codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
            }

            leadSurrogate = null;

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              bytes.push(
                (codePoint >> 0x12) | 0xf0,
                ((codePoint >> 0xc) & 0x3f) | 0x80,
                ((codePoint >> 0x6) & 0x3f) | 0x80,
                (codePoint & 0x3f) | 0x80
              );
            } else {
              throw new Error('Invalid code point');
            }
          }

          return bytes;
        }

        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xff);
          }
          return byteArray;
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;

            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }

          return byteArray;
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }

        function isnan(val) {
          return val !== val; // eslint-disable-line no-self-compare
        }
      },
      {
        'base64-js': '../../../../../../.config/yarn/global/node_modules/base64-js/index.js',
        ieee754: '../../../../../../.config/yarn/global/node_modules/ieee754/index.js',
        isarray: '../../../../../../.config/yarn/global/node_modules/isarray/index.js',
        buffer: '../../../../../../.config/yarn/global/node_modules/buffer/index.js',
      },
    ],
    '../../../node_modules/@scalecube/browser/es/index.js': [
      function(require, module, exports) {
        var global = arguments[3];
        var Buffer = require('buffer').Buffer;
        ('use strict');

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.workers = exports.stringToAddress = exports.createMicroservice = exports.ASYNC_MODEL_TYPES = void 0;

        require('core-js/modules/es.symbol');

        require('core-js/modules/es.symbol.description');

        require('core-js/modules/es.symbol.async-iterator');

        require('core-js/modules/es.symbol.iterator');

        require('core-js/modules/es.array.concat');

        require('core-js/modules/es.array.iterator');

        require('core-js/modules/es.object.assign');

        require('core-js/modules/es.object.get-own-property-descriptor');

        require('core-js/modules/es.object.to-string');

        require('core-js/modules/es.promise');

        require('core-js/modules/es.string.iterator');

        require('core-js/modules/web.dom-collections.iterator');

        require('core-js/modules/es.array.copy-within');

        require('core-js/modules/es.array.filter');

        require('core-js/modules/es.array.includes');

        require('core-js/modules/es.array.join');

        require('core-js/modules/es.array.map');

        require('core-js/modules/es.array.slice');

        require('core-js/modules/es.array.splice');

        require('core-js/modules/es.array-buffer.constructor');

        require('core-js/modules/es.function.name');

        require('core-js/modules/es.map');

        require('core-js/modules/es.number.constructor');

        require('core-js/modules/es.number.is-integer');

        require('core-js/modules/es.number.max-safe-integer');

        require('core-js/modules/es.object.freeze');

        require('core-js/modules/es.object.keys');

        require('core-js/modules/es.object.values');

        require('core-js/modules/es.regexp.flags');

        require('core-js/modules/es.regexp.to-string');

        require('core-js/modules/es.set');

        require('core-js/modules/es.string.includes');

        require('core-js/modules/es.string.replace');

        require('core-js/modules/es.string.split');

        require('core-js/modules/es.typed-array.uint8-array');

        require('core-js/modules/es.typed-array.copy-within');

        require('core-js/modules/es.typed-array.every');

        require('core-js/modules/es.typed-array.fill');

        require('core-js/modules/es.typed-array.filter');

        require('core-js/modules/es.typed-array.find');

        require('core-js/modules/es.typed-array.find-index');

        require('core-js/modules/es.typed-array.for-each');

        require('core-js/modules/es.typed-array.includes');

        require('core-js/modules/es.typed-array.index-of');

        require('core-js/modules/es.typed-array.iterator');

        require('core-js/modules/es.typed-array.join');

        require('core-js/modules/es.typed-array.last-index-of');

        require('core-js/modules/es.typed-array.map');

        require('core-js/modules/es.typed-array.reduce');

        require('core-js/modules/es.typed-array.reduce-right');

        require('core-js/modules/es.typed-array.reverse');

        require('core-js/modules/es.typed-array.set');

        require('core-js/modules/es.typed-array.slice');

        require('core-js/modules/es.typed-array.some');

        require('core-js/modules/es.typed-array.sort');

        require('core-js/modules/es.typed-array.subarray');

        require('core-js/modules/es.typed-array.to-locale-string');

        require('core-js/modules/es.typed-array.to-string');

        require('core-js/modules/web.dom-collections.for-each');

        var _rxjs = require('rxjs');

        require('core-js/modules/es.array.find-index');

        function _typeof(obj) {
          if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
            _typeof = function(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function(obj) {
              return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }

          return _typeof(obj);
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
        }

        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

            return arr2;
          }
        }

        function _iterableToArray(iter) {
          if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === '[object Arguments]')
            return Array.from(iter);
        }

        function _nonIterableSpread() {
          throw new TypeError('Invalid attempt to spread non-iterable instance');
        }

        var _assign = function __assign() {
          _assign =
            Object.assign ||
            function __assign(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];

                for (var p in s) {
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
              }

              return t;
            };

          return _assign.apply(this, arguments);
        };
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

        /* global Reflect, Promise */

        var _extendStatics = function extendStatics(d, b) {
          _extendStatics =
            Object.setPrototypeOf ||
            ({
              __proto__: [],
            } instanceof Array &&
              function(d, b) {
                d.__proto__ = b;
              }) ||
            function(d, b) {
              for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
              }
            };

          return _extendStatics(d, b);
        };

        function __extends(d, b) {
          _extendStatics(d, b);

          function __() {
            this.constructor = d;
          }

          d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
        }

        var _assign$1 = function __assign() {
          _assign$1 =
            Object.assign ||
            function __assign(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];

                for (var p in s) {
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
              }

              return t;
            };

          return _assign$1.apply(this, arguments);
        };

        var assert = function assert(predicate, msg) {
          if (!predicate) {
            throw new Error(msg);
          }
        };

        var isDefined = function isDefined(val) {
          return typeof val !== 'undefined';
        };

        var assertDefined = function assertDefined(val, msg) {
          if (msg === void 0) {
            msg = 'Expect to be defined';
          }

          assert(isDefined(val), msg);
        };

        var isString = function isString(val) {
          return typeof val === 'string' || val instanceof String;
        };

        var assertString = function assertString(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be a string';
          }

          assert(isDefined(val) && isString(val), msg);
        };

        var assertNonEmptyString = function assertNonEmptyString(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be non empty string';
          }

          assertString(val, msg);
          assert(val.length > 0, msg);
        };

        var isArray = function isArray(val) {
          return Array.isArray(val);
        };

        var assertArray = function assertArray(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be an array';
          }

          assert(isArray(val), msg);
        };

        var isObject = function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]';
        };

        var assertObject = function assertObject(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be an object';
          }

          assert(isObject(val), msg);
        };

        var assertNonEmptyObject = function assertNonEmptyObject(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be non empty object';
          }

          assertObject(val, msg);
          assert(Object.keys(val).length > 0, msg);
        };

        var isOneOf = function isOneOf(collection, val) {
          if (isArray(collection)) {
            return collection.includes(val);
          }

          if (isObject(collection)) {
            return Object.values(collection).includes(val);
          }

          return false;
        };

        var assertOneOf = function assertOneOf(collection, val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be one of the collection elements';
          }

          assert(isOneOf(collection, val), msg);
        };

        var isFunction = function isFunction(val) {
          return typeof val === 'function' && !/^class\s/.test(Function.prototype.toString.call(val));
        };

        var assertFunction = function assertFunction(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be a function';
          }

          assert(isFunction(val), msg);
        };

        var isNumber = function isNumber(val) {
          return typeof val === 'number' && !isNaN(val);
        };

        var assertNumber = function assertNumber(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be a number';
          }

          assert(isNumber(val), msg);
        };

        var NOT_VALID_PROTOCOL = 'Not a valid protocol';
        var NOT_VALID_ADDRESS = 'Address must be of type object';
        var NOT_VALID_HOST = 'Not a valid host';
        var NOT_VALID_PATH = 'Not a valid path';
        var NOT_VALID_PORT = 'Not a valid port';
        var ASYNC_MODEL_TYPES = {
          REQUEST_RESPONSE: 'requestResponse',
          REQUEST_STREAM: 'requestStream',
        };
        var SERVICE_NAME_NOT_PROVIDED = 'MS0020 - Invalid format, definition must contain valid serviceName';
        var DEFINITION_MISSING_METHODS = 'MS0021 - Invalid format, definition must contain valid methods';
        var INVALID_METHODS = 'MS0022 - Invalid format, definition must contain valid methods';

        var getServiceNameInvalid = function getServiceNameInvalid(serviceName) {
          return (
            'MS0023 - Invalid format, serviceName must be not empty string but received type ' + _typeof(serviceName)
          );
        };

        var getIncorrectMethodValueError = function getIncorrectMethodValueError(qualifier) {
          return 'Method value for ' + qualifier + ' definition should be non empty object';
        };

        var getAsynModelNotProvidedError = function getAsynModelNotProvidedError(qualifier) {
          return 'Async model is not provided in service definition for ' + qualifier;
        };

        var getInvalidAsyncModelError = function getInvalidAsyncModelError(qualifier) {
          return 'Invalid async model in service definition for ' + qualifier;
        };

        var validateAddress = function validateAddress(address, isOptional) {
          if (isOptional === void 0) {
            isOptional = true;
          }

          if (isOptional && typeof address === 'undefined') {
            return true;
          }

          assertNonEmptyObject(address, NOT_VALID_ADDRESS);
          var host = address.host,
            path = address.path,
            protocol = address.protocol;
          var port = address.port;
          port = isString(port) ? Number(port) : port;
          assertString(host, NOT_VALID_HOST);
          assertString(path, NOT_VALID_PATH);
          assertNumber(port, NOT_VALID_PORT);
          assertString(protocol, NOT_VALID_PROTOCOL);
          assert(isOneOf(['pm', 'ws', 'wss', 'tcp'], protocol), NOT_VALID_PROTOCOL);
          return true;
        };
        /**
         * address is <protocol>://<host>:<port>/<path>
         */

        var getFullAddress = function getFullAddress(address) {
          validateAddress(address, false);
          var host = address.host,
            path = address.path,
            port = address.port,
            protocol = address.protocol;
          return protocol + '://' + host + ':' + port + '/' + path;
        };

        var getAddress = function getAddress(address) {
          var newAddress = {};
          address = buildAddress({
            key: 'protocol',
            optionalValue: 'pm',
            delimiter: '://',
            str: address,
            newAddress: newAddress,
          });
          address = buildAddress({
            key: 'host',
            optionalValue: 'defaultHost',
            delimiter: ':',
            str: address,
            newAddress: newAddress,
          });
          address = buildAddress({
            key: 'port',
            optionalValue: 8080,
            delimiter: '/',
            str: address,
            newAddress: newAddress,
          });
          newAddress.path = address;
          return newAddress;
        };

        exports.stringToAddress = getAddress;

        var buildAddress = function buildAddress(_a) {
          var key = _a.key,
            optionalValue = _a.optionalValue,
            delimiter = _a.delimiter,
            newAddress = _a.newAddress,
            str = _a.str;

          var _b = str.split(delimiter),
            v1 = _b[0],
            rest = _b[1];

          if (!rest) {
            rest = v1;
            v1 = optionalValue;
          }

          newAddress[key] = v1;
          return rest;
        };

        var isNodejs = function isNodejs() {
          return !navigator;
        }; // common api for main threat or worker in the browser

        var workersMap = {};

        var initialize = function initialize() {
          if (!isNodejs()) {
            // @ts-ignore
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              console.warn("Don't use this on webworkers, only on the main thread");
            } else {
              addEventListener('message', function(ev) {
                if (ev && ev.data && !ev.data.workerId) {
                  if (ev.data.detail) {
                    ev.data.workerId = 1;
                    var propogateTo = workersMap[ev.data.detail.to] || workersMap[ev.data.detail.address]; // discoveryEvents || rsocketEvents

                    if (propogateTo) {
                      // @ts-ignore
                      propogateTo.postMessage(ev.data, ev.ports);
                    }
                  }
                }
              });
            }
          }
        };

        function workerEventHandler(ev) {
          if (ev.data && ev.data.detail && ev.data.type) {
            var detail = ev.data.detail;

            if (!ev.data.workerId) {
              ev.data.workerId = 1;

              if (ev.data.type === 'ConnectWorkerEvent') {
                if (detail.whoAmI) {
                  // @ts-ignore
                  workersMap[detail.whoAmI] = this;
                }
              } else {
                var propogateTo = workersMap[detail.to] || workersMap[detail.address]; // discoveryEvents || rsocketEvents

                if (propogateTo) {
                  // @ts-ignore
                  propogateTo.postMessage(ev.data, ev.ports);
                } else {
                  // @ts-ignore
                  postMessage(ev.data, '*', ev.ports);
                }
              }
            }
          }
        }

        var addWorker = function addWorker(worker) {
          worker.addEventListener('message', workerEventHandler.bind(worker));
        };

        var removeWorker = function removeWorker(worker) {
          worker.removeEventListener('message', workerEventHandler.bind(worker));
        };

        var colorsMap = {};

        var getRandomColor = function getRandomColor() {
          var letters = '0123456789ABCDEF';
          var color = '#';

          for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
          }

          return color;
        };

        var saveToLogs = function saveToLogs(identifier, msg, extra, debug, type) {
          if (type === void 0) {
            type = 'log';
          }

          if (!colorsMap[identifier]) {
            colorsMap[identifier] = getRandomColor();
          } // tslint:disable

          if (debug) {
            var logColor = 'color:' + colorsMap[identifier];
            extra && console[type]('%c******** address: ' + identifier + '********', logColor);
            console[type](msg);
            extra &&
              Object.keys(extra).forEach(function(key) {
                if (Array.isArray(extra[key])) {
                  Object.values(extra[key]).forEach(function(props) {
                    console[type](key + ': ' + JSON.stringify(props.qualifier || props, null, 2));
                  });
                } else {
                  console[type](key + ': ' + JSON.stringify(extra[key], null, 2));
                }
              });
          } // tslint:enable
        };

        var getQualifier = function getQualifier(_a) {
          var serviceName = _a.serviceName,
            methodName = _a.methodName;
          return serviceName + '/' + methodName;
        };

        var validateServiceDefinition = function validateServiceDefinition(definition) {
          assertNonEmptyObject(definition);
          var serviceName = definition.serviceName,
            methods = definition.methods;
          assertDefined(serviceName, SERVICE_NAME_NOT_PROVIDED);
          assertNonEmptyString(serviceName, getServiceNameInvalid(serviceName));
          assertDefined(methods, DEFINITION_MISSING_METHODS);
          assertNonEmptyObject(methods, INVALID_METHODS);
          Object.keys(methods).forEach(function(methodName) {
            assertNonEmptyString(methodName);
            var qualifier = getQualifier({
              serviceName: serviceName,
              methodName: methodName,
            });
            validateAsyncModel(qualifier, methods[methodName]);
          });
        };

        var validateAsyncModel = function validateAsyncModel(qualifier, val) {
          assertNonEmptyObject(val, getIncorrectMethodValueError(qualifier));
          var asyncModel = val.asyncModel;
          assertDefined(asyncModel, getAsynModelNotProvidedError(qualifier));
          assertOneOf(ASYNC_MODEL_TYPES, asyncModel, getInvalidAsyncModelError(qualifier));
        };

        var MessagePortPolyfill =
          /** @class */
          (function() {
            function MessagePortPolyfill(whoami) {
              this.onmessage = null;
              this.onmessageerror = null;
              this.otherPort = null;
              this.onmessageListeners = [];
              this.queue = [];
              this.otherSideStart = false;
              this.whoami = whoami;
            }

            MessagePortPolyfill.prototype.dispatchEvent = function(event) {
              if (this.onmessage) {
                this.onmessage(event);
              }

              this.onmessageListeners.forEach(function(listener) {
                return listener(event);
              });
              return true;
            };

            MessagePortPolyfill.prototype.postMessage = function(message) {
              if (!this.otherPort) {
                return;
              }

              if (this.otherSideStart) {
                this.otherPort.dispatchEvent({
                  data: message,
                });
              } else {
                this.queue.push(message);
              }
            };

            MessagePortPolyfill.prototype.addEventListener = function(type, listener) {
              if (type !== 'message') {
                return;
              }

              if (typeof listener !== 'function' || this.onmessageListeners.indexOf(listener) !== -1) {
                return;
              }

              this.onmessageListeners.push(listener);
            };

            MessagePortPolyfill.prototype.removeEventListener = function(type, listener) {
              if (type !== 'message') {
                return;
              }

              var index = this.onmessageListeners.indexOf(listener);

              if (index === -1) {
                return;
              }

              this.onmessageListeners.splice(index, 1);
            };

            MessagePortPolyfill.prototype.start = function() {
              var _this = this;

              setTimeout(function() {
                return _this.otherPort && _this.otherPort.startSending.apply(_this.otherPort, []);
              }, 0);
            };

            MessagePortPolyfill.prototype.close = function() {
              var _this = this;

              setTimeout(function() {
                return _this.otherPort && _this.otherPort.stopSending.apply(_this.otherPort, []);
              }, 0);
            };

            MessagePortPolyfill.prototype.startSending = function() {
              var _this = this;

              this.otherSideStart = true;
              this.queue.forEach(function(message) {
                return (
                  _this.otherPort &&
                  _this.otherPort.dispatchEvent({
                    data: message,
                  })
                );
              });
            };

            MessagePortPolyfill.prototype.stopSending = function() {
              this.otherSideStart = false;
              this.queue.length = 0;
            };

            return MessagePortPolyfill;
          })(); // tslint:disable-next-line

        var MessageChannelPolyfill =
          /** @class */
          (function() {
            function MessageChannelPolyfill() {
              this.port1 = new MessagePortPolyfill('client');
              this.port2 = new MessagePortPolyfill('server');
              this.port1.otherPort = this.port2;
              this.port2.otherPort = this.port1;
            }

            return MessageChannelPolyfill;
          })();

        var globalObj =
          typeof window !== 'undefined' && window.Math === Math
            ? window
            : typeof self !== 'undefined' && self.Math === Math
            ? self
            : Function('return this')();

        function applyMessageChannelPolyfill() {
          globalObj.MessagePort = MessagePortPolyfill;
          globalObj.MessageChannel = MessageChannelPolyfill;
        }

        if (!globalObj.MessagePort || !globalObj.MessageChannel) {
          applyMessageChannelPolyfill();
        }

        var workers = !isNodejs()
          ? {
              addWorker: addWorker,
              removeWorker: removeWorker,
              initialize: initialize,
            }
          : {};
        exports.workers = workers;
        var MEMBERSHIP_EVENT = 'membershipEvent';
        var MEMBERSHIP_EVENT_INIT_SERVER = 'membershipEventInitServer';
        var MEMBERSHIP_EVENT_INIT_CLIENT = 'membershipEventInitClient';
        var MESSAGE = 'message';
        var ADDED = 'ADDED';
        var REMOVED = 'REMOVED';
        var INIT = 'INIT';

        var getMultiInitClientFromServer = function getMultiInitClientFromServer(whoAmI, from) {
          return (
            'PLEASE PAY ATTENTION:\n            ' +
            whoAmI +
            ' received multiple ' +
            MEMBERSHIP_EVENT_INIT_CLIENT +
            ' from ' +
            from +
            ',        \n            it might happen if the addresses are not unique. and might result with incorrect behavior\n            '
          );
        };

        var getKeysAsArray = function getKeysAsArray(obj) {
          return (obj && Object.keys(obj)) || [];
        };

        var localAddress = [];

        var setLocalAddress = function setLocalAddress(address) {
          localAddress = localAddress.concat([address]);
          return localAddress;
        };

        var genericPostMessage = function genericPostMessage(data, transfer) {
          try {
            // @ts-ignore
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              if (data.detail && data.detail.to && localAddress.indexOf(data.detail.to) > -1) {
                var event_1 = new MessageEvent('message', {
                  data: data,
                  ports: transfer ? transfer : undefined,
                });
                dispatchEvent(event_1);
              } else {
                // @ts-ignore
                postMessage(data, transfer ? transfer : undefined);
              }
            } else {
              if (data.type === 'ConnectWorkerEvent') {
                return;
              }

              postMessage(data, '*', transfer ? transfer : undefined);
            }
          } catch (e) {
            console.error('Unable to post message ', e);
          }
        };

        var __assign$2 = function() {
          __assign$2 =
            Object.assign ||
            function(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];

                for (var p in s) {
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
              }

              return t;
            };

          return __assign$2.apply(this, arguments);
        };

        var server = function server(options) {
          var _a;

          var whoAmI = options.whoAmI,
            itemsToPublish = options.itemsToPublish,
            rSubjectMembers = options.rSubjectMembers,
            membersStatus = options.membersStatus,
            updateConnectedMember = options.updateConnectedMember,
            getMembershipEvent = options.getMembershipEvent,
            port1 = options.port1,
            seed = options.seed,
            debug = options.debug;
          var eventHandlers =
            ((_a = {}),
            (_a['globalEventsHandler' + whoAmI] = function(ev) {
              var _a, _b;

              var _c = ev.data,
                evType = _c.type,
                membershipEvent = _c.detail;

              if (evType === MEMBERSHIP_EVENT) {
                var metadata = membershipEvent.metadata,
                  type = membershipEvent.type,
                  to = membershipEvent.to,
                  from = membershipEvent.from,
                  origin_1 = membershipEvent.origin;

                if (origin_1 === whoAmI || from === whoAmI || from === to || to !== whoAmI) {
                  return;
                }

                if (membersStatus.membersState[origin_1]) {
                  saveToLogs(whoAmI, getMultiInitClientFromServer(whoAmI, origin_1), {}, debug, 'warn');
                  return;
                } // console.log('Server listen to global', { ...membersStatus.membersState },metadata, whoAmI)

                var mPort = ev && ev.ports && ev.ports[0];

                if (!mPort) {
                  console.error(whoAmI + ' unable to receive port from ' + from);
                }

                mPort.addEventListener(MESSAGE, eventHandlers['portEventsHandler' + whoAmI]);
                mPort.start(); // 1. update seed with the new metadata

                seed &&
                  port1.postMessage(
                    getMembershipEvent({
                      from: whoAmI,
                      to: seed,
                      origin: origin_1,
                      metadata: metadata,
                      type: ADDED,
                    })
                  ); // 2. response to initiator of the contact with all members data

                mPort.postMessage(
                  getMembershipEvent({
                    from: whoAmI,
                    to: from,
                    origin: whoAmI,
                    metadata: __assign$2(
                      {},
                      membersStatus.membersState,
                      ((_a = {}), (_a[whoAmI] = itemsToPublish), _a)
                    ),
                    type: INIT,
                  })
                ); // 3. update membersState

                membersStatus.membersState = __assign$2({}, membersStatus.membersState, metadata);
                updateConnectedMember({
                  metadata: metadata,
                  type: ADDED,
                  from: from,
                  to: to,
                  origin: origin_1,
                }); // 4. update ports

                membersStatus.membersPort = __assign$2(
                  {},
                  membersStatus.membersPort,
                  ((_b = {}), (_b[from] = mPort), _b)
                );
                rSubjectMembers &&
                  rSubjectMembers.next({
                    type: type,
                    items: metadata[origin_1],
                    from: origin_1,
                  });
                saveToLogs(
                  whoAmI,
                  whoAmI + ' server received ' + type + ' request from ' + from,
                  __assign$2({}, membersStatus.membersState),
                  debug
                );
              }

              if (evType === MEMBERSHIP_EVENT_INIT_SERVER) {
                var to = membershipEvent.to,
                  origin_2 = membershipEvent.origin;

                if (to === whoAmI && to !== origin_2) {
                  genericPostMessage({
                    detail: {
                      from: whoAmI,
                      to: origin_2,
                      origin: origin_2,
                    },
                    type: MEMBERSHIP_EVENT_INIT_CLIENT,
                  });
                }
              }
            }),
            (_a['portEventsHandler' + whoAmI] = function(ev) {
              var _a = ev.data,
                evType = _a.type,
                membershipEvent = _a.detail;
              var metadata = membershipEvent.metadata,
                type = membershipEvent.type,
                from = membershipEvent.from,
                to = membershipEvent.to,
                origin = membershipEvent.origin;

              if (origin === whoAmI || from === whoAmI || to !== whoAmI) {
                return;
              } // update seed with the change in members

              seed &&
                port1.postMessage(
                  getMembershipEvent({
                    from: whoAmI,
                    to: seed,
                    origin: origin,
                    metadata: metadata,
                    type: type,
                  })
                );

              switch (type) {
                case INIT:
                  break;

                case ADDED:
                  membersStatus.membersState = __assign$2({}, membersStatus.membersState, metadata);
                  break;

                case REMOVED:
                  if (membersStatus.membersState[origin]) {
                    delete membersStatus.membersState[origin];
                  }

                  var mPort = membersStatus.membersPort[origin];

                  if (mPort) {
                    mPort.postMessage(
                      getMembershipEvent({
                        type: REMOVED,
                        metadata: {},
                        to: from,
                        from: to,
                        origin: whoAmI,
                      })
                    );
                    membersStatus.membersPort[origin].close();
                  }

                  break;

                default:
                  saveToLogs(whoAmI, 'Not supported membership event type', {}, debug, 'warn');
                  return;
              }

              rSubjectMembers &&
                rSubjectMembers.next({
                  type: type,
                  items: metadata[origin],
                  from: origin,
                });
              updateConnectedMember({
                metadata: metadata,
                type: type === INIT ? ADDED : type,
                from: from,
                to: to,
                origin: origin,
              });
              saveToLogs(
                whoAmI,
                whoAmI + ' server received ' + type + ' request from ' + from,
                {
                  membersState: __assign$2({}, membersStatus.membersState),
                  membersPort: getKeysAsArray(__assign$2({}, membersStatus.membersPort)),
                },
                debug
              );
            }),
            _a);
          return {
            start: function start() {
              addEventListener(MESSAGE, eventHandlers['globalEventsHandler' + whoAmI]);
              genericPostMessage({
                detail: {
                  whoAmI: whoAmI,
                },
                type: 'ConnectWorkerEvent',
              });
            },
            stop: function stop() {
              removeEventListener(MESSAGE, eventHandlers['globalEventsHandler' + whoAmI]);
              var membersList = getKeysAsArray(__assign$2({}, membersStatus.membersPort));
              membersList.forEach(function(to) {
                var _a;

                var mPort = membersStatus.membersPort[to];
                mPort &&
                  mPort.postMessage(
                    getMembershipEvent({
                      to: to,
                      from: whoAmI,
                      origin: whoAmI,
                      metadata: ((_a = {}), (_a[whoAmI] = itemsToPublish), _a),
                      type: REMOVED,
                    })
                  );
                mPort.removeEventListener(MESSAGE, eventHandlers['portEventsHandler' + whoAmI]);
                mPort.close();
              });
              return Promise.resolve('');
            },
          };
        };

        var __assign$3 = function() {
          __assign$3 =
            Object.assign ||
            function(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];

                for (var p in s) {
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
              }

              return t;
            };

          return __assign$3.apply(this, arguments);
        };

        var client = function client(options) {
          var _a;

          var whoAmI = options.whoAmI,
            membersStatus = options.membersStatus,
            updateConnectedMember = options.updateConnectedMember,
            getMembershipEvent = options.getMembershipEvent,
            itemsToPublish = options.itemsToPublish,
            rSubjectMembers = options.rSubjectMembers,
            port1 = options.port1,
            port2 = options.port2,
            debug = options.debug,
            retry = options.retry,
            seedAddress = options.seedAddress;
          var seed = '';
          var retryTimer = null;
          var countServers = 0;
          var eventHandlers =
            ((_a = {}), // tslint:disable-next-line
            (_a['globalEventsHandler' + whoAmI] = function(ev) {
              var _a;

              var _b = ev.data,
                evType = _b.type,
                membershipEvent = _b.detail;

              if (evType === MEMBERSHIP_EVENT_INIT_CLIENT) {
                var from = membershipEvent.from,
                  origin_1 = membershipEvent.origin;

                if (from === seed && origin_1 && origin_1 === whoAmI) {
                  countServers++;

                  if (countServers > 1) {
                    saveToLogs(whoAmI, getMultiInitClientFromServer(whoAmI, from), {}, debug, 'warn');
                    return;
                  } // @ts-ignore

                  port1.addEventListener(MESSAGE, eventHandlers['portEventsHandler' + whoAmI].bind(this));
                  port1.start();
                  clearInterval(retryTimer);
                  removeEventListener(MESSAGE, eventHandlers['globalEventsHandler' + whoAmI]);
                  retryTimer = null;
                  genericPostMessage(
                    getMembershipEvent({
                      metadata: ((_a = {}), (_a[whoAmI] = itemsToPublish), _a),
                      type: INIT,
                      to: seed,
                      from: whoAmI,
                      origin: whoAmI,
                    }),
                    [port2]
                  );
                }
              }
            }), // tslint:disable-next-line
            (_a['portEventsHandler' + whoAmI] = function(ev) {
              var _a = ev.data,
                evType = _a.type,
                membershipEvent = _a.detail;

              if (evType === MEMBERSHIP_EVENT) {
                var metadata_1 = membershipEvent.metadata,
                  type_1 = membershipEvent.type,
                  from = membershipEvent.from,
                  to = membershipEvent.to,
                  origin_2 = membershipEvent.origin;

                if (origin_2 === whoAmI || from === whoAmI || from === to) {
                  return;
                }

                switch (type_1) {
                  case INIT:
                    clearInterval(retryTimer);
                    removeEventListener(MESSAGE, eventHandlers['globalEventsHandler' + whoAmI]);
                    retryTimer = null;
                    membersStatus.membersState = __assign$3({}, membersStatus.membersState, metadata_1); // @ts-ignore

                    this.resolveClusterStart
                      ? this.resolveClusterStart()
                      : console.error('unable to resolve cluster client.');
                    break;

                  case ADDED:
                    membersStatus.membersState = __assign$3({}, membersStatus.membersState, metadata_1);
                    break;

                  case REMOVED:
                    if (membersStatus.membersState[from]) {
                      delete membersStatus.membersState[from];
                    }

                    break;
                }

                updateConnectedMember({
                  metadata: metadata_1,
                  type: type_1 === INIT ? ADDED : type_1,
                  from: from,
                  to: to,
                  origin: origin_2,
                });
                saveToLogs(
                  whoAmI,
                  whoAmI + ' client received ' + type_1 + ' request from ' + from,
                  __assign$3({}, membersStatus.membersState),
                  debug
                );
                Object.keys(metadata_1).forEach(function(member) {
                  return (
                    rSubjectMembers &&
                    rSubjectMembers.next({
                      type: type_1,
                      items: metadata_1[member],
                      from: member,
                    })
                  );
                });
              }
            }),
            _a);
          return Object.freeze({
            start: function start() {
              return new Promise(function(resolve, reject) {
                if (!seedAddress) {
                  resolve();
                } else {
                  seed = getFullAddress(seedAddress);

                  var ClusterStart = function ClusterStart() {
                    return {
                      resolveClusterStart: resolve,
                    };
                  };

                  addEventListener(MESSAGE, eventHandlers['globalEventsHandler' + whoAmI].bind(ClusterStart()));
                  retryTimer = setInterval(function() {
                    genericPostMessage({
                      detail: {
                        origin: whoAmI,
                        to: seed,
                      },
                      type: MEMBERSHIP_EVENT_INIT_SERVER,
                    });
                  }, retry.timeout);
                }
              });
            },
            stop: function stop() {
              var _a, _b;

              updateConnectedMember({
                metadata: ((_a = {}), (_a[whoAmI] = itemsToPublish), _a),
                type: REMOVED,
                from: whoAmI,
                to: null,
                origin: whoAmI,
              });
              port1.postMessage(
                getMembershipEvent({
                  metadata: ((_b = {}), (_b[whoAmI] = itemsToPublish), _b),
                  type: REMOVED,
                  from: whoAmI,
                  to: seed,
                  origin: whoAmI,
                })
              );
              removeEventListener(MESSAGE, eventHandlers['globalEventsHandler' + whoAmI]);
              port1.removeEventListener(MESSAGE, eventHandlers['portEventsHandler' + whoAmI]);
              port1.close();
              port2.close();
              saveToLogs(whoAmI, whoAmI + ' close client', __assign$3({}, membersStatus.membersState), debug);
            },
          });
        };

        var createMember = function createMember(address, membersStatus) {
          var whoAmI = getFullAddress(address);
          setLocalAddress(whoAmI);
          /**
           * membership event format
           * @param from
           * @param to
           * @param metadata
           * @param origin
           * @param type
           */

          var getMembershipEvent = function getMembershipEvent(_a) {
            var from = _a.from,
              to = _a.to,
              metadata = _a.metadata,
              origin = _a.origin,
              type = _a.type;
            return {
              detail: {
                metadata: metadata,
                type: type,
                from: from,
                origin: origin,
                to: to,
              },
              type: MEMBERSHIP_EVENT,
            };
          };
          /**
           * loop on all connected members and update them on the change
           * @param type
           * @param metadata
           * @param from
           * @param to
           * @param origin
           */

          var updateConnectedMember = function updateConnectedMember(_a) {
            var type = _a.type,
              metadata = _a.metadata,
              from = _a.from,
              to = _a.to,
              origin = _a.origin;
            var membersPort = membersStatus.membersPort;
            Object.keys(membersPort).forEach(function(nextMember) {
              if (from !== nextMember && whoAmI !== nextMember && origin !== nextMember) {
                var mPort = membersPort[nextMember];
                mPort.postMessage(
                  getMembershipEvent({
                    from: whoAmI,
                    to: nextMember,
                    origin: from,
                    metadata: metadata,
                    type: type,
                  })
                );
              }
            });
          };

          return {
            getMembershipEvent: getMembershipEvent,
            updateConnectedMember: updateConnectedMember,
            whoAmI: whoAmI,
          };
        };

        var __assign$4 = function() {
          __assign$4 =
            Object.assign ||
            function(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];

                for (var p in s) {
                  if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
              }

              return t;
            };

          return __assign$4.apply(this, arguments);
        };

        var __awaiter = function(thisArg, _arguments, P, generator) {
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }

            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }

            function step(result) {
              result.done
                ? resolve(result.value)
                : new P(function(resolve) {
                    resolve(result.value);
                  }).then(fulfilled, rejected);
            }

            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };

        var __generator = function(thisArg, body) {
          var _ = {
              label: 0,
              sent: function sent() {
                if (t[0] & 1) throw t[1];
                return t[1];
              },
              trys: [],
              ops: [],
            },
            f,
            y,
            t,
            g;
          return (
            (g = {
              next: verb(0),
              throw: verb(1),
              return: verb(2),
            }),
            typeof Symbol === 'function' &&
              (g[Symbol.iterator] = function() {
                return this;
              }),
            g
          );

          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }

          function step(op) {
            if (f) throw new TypeError('Generator is already executing.');

            while (_) {
              try {
                if (
                  ((f = 1),
                  y &&
                    (t =
                      op[0] & 2 ? y['return'] : op[0] ? y['throw'] || ((t = y['return']) && t.call(y), 0) : y.next) &&
                    !(t = t.call(y, op[1])).done)
                )
                  return t;
                if (((y = 0), t)) op = [op[0] & 2, t.value];

                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;

                  case 4:
                    _.label++;
                    return {
                      value: op[1],
                      done: false,
                    };

                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;

                  case 7:
                    op = _.ops.pop();

                    _.trys.pop();

                    continue;

                  default:
                    if (!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }

                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                      _.label = op[1];
                      break;
                    }

                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }

                    if (t && _.label < t[2]) {
                      _.label = t[2];

                      _.ops.push(op);

                      break;
                    }

                    if (t[2]) _.ops.pop();

                    _.trys.pop();

                    continue;
                }

                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            }

            if (op[0] & 5) throw op[1];
            return {
              value: op[0] ? op[1] : void 0,
              done: true,
            };
          }
        };

        var _this = undefined;

        var joinCluster = function joinCluster(options) {
          var address = options.address,
            seedAddress = options.seedAddress,
            itemsToPublish = options.itemsToPublish,
            retry = options.retry,
            debug = options.debug;

          var _a = new MessageChannel(),
            port1 = _a.port1,
            port2 = _a.port2;

          var membersStatus = {
            membersPort: {},
            membersState: {},
          };
          var delayedActions = [];
          var isConnected = !seedAddress;
          var rSubjectMembers = new _rxjs.Subject();
          var clientPort;

          var _b = createMember(address, membersStatus),
            updateConnectedMember = _b.updateConnectedMember,
            getMembershipEvent = _b.getMembershipEvent,
            whoAmI = _b.whoAmI;

          var serverPort = server({
            whoAmI: whoAmI,
            membersStatus: membersStatus,
            rSubjectMembers: rSubjectMembers,
            itemsToPublish: itemsToPublish,
            updateConnectedMember: updateConnectedMember,
            getMembershipEvent: getMembershipEvent,
            port1: port1,
            seed: seedAddress ? getFullAddress(seedAddress) : undefined,
            debug: debug,
          });
          serverPort.start();
          clientPort = client({
            whoAmI: whoAmI,
            updateConnectedMember: updateConnectedMember,
            getMembershipEvent: getMembershipEvent,
            membersStatus: membersStatus,
            itemsToPublish: itemsToPublish,
            rSubjectMembers: rSubjectMembers,
            port1: port1,
            port2: port2,
            retry: retry || {
              timeout: 10,
            },
            debug: debug,
            seedAddress: seedAddress,
          });
          clientPort.start().then(function() {
            isConnected = true;

            if (delayedActions.length > 0) {
              delayedActions.forEach(function(action) {
                return action && action();
              });
            }
          });
          return Object.freeze({
            listen$: function listen$() {
              return rSubjectMembers.asObservable();
            },
            getCurrentMembersData: function getCurrentMembersData() {
              return new Promise(function(resolve, reject) {
                var getMemberStateCluster = function getMemberStateCluster() {
                  resolve(__assign$4({}, membersStatus.membersState));
                };

                if (!isConnected) {
                  delayedActions.push(getMemberStateCluster);
                } else {
                  getMemberStateCluster();
                }
              });
            },
            destroy: function destroy() {
              return new Promise(function(resolve, reject) {
                var destroyCluster = function destroyCluster() {
                  return __awaiter(_this, void 0, void 0, function() {
                    var _a, e_1;

                    return __generator(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          _b.trys.push([0, 4, , 5]);

                          return [
                            4,
                            /*yield*/
                            serverPort.stop(),
                          ];

                        case 1:
                          _b.sent();

                          _a = clientPort;
                          if (!_a)
                            return [
                              3,
                              /*break*/
                              3,
                            ];
                          return [
                            4,
                            /*yield*/
                            clientPort.stop(),
                          ];

                        case 2:
                          _a = _b.sent();
                          _b.label = 3;

                        case 3:
                          return [
                            3,
                            /*break*/
                            5,
                          ];

                        case 4:
                          e_1 = _b.sent();
                          saveToLogs(whoAmI, 'unable to destroy ' + whoAmI + ': ' + e_1, {}, debug, 'warn');
                          return [
                            3,
                            /*break*/
                            5,
                          ];

                        case 5:
                          rSubjectMembers.complete();
                          membersStatus.membersPort = {};
                          membersStatus.membersState = {};
                          resolve('');
                          return [
                            2,
                            /*return*/
                          ];
                      }
                    });
                  });
                };

                if (!isConnected) {
                  delayedActions.push(destroyCluster);
                } else {
                  return destroyCluster();
                }
              });
            },
          });
        };

        var INVALID_ITEMS_TO_PUBLISH = 'itemsToPublish are not of type Array';
        var NODEJS_MUST_PROVIDE_CLUSTER_IMPL = 'Must provide cluster when running on nodejs';

        var getAddressCollision = function getAddressCollision(address, seedAddress) {
          return 'address ' + address + ' must be different from the seed Address ' + seedAddress;
        };

        var getDiscoverySuccessfullyDestroyedMessage = function getDiscoverySuccessfullyDestroyedMessage(address) {
          return getFullAddress(address) + ' has been removed';
        };

        var createDiscovery = function createDiscovery(options) {
          var address = options.address,
            itemsToPublish = options.itemsToPublish,
            seedAddress = options.seedAddress,
            debug = options.debug;
          var joinCluster$1 = options.cluster || (!isNodejs() ? joinCluster : undefined);
          var discoveredItemsSubject = new _rxjs.ReplaySubject();

          if (!joinCluster$1) {
            saveToLogs(getFullAddress(address), NODEJS_MUST_PROVIDE_CLUSTER_IMPL, {}, debug, 'warn');
            discoveredItemsSubject.complete();
            return {
              destroy: function destroy() {
                return Promise.resolve(NODEJS_MUST_PROVIDE_CLUSTER_IMPL);
              },
              discoveredItems$: function discoveredItems$() {
                return discoveredItemsSubject.asObservable();
              },
            };
          }

          var membersState = {};
          validateAddress(address, false);

          if (seedAddress) {
            validateAddress(seedAddress, false);
            validateAddressCollision(address, seedAddress);
          }

          assertArray(itemsToPublish, INVALID_ITEMS_TO_PUBLISH);
          var cluster = joinCluster$1({
            address: address,
            seedAddress: seedAddress,
            itemsToPublish: itemsToPublish,
            debug: false,
          });
          var clusterListener = cluster.listen$();
          var subscription;
          return Object.freeze({
            destroy: function destroy() {
              subscription && subscription.unsubscribe();
              discoveredItemsSubject.complete();
              return new Promise(function(resolve, reject) {
                cluster
                  .destroy()
                  .then(function() {
                    return resolve(getDiscoverySuccessfullyDestroyedMessage(address));
                  })
                  ['catch'](function(error) {
                    return reject(error);
                  });
              });
            },
            discoveredItems$: function discoveredItems$() {
              cluster
                .getCurrentMembersData()
                .then(function(currentMembersState) {
                  var members = Object.keys(currentMembersState);
                  members.forEach(function(member) {
                    var memberItem = currentMembersState[member];

                    if (memberItem.length === 0) {
                      discoveredItemsSubject.next({
                        type: 'IDLE',
                        items: [],
                      });
                    } else {
                      if (!membersState[member]) {
                        membersState[member] = true;
                        discoveredItemsSubject.next({
                          type: 'REGISTERED',
                          items: memberItem,
                        });
                      }
                    }
                  });
                })
                ['catch'](function(error) {
                  return discoveredItemsSubject.error(error);
                });
              subscription = clusterListener.subscribe(
                function(clusterEvent) {
                  var type = clusterEvent.type,
                    items = clusterEvent.items,
                    from = clusterEvent.from;

                  if (items.length > 0) {
                    if (type === 'REMOVED' && membersState[from]) {
                      membersState[from] = false;
                      discoveredItemsSubject.next({
                        type: 'UNREGISTERED',
                        items: items,
                      });
                    }

                    if (type !== 'REMOVED' && !membersState[from]) {
                      membersState[from] = true;
                      discoveredItemsSubject.next({
                        type: 'REGISTERED',
                        items: items,
                      });
                    }
                  }
                },
                function(error) {
                  return discoveredItemsSubject.error(error);
                },
                function() {
                  return discoveredItemsSubject.complete();
                }
              );
              return discoveredItemsSubject.asObservable();
            },
          });
        };

        var validateAddressCollision = function validateAddressCollision(address, seedAddress) {
          var fullAddress = getFullAddress(address);
          var fullSeedAddress = getFullAddress(seedAddress);

          if (fullAddress === fullSeedAddress) {
            throw new Error(getAddressCollision(fullAddress, fullSeedAddress));
          }
        };

        var commonjsGlobal =
          typeof globalThis !== 'undefined'
            ? globalThis
            : typeof window !== 'undefined'
            ? window
            : typeof global !== 'undefined'
            ? global
            : typeof self !== 'undefined'
            ? self
            : {};

        function unwrapExports(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }

        function createCommonjsModule(fn, module) {
          return (
            (module = {
              exports: {},
            }),
            fn(module, module.exports),
            module.exports
          );
        }
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         *
         */

        var nullthrows = function nullthrows(x) {
          if (x != null) {
            return x;
          }

          throw new Error('Got unexpected null or undefined');
        };

        var nullthrows_1 = nullthrows;
        var FlowableMapOperator_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _nullthrows2 = _interopRequireDefault(nullthrows_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * An operator that acts like Array.map, applying a given function to
           * all values provided by its `Subscription` and passing the result to its
           * `Subscriber`.
           */

          var FlowableMapOperator =
            /*#__PURE__*/
            (function() {
              function FlowableMapOperator(subscriber, fn) {
                _classCallCheck(this, FlowableMapOperator);

                this._fn = fn;
                this._subscriber = subscriber;
                this._subscription = null;
              }

              _createClass(FlowableMapOperator, [
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    this._subscriber.onComplete();
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(t) {
                    try {
                      this._subscriber.onNext(this._fn(t));
                    } catch (e) {
                      (0, _nullthrows2['default'])(this._subscription).cancel();

                      this._subscriber.onError(e);
                    }
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    this._subscription = subscription;

                    this._subscriber.onSubscribe(subscription);
                  },
                },
              ]);

              return FlowableMapOperator;
            })();

          exports['default'] = FlowableMapOperator;
        });
        unwrapExports(FlowableMapOperator_1);
        var FlowableTakeOperator_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _nullthrows2 = _interopRequireDefault(nullthrows_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * An operator that requests a fixed number of values from its source
           * `Subscription` and forwards them to its `Subscriber`, cancelling the
           * subscription when the requested number of items has been reached.
           */

          var FlowableTakeOperator =
            /*#__PURE__*/
            (function() {
              function FlowableTakeOperator(subscriber, toTake) {
                _classCallCheck(this, FlowableTakeOperator);

                this._subscriber = subscriber;
                this._subscription = null;
                this._toTake = toTake;
              }

              _createClass(FlowableTakeOperator, [
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    this._subscriber.onComplete();
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(t) {
                    try {
                      this._subscriber.onNext(t);

                      if (--this._toTake === 0) {
                        this._cancelAndComplete();
                      }
                    } catch (e) {
                      (0, _nullthrows2['default'])(this._subscription).cancel();

                      this._subscriber.onError(e);
                    }
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    this._subscription = subscription;

                    this._subscriber.onSubscribe(subscription);

                    if (this._toTake <= 0) {
                      this._cancelAndComplete();
                    }
                  },
                },
                {
                  key: '_cancelAndComplete',
                  value: function _cancelAndComplete() {
                    (0, _nullthrows2['default'])(this._subscription).cancel();

                    this._subscriber.onComplete();
                  },
                },
              ]);

              return FlowableTakeOperator;
            })();

          exports['default'] = FlowableTakeOperator;
        });
        unwrapExports(FlowableTakeOperator_1);
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         *
         */

        var validateFormat =
          'development' !== 'production'
            ? function(format) {}
            : function(format) {
                if (format === undefined) {
                  throw new Error('invariant(...): Second argument must be a string.');
                }
              };
        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments to provide
         * information about what broke and what you were expecting.
         *
         * The invariant message will be stripped in production, but the invariant will
         * remain to ensure logic does not differ in production.
         */

        function invariant(condition, format) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          validateFormat(format);

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                'Minified exception occurred; use the non-minified dev environment ' +
                  'for the full error message and additional helpful warnings.'
              );
            } else {
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return String(args[argIndex++]);
                })
              );
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // Skip invariant's own stack frame.

            throw error;
          }
        }

        var invariant_1 = invariant;
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         *
         */

        function makeEmptyFunction(arg) {
          return function() {
            return arg;
          };
        }
        /**
         * This function accepts and discards inputs; it has no side effects. This is
         * primarily useful idiomatically for overridable function endpoints which
         * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
         */

        var emptyFunction = function emptyFunction() {};

        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);

        emptyFunction.thatReturnsThis = function() {
          return this;
        };

        emptyFunction.thatReturnsArgument = function(arg) {
          return arg;
        };

        var emptyFunction_1 = emptyFunction;
        /**
         * Similar to invariant but only logs a warning if the condition is not met.
         * This can be used to log issues in development environments in critical
         * paths. Removing the logging code for production environments will keep the
         * same logic and follow the same code paths.
         */

        function printWarning(format) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message =
            'Warning: ' +
            format.replace(/%s/g, function() {
              return args[argIndex++];
            });

          if (typeof console !== 'undefined') {
            console.error(message);
          }

          try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch (x) {}
        }

        var warning =
          'development' !== 'production'
            ? function(condition, format) {
                if (format === undefined) {
                  throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
                }

                if (!condition) {
                  for (
                    var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 2] = arguments[_key2];
                  }

                  printWarning.apply(void 0, [format].concat(args));
                }
              }
            : emptyFunction_1;
        var warning_1 = warning;
        var Flowable_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _FlowableMapOperator2 = _interopRequireDefault(FlowableMapOperator_1);

          var _FlowableTakeOperator2 = _interopRequireDefault(FlowableTakeOperator_1);

          var _invariant2 = _interopRequireDefault(invariant_1);

          var _warning2 = _interopRequireDefault(warning_1);

          var _emptyFunction2 = _interopRequireDefault(emptyFunction_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * Implements the ReactiveStream `Publisher` interface with Rx-style operators.
           */

          var Flowable =
            /*#__PURE__*/
            (function() {
              _createClass(Flowable, null, [
                {
                  key: 'just',
                  value: function just() {
                    for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                      values[_key3] = arguments[_key3];
                    }

                    return new Flowable(function(subscriber) {
                      var cancelled = false;
                      var i = 0;
                      subscriber.onSubscribe({
                        cancel: function cancel() {
                          cancelled = true;
                        },
                        request: function request(n) {
                          while (!cancelled && n > 0 && i < values.length) {
                            subscriber.onNext(values[i++]);
                            n--;
                          }

                          if (!cancelled && i == values.length) {
                            subscriber.onComplete();
                          }
                        },
                      });
                    });
                  },
                },
                {
                  key: 'error',
                  value: function error(_error2) {
                    return new Flowable(function(subscriber) {
                      subscriber.onSubscribe({
                        cancel: function cancel() {},
                        request: function request() {
                          subscriber.onError(_error2);
                        },
                      });
                    });
                  },
                },
                {
                  key: 'never',
                  value: function never() {
                    return new Flowable(function(subscriber) {
                      subscriber.onSubscribe({
                        cancel: _emptyFunction2['default'],
                        request: _emptyFunction2['default'],
                      });
                    });
                  },
                },
              ]);

              function Flowable(source) {
                var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_SAFE_INTEGER;

                _classCallCheck(this, Flowable);

                this._max = max;
                this._source = source;
              }

              _createClass(Flowable, [
                {
                  key: 'subscribe',
                  value: function subscribe(subscriberOrCallback) {
                    var partialSubscriber;

                    if (typeof subscriberOrCallback === 'function') {
                      partialSubscriber = this._wrapCallback(subscriberOrCallback);
                    } else {
                      partialSubscriber = subscriberOrCallback;
                    }

                    var subscriber = new FlowableSubscriber(partialSubscriber, this._max);

                    this._source(subscriber);
                  },
                },
                {
                  key: 'lift',
                  value: function lift(onSubscribeLift) {
                    var _this2 = this;

                    return new Flowable(function(subscriber) {
                      return _this2._source(onSubscribeLift(subscriber));
                    });
                  },
                },
                {
                  key: 'map',
                  value: function map(fn) {
                    return this.lift(function(subscriber) {
                      return new _FlowableMapOperator2['default'](subscriber, fn);
                    });
                  },
                },
                {
                  key: 'take',
                  value: function take(toTake) {
                    return this.lift(function(subscriber) {
                      return new _FlowableTakeOperator2['default'](subscriber, toTake);
                    });
                  },
                },
                {
                  key: '_wrapCallback',
                  value: function _wrapCallback(callback) {
                    var max = this._max;
                    return {
                      onNext: callback,
                      onSubscribe: function onSubscribe(subscription) {
                        subscription.request(max);
                      },
                    };
                  },
                },
              ]);

              return Flowable;
            })();

          exports['default'] = Flowable;
          /**
           * @private
           */

          var FlowableSubscriber =
            /*#__PURE__*/
            (function() {
              function FlowableSubscriber(subscriber, max) {
                var _this3 = this;

                _classCallCheck(this, FlowableSubscriber);

                this._cancel = function() {
                  if (!_this3._active) {
                    return;
                  }

                  _this3._active = false;

                  if (_this3._subscription) {
                    _this3._subscription.cancel();
                  }
                };

                this._request = function(n) {
                  (0, _invariant2['default'])(
                    Number.isInteger(n) && n >= 1 && n <= _this3._max,
                    'Flowable: Expected request value to be an integer with a ' +
                      'value greater than 0 and less than or equal to %s, got ' +
                      '`%s`.',
                    _this3._max,
                    n
                  );

                  if (!_this3._active) {
                    return;
                  }

                  if (n === _this3._max) {
                    _this3._pending = _this3._max;
                  } else {
                    _this3._pending += n;

                    if (_this3._pending >= _this3._max) {
                      _this3._pending = _this3._max;
                    }
                  }

                  if (_this3._subscription) {
                    _this3._subscription.request(n);
                  }
                };

                this._active = false;
                this._max = max;
                this._pending = 0;
                this._started = false;
                this._subscriber = subscriber || {};
                this._subscription = null;
              }

              _createClass(FlowableSubscriber, [
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    if (!this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onComplete(): %s.',
                        this._started ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;

                    try {
                      if (this._subscriber.onComplete) {
                        this._subscriber.onComplete();
                      }
                    } catch (error) {
                      if (this._subscriber.onError) {
                        this._subscriber.onError(error);
                      }
                    }
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    if (this._started && !this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onError(): %s.',
                        this._active ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;
                    this._subscriber.onError && this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(data) {
                    if (!this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onNext(): %s.',
                        this._active ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    if (this._pending === 0) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onNext(), all request()ed values have been ' + 'published.'
                      );
                      return;
                    }

                    if (this._pending !== this._max) {
                      this._pending--;
                    }

                    try {
                      this._subscriber.onNext && this._subscriber.onNext(data);
                    } catch (error) {
                      if (this._subscription) {
                        this._subscription.cancel();
                      }

                      this.onError(error);
                    }
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    if (this._started) {
                      (0, _warning2['default'])(false, 'Flowable: Invalid call to onSubscribe(): already called.');
                      return;
                    }

                    this._active = true;
                    this._started = true;
                    this._subscription = subscription;

                    try {
                      this._subscriber.onSubscribe &&
                        this._subscriber.onSubscribe({
                          cancel: this._cancel,
                          request: this._request,
                        });
                    } catch (error) {
                      this.onError(error);
                    }
                  },
                },
              ]);

              return FlowableSubscriber;
            })();
        });
        unwrapExports(Flowable_1);
        var Single_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _warning2 = _interopRequireDefault(warning_1);

          var _emptyFunction2 = _interopRequireDefault(emptyFunction_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * Represents a lazy computation that will either produce a value of type T
           * or fail with an error. Calling `subscribe()` starts the
           * computation and returns a subscription object, which has an `unsubscribe()`
           * method that can be called to prevent completion/error callbacks from being
           * invoked and, where supported, to also cancel the computation.
           * Implementations may optionally implement cancellation; if they do not
           * `cancel()` is a no-op.
           *
           * Note: Unlike Promise, callbacks (onComplete/onError) may be invoked
           * synchronously.
           *
           * Example:
           *
           * ```
           * const value = new Single(subscriber => {
           *   const id = setTimeout(
           *     () => subscriber.onComplete('Hello!'),
           *     250
           *   );
           *   // Optional: Call `onSubscribe` with a cancellation callback
           *   subscriber.onSubscribe(() => clearTimeout(id));
           * });
           *
           * // Start the computation. onComplete will be called after the timeout
           * // with 'hello'  unless `cancel()` is called first.
           * value.subscribe({
           *   onComplete: value => console.log(value),
           *   onError: error => console.error(error),
           *   onSubscribe: cancel => ...
           * });
           * ```
           */

          var Single =
            /*#__PURE__*/
            (function() {
              _createClass(Single, null, [
                {
                  key: 'of',
                  value: function of(value) {
                    return new Single(function(subscriber) {
                      subscriber.onSubscribe();
                      subscriber.onComplete(value);
                    });
                  },
                },
                {
                  key: 'error',
                  value: function error(_error3) {
                    return new Single(function(subscriber) {
                      subscriber.onSubscribe();
                      subscriber.onError(_error3);
                    });
                  },
                },
              ]);

              function Single(source) {
                _classCallCheck(this, Single);

                this._source = source;
              }

              _createClass(Single, [
                {
                  key: 'subscribe',
                  value: function subscribe(partialSubscriber) {
                    var subscriber = new FutureSubscriber(partialSubscriber);

                    try {
                      this._source(subscriber);
                    } catch (error) {
                      subscriber.onError(error);
                    }
                  },
                },
                {
                  key: 'flatMap',
                  value: function flatMap(fn) {
                    var _this4 = this;

                    return new Single(function(subscriber) {
                      var currentCancel;

                      var cancel = function cancel() {
                        currentCancel && currentCancel();
                        currentCancel = null;
                      };

                      _this4._source({
                        onComplete: function onComplete(value) {
                          fn(value).subscribe({
                            onComplete: function onComplete(mapValue) {
                              subscriber.onComplete(mapValue);
                            },
                            onError: function onError(error) {
                              return subscriber.onError(error);
                            },
                            onSubscribe: function onSubscribe(_cancel) {
                              currentCancel = _cancel;
                            },
                          });
                        },
                        onError: function onError(error) {
                          return subscriber.onError(error);
                        },
                        onSubscribe: function onSubscribe(_cancel) {
                          currentCancel = _cancel;
                          subscriber.onSubscribe(cancel);
                        },
                      });
                    });
                  },
                  /**
                   * Return a new Single that resolves to the value of this Single applied to
                   * the given mapping function.
                   */
                },
                {
                  key: 'map',
                  value: function map(fn) {
                    var _this5 = this;

                    return new Single(function(subscriber) {
                      return _this5._source({
                        onComplete: function onComplete(value) {
                          return subscriber.onComplete(fn(value));
                        },
                        onError: function onError(error) {
                          return subscriber.onError(error);
                        },
                        onSubscribe: function onSubscribe(cancel) {
                          return subscriber.onSubscribe(cancel);
                        },
                      });
                    });
                  },
                },
                {
                  key: 'then',
                  value: function then(successFn, errorFn) {
                    this.subscribe({
                      onComplete: successFn || _emptyFunction2['default'],
                      onError: errorFn || _emptyFunction2['default'],
                    });
                  },
                },
              ]);

              return Single;
            })();

          exports['default'] = Single;
          /**
           * @private
           */

          var FutureSubscriber =
            /*#__PURE__*/
            (function() {
              function FutureSubscriber(subscriber) {
                _classCallCheck(this, FutureSubscriber);

                this._active = false;
                this._started = false;
                this._subscriber = subscriber || {};
              }

              _createClass(FutureSubscriber, [
                {
                  key: 'onComplete',
                  value: function onComplete(value) {
                    if (!this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Single: Invalid call to onComplete(): %s.',
                        this._started ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;

                    try {
                      if (this._subscriber.onComplete) {
                        this._subscriber.onComplete(value);
                      }
                    } catch (error) {
                      if (this._subscriber.onError) {
                        this._subscriber.onError(error);
                      }
                    }
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    if (this._started && !this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Single: Invalid call to onError(): %s.',
                        this._active ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;
                    this._subscriber.onError && this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(cancel) {
                    var _this6 = this;

                    if (this._started) {
                      (0, _warning2['default'])(false, 'Single: Invalid call to onSubscribe(): already called.');
                      return;
                    }

                    this._active = true;
                    this._started = true;

                    try {
                      this._subscriber.onSubscribe &&
                        this._subscriber.onSubscribe(function() {
                          if (!_this6._active) {
                            return;
                          }

                          _this6._active = false;
                          cancel && cancel();
                        });
                    } catch (error) {
                      this.onError(error);
                    }
                  },
                },
              ]);

              return FutureSubscriber;
            })();
        });
        unwrapExports(Single_1);
        var FlowableProcessor_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _warning2 = _interopRequireDefault(warning_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var FlowableProcessor =
            /*#__PURE__*/
            (function() {
              function FlowableProcessor(source, fn) {
                _classCallCheck(this, FlowableProcessor);

                this._source = source;
                this._transformer = fn;
                this._done = false;
                this._mappers = []; //mappers for map function
              }

              _createClass(FlowableProcessor, [
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    this._subscription = subscription;
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(t) {
                    if (!this._sink) {
                      (0, _warning2['default'])('Warning, premature onNext for processor, dropping value');
                      return;
                    }

                    var val = t;

                    if (this._transformer) {
                      val = this._transformer(t);
                    }

                    var finalVal = this._mappers.reduce(function(interimVal, mapper) {
                      return mapper(interimVal);
                    }, val);

                    this._sink.onNext(finalVal);
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    this._error = error;

                    if (!this._sink) {
                      (0, _warning2['default'])('Warning, premature onError for processor, marking complete/errored');
                    } else {
                      this._sink.onError(error);
                    }
                  },
                },
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    this._done = true;

                    if (!this._sink) {
                      (0, _warning2['default'])('Warning, premature onError for processor, marking complete');
                    } else {
                      this._sink.onComplete();
                    }
                  },
                },
                {
                  key: 'subscribe',
                  value: function subscribe(subscriber) {
                    if (this._source.subscribe) {
                      this._source.subscribe(this);
                    }

                    this._sink = subscriber;

                    this._sink.onSubscribe(this);

                    if (this._error) {
                      this._sink.onError(this._error);
                    } else if (this._done) {
                      this._sink.onComplete();
                    }
                  },
                },
                {
                  key: 'map',
                  value: function map(fn) {
                    this._mappers.push(fn);

                    return this;
                  },
                },
                {
                  key: 'request',
                  value: function request(n) {
                    this._subscription && this._subscription.request(n);
                  },
                },
                {
                  key: 'cancel',
                  value: function cancel() {
                    this._subscription && this._subscription.cancel();
                  },
                },
              ]);

              return FlowableProcessor;
            })();

          exports['default'] = FlowableProcessor;
        });
        unwrapExports(FlowableProcessor_1);
        var FlowableTimer = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.every = every;

          var _Flowable2 = _interopRequireDefault(Flowable_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * Returns a Publisher that provides the current time (Date.now()) every `ms`
           * milliseconds.
           *
           * The timer is established on the first call to `request`: on each
           * interval a value is published if there are outstanding requests,
           * otherwise nothing occurs for that interval. This approach ensures
           * that the interval between `onNext` calls is as regular as possible
           * and means that overlapping `request` calls (ie calling again before
           * the previous values have been vended) behaves consistently.
           */

          function every(ms) {
            return new _Flowable2['default'](function(subscriber) {
              var intervalId = null;
              var pending = 0;
              subscriber.onSubscribe({
                cancel: function cancel() {
                  if (intervalId != null) {
                    clearInterval(intervalId);
                    intervalId = null;
                  }
                },
                request: function request(n) {
                  if (n < Number.MAX_SAFE_INTEGER) {
                    pending += n;
                  } else {
                    pending = Number.MAX_SAFE_INTEGER;
                  }

                  if (intervalId != null) {
                    return;
                  }

                  intervalId = setInterval(function() {
                    if (pending > 0) {
                      if (pending !== Number.MAX_SAFE_INTEGER) {
                        pending--;
                      }

                      subscriber.onNext(Date.now());
                    }
                  }, ms);
                },
              });
            });
          }
        });
        unwrapExports(FlowableTimer);
        var FlowableTimer_1 = FlowableTimer.every;
        var build = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.every = exports.Single = exports.FlowableProcessor = exports.Flowable = undefined;

          var _Flowable2 = _interopRequireDefault(Flowable_1);

          var _Single2 = _interopRequireDefault(Single_1);

          var _FlowableProcessor2 = _interopRequireDefault(FlowableProcessor_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * The public API of the `flowable` package.
           */

          exports.Flowable = _Flowable2['default'];
          exports.FlowableProcessor = _FlowableProcessor2['default'];
          exports.Single = _Single2['default'];
          exports.every = FlowableTimer.every;
        });
        unwrapExports(build);
        var build_1 = build.every;
        var build_2 = build.Single;
        var build_3 = build.FlowableProcessor;
        var build_4 = build.Flowable;
        var ReactiveSocketTypes = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          /** Copyright (c) Facebook, Inc. and its affiliates.
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           *
           *
           */

          /**
           * Represents a network connection with input/output used by a ReactiveSocket to
           * send/receive data.
           */

          var CONNECTION_STATUS = exports.CONNECTION_STATUS = {
    CLOSED: Object.freeze({
      kind: 'CLOSED'
    }),
    CONNECTED: Object.freeze({
      kind: 'CONNECTED'
    }),
    CONNECTING: Object.freeze({
      kind: 'CONNECTING'
    }),
    NOT_CONNECTED: Object.freeze({
      kind: 'NOT_CONNECTED'
    })
  };
          /**
           * Describes the connection status of a ReactiveSocket/DuplexConnection.
           * - NOT_CONNECTED: no connection established or pending.
           * - CONNECTING: when `connect()` has been called but a connection is not yet
           *   established.
           * - CONNECTED: when a connection is established.
           * - CLOSED: when the connection has been explicitly closed via `close()`.
           * - ERROR: when the connection has been closed for any other reason.
           */

          /**
   * A contract providing different interaction models per the [ReactiveSocket protocol]
   (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
   */

          /**
           * A single unit of data exchanged between the peers of a `ReactiveSocket`.
           */

          /**
           * A type that can be written to a buffer.
           */
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
        });
        unwrapExports(ReactiveSocketTypes);
        var ReactiveSocketTypes_1 = ReactiveSocketTypes.CONNECTION_STATUS;
        var ReactiveStreamTypes =
          /*#__PURE__*/
          Object.freeze({});
        var build$1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          Object.keys(ReactiveSocketTypes).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return ReactiveSocketTypes[key];
              },
            });
          });
          Object.keys(ReactiveStreamTypes).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return ReactiveStreamTypes[key];
              },
            });
          });
        });
        unwrapExports(build$1);
        var build_1$1 = build$1.CONNECTION_STATUS;
        /**
         *
         *
         */

        var newMessage = function newMessage(_ref) {
          var type = _ref.type,
            payload = _ref.payload;
          return {
            cid: Date.now() + '-' + Math.random(),
            payload: payload,
            type: type,
          };
        }; // $FlowFixMe

        var getMessageData = function getMessageData(_ref2) {
          var data = _ref2.data;
          return data || null;
        };

        var updateListeners = function updateListeners(_ref3) {
          var _ref3$listeners = _ref3.listeners,
            listeners = _ref3$listeners === void 0 ? [] : _ref3$listeners,
            type = _ref3.type,
            func = _ref3.func,
            scope = _ref3.scope;
          return type && func
            ? [].concat(_toConsumableArray(listeners), [
                {
                  func: func,
                  type: type,
                  scope: scope,
                },
              ])
            : _toConsumableArray(listeners);
        };

        var localAddress$1 = [];

        var genericPostMessage$1 = function genericPostMessage$1(data, transfer) {
          try {
            // $FlowFixMe
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              if (localAddress$1.indexOf(data.detail.address) > -1) {
                var event = new MessageEvent('message', {
                  data: data,
                  ports: transfer ? transfer : undefined,
                });
                dispatchEvent(event);
              } else {
                // $FlowFixMe
                postMessage(data, transfer ? transfer : undefined);
              }
            } else {
              // $FlowFixMe
              postMessage(data, '*', transfer ? transfer : undefined);
            }
          } catch (e) {
            console.error('Unable to post message ', e);
          }
        };
        /**
         *
         */

        /**
         * EventsClient implements IChannelClient
         *
         * initiate connection with a server.
         *
         */

        var listeners = [];

        var EventsClient =
          /*#__PURE__*/
          (function() {
            function EventsClient(option) {
              _classCallCheck(this, EventsClient);

              this.eventType = option.eventType || 'RsocketEvents';
              this.confirmConnectionOpenCallback = option.confirmConnectionOpenCallback;
              this.debug = option.debug || false;
            }

            _createClass(EventsClient, [
              {
                key: 'connect',
                value: function connect(address) {
                  var _this7 = this;

                  var channel = new MessageChannel();

                  if (!channel) {
                    throw new Error('MessageChannel not supported');
                  } // send open message to the server with a port message

                  pingServer(this.eventType, channel, address);
                  listeners = updateListeners({
                    func: initConnection,
                    type: 'message',
                    scope: 'port',
                  }); // start to listen to the port

                  startListen(channel, this.confirmConnectionOpenCallback);

                  if (channel && channel.port1) {
                    var port1 = channel.port1;
                    return Object.freeze({
                      disconnect: function disconnect() {
                        port1.postMessage(
                          newMessage({
                            payload: null,
                            type: 'close',
                          })
                        );
                        Array.isArray(listeners) &&
                          listeners.forEach(function(_ref4) {
                            var type = _ref4.type,
                              func = _ref4.func,
                              scope = _ref4.scope;
                            return scope === 'port'
                              ? port1 && port1.removeEventListener(type, func) // $FlowFixMe
                              : removeEventListener(type, func);
                          });
                      },
                      receive: function receive(cb) {
                        listeners = updateListeners({
                          func: responseMessage,
                          listeners: listeners,
                          type: 'message',
                          scope: 'port',
                        });
                        port1.addEventListener('message', function(eventMsg) {
                          return responseMessage(eventMsg, _this7.debug, cb);
                        });
                      },
                      send: function send(msg) {
                        if (_this7.debug) {
                          console.log('Client send request with payload: '.concat(JSON.stringify(msg)));
                        }

                        port1.postMessage(
                          newMessage({
                            payload: msg,
                            type: 'request',
                          })
                        );
                      },
                    });
                  } else {
                    throw new Error('Unable to use port message');
                  }
                },
              },
            ]);

            return EventsClient;
          })();

        var pingServer = function pingServer(type, channel, address) {
          genericPostMessage$1(
            {
              detail: {
                address: address,
                type: 'rsocket-events-open-connection',
              },
              type: type,
            },
            [channel.port2]
          );
        };

        var startListen = function startListen(channel, confirmConnectionOpenCallback) {
          if (channel && channel.port1) {
            var port1 = channel.port1;
            port1.addEventListener('message', function(eventMsg) {
              return initConnection(eventMsg, channel, confirmConnectionOpenCallback, port1);
            });
            port1.start();
          }
        };

        var initConnection = function initConnection(eventMsg, channel, confirmConnectionOpenCallback, port1) {
          var _getMessageData = getMessageData(eventMsg),
            type = _getMessageData.type;

          switch (type) {
            case 'connect': {
              typeof confirmConnectionOpenCallback === 'function' && confirmConnectionOpenCallback();
              break;
            }

            case 'disconnect': {
              if (channel) {
                port1 && port1.close();
                Array.isArray(listeners) &&
                  listeners.forEach(function(_ref5) {
                    var type = _ref5.type,
                      func = _ref5.func,
                      scope = _ref5.scope;
                    return scope === 'port' && port1 && port1.removeEventListener(type, func);
                  });
                port1 = null;
                channel = null;
              }

              break;
            }
          }
        };

        var responseMessage = function responseMessage(eventMsg, debug, cb) {
          var _getMessageData2 = getMessageData(eventMsg),
            type = _getMessageData2.type,
            payload = _getMessageData2.payload;

          if (type === 'response') {
            if (debug) {
              console.log('Client receive response with payload: '.concat(payload));
            }

            cb(payload);
          }
        };
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var validateFormat$1 = function validateFormat(format) {};

        if ('development' !== 'production') {
          validateFormat$1 = function validateFormat(format) {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          };
        }

        function invariant$1(condition, format, a, b, c, d, e, f) {
          validateFormat$1(format);

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                'Minified exception occurred; use the non-minified dev environment ' +
                  'for the full error message and additional helpful warnings.'
              );
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                })
              );
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame

            throw error;
          }
        }

        var invariant_1$1 = invariant$1;
        /**
         * written with <3 by scaleCube-js maintainers
         *
         * RSocketEventsClient Transport provider for event base messages
         * browser <--> browser
         *
         *
         */

        /**
         * A WebSocket transport client for use in browser environments.
         */

        var RSocketEventsClient =
          /*#__PURE__*/
          (function() {
            function RSocketEventsClient(_ref6) {
              var eventClient = _ref6.eventClient,
                address = _ref6.address,
                _ref6$debug = _ref6.debug,
                debug = _ref6$debug === void 0 ? false : _ref6$debug;

              _classCallCheck(this, RSocketEventsClient);

              this._receivers = new Set();
              this._eventsClient =
                eventClient ||
                new EventsClient({
                  confirmConnectionOpenCallback: this.confirmConnectionOpenCallback.bind(this),
                  eventType: 'RsocketEvents',
                  debug: debug,
                });
              this._address = address;
              this._statusSubscribers = new Set();
              this._status = build_1$1.NOT_CONNECTED;
              this.debug = debug;
            }

            _createClass(RSocketEventsClient, [
              {
                key: 'confirmConnectionOpenCallback',
                value: function confirmConnectionOpenCallback() {
                  this._setConnectionStatus(build_1$1.CONNECTED);
                },
                /**
                 * Send a single frame on the connection.
                 */
              },
              {
                key: 'sendOne',
                value: function sendOne(frame) {
                  if (!this.connection) {
                    return;
                  }

                  this.connection.send(frame);
                },
                /**
                 * Send all the `input` frames on this connection.
                 *
                 * Notes:
                 * - Implementations must not cancel the subscription.
                 * - Implementations must signal any errors by calling `onError` on the
                 *   `receive()` Publisher.
                 */
              },
              {
                key: 'send',
                value: function send(input) {
                  var _this8 = this;

                  if (!this.connection) {
                    return;
                  }

                  input.subscribe(function(frame) {
                    if (_this8.debug) {
                      console.log('RSocketEventsClient send frame: ', frame);
                    }

                    _this8.connection.send(frame);
                  });
                },
                /**
                 * Returns a stream of all `Frame`s received on this connection.
                 *
                 * Notes:
                 * - Implementations must call `onComplete` if the underlying connection is
                 *   closed by the peer or by calling `close()`.
                 * - Implementations must call `onError` if there are any errors
                 *   sending/receiving frames.
                 * - Implemenations may optionally support multi-cast receivers. Those that do
                 *   not should throw if `receive` is called more than once.
                 */
              },
              {
                key: 'receive',
                value: function receive() {
                  var _this9 = this;

                  return new build_4(function(subject) {
                    subject.onSubscribe({
                      cancel: function cancel() {
                        _this9._receivers['delete'](subject);
                      },
                      request: function request() {
                        _this9._receivers.add(subject);
                      },
                    });
                  });
                },
                /**
                 * Close the underlying connection, emitting `onComplete` on the receive()
                 * Publisher.
                 */
              },
              {
                key: 'close',
                value: function close(error) {
                  if (this._status.kind === 'CLOSED' || this._status.kind === 'ERROR') {
                    // already closed
                    return;
                  }

                  var status = error
                    ? {
                        error: error,
                        kind: 'ERROR',
                      }
                    : build_1$1.CLOSED;

                  this._setConnectionStatus(status);

                  this._receivers.forEach(function(subscriber) {
                    if (error) {
                      subscriber.onError(error);
                    } else {
                      subscriber.onComplete();
                    }
                  });

                  this._receivers.clear();

                  this.connection && typeof this.connection.disconnect === 'function' && this.connection.disconnect();
                  this._eventsClient = null;
                },
                /**
                 * Open the underlying connection. Throws if the connection is already in
                 * the CLOSED or ERROR state.
                 */
              },
              {
                key: 'connect',
                value: function connect() {
                  var _this10 = this;

                  invariant_1$1(
                    this._status.kind === 'NOT_CONNECTED',
                    'RSocketEventsClient: Cannot connect(), a connection is already ' + 'established.'
                  );

                  this._setConnectionStatus(build_1$1.CONNECTING);

                  if (this._eventsClient) {
                    var _eventsClient = this._eventsClient;

                    this._setConnectionStatus(build_1$1.CONNECTING);

                    this.connection = _eventsClient.connect(this._address);
                    this.connection.receive(function(frame) {
                      if (_this10.debug) {
                        console.log('RSocketEventsClient received frame: ', frame);
                      }

                      frame &&
                        _this10._receivers.forEach(function(subscriber) {
                          return subscriber.onNext(frame);
                        });
                    });
                  } else {
                    console.log('connection is closed');
                  }
                },
                /**
                 * Returns a Flowable that immediately publishes the current connection
                 * status and thereafter updates as it changes. Once a connection is in
                 * the CLOSED or ERROR state, it may not be connected again.
                 * Implementations must publish values per the comments on ConnectionStatus.
                 */
              },
              {
                key: 'connectionStatus',
                value: function connectionStatus() {
                  var _this11 = this;

                  return new build_4(function(subscriber) {
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        _this11._statusSubscribers['delete'](subscriber);
                      },
                      request: function request() {
                        _this11._statusSubscribers.add(subscriber);

                        subscriber.onNext(_this11._status);
                      },
                    });
                  });
                },
              },
              {
                key: '_setConnectionStatus',
                value: function _setConnectionStatus(status) {
                  this._status = status;

                  this._statusSubscribers.forEach(function(subscriber) {
                    return subscriber.onNext(status);
                  });
                },
              },
            ]);

            return RSocketEventsClient;
          })();

        var clientFactory = function clientFactory(options) {
          var address = options.address,
            factoryOptions = options.factoryOptions;
          validateAddress(address);
          var protocol = address.protocol;

          switch (protocol.toLowerCase()) {
            case 'pm':
              return new RSocketEventsClient({
                address: getFullAddress(address),
              });

            default:
              throw Error(NOT_VALID_PROTOCOL);
          }
        };
        /**
         *
         *
         */

        var newMessage$1 = function newMessage$1(_ref7) {
          var type = _ref7.type,
            payload = _ref7.payload;
          return {
            cid: Date.now() + '-' + Math.random(),
            payload: payload,
            type: type,
          };
        }; // $FlowFixMe

        var getMessageData$1 = function getMessageData$1(_ref8) {
          var data = _ref8.data;
          return data || null;
        };

        var updateListeners$1 = function updateListeners$1(_ref9) {
          var _ref9$listeners = _ref9.listeners,
            listeners = _ref9$listeners === void 0 ? [] : _ref9$listeners,
            type = _ref9.type,
            func = _ref9.func,
            scope = _ref9.scope;
          return type && func
            ? [].concat(_toConsumableArray(listeners), [
                {
                  func: func,
                  type: type,
                  scope: scope,
                },
              ])
            : _toConsumableArray(listeners);
        };

        var localAddress$2 = [];

        var genericPostMessage$2 = function genericPostMessage$2(data, transfer) {
          try {
            // $FlowFixMe
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              if (localAddress$2.indexOf(data.detail.address) > -1) {
                var event = new MessageEvent('message', {
                  data: data,
                  ports: transfer ? transfer : undefined,
                });
                dispatchEvent(event);
              } else {
                // $FlowFixMe
                postMessage(data, transfer ? transfer : undefined);
              }
            } else {
              // $FlowFixMe
              postMessage(data, '*', transfer ? transfer : undefined);
            }
          } catch (e) {
            console.error('Unable to post message ', e);
          }
        };
        /**
         *
         */

        /**
         * EventsClient implements IChannelClient
         *
         * initiate connection with a server.
         *
         */

        var listeners$1 = [];

        var EventsClient$1 =
          /*#__PURE__*/
          (function() {
            function EventsClient$1(option) {
              _classCallCheck(this, EventsClient$1);

              this.eventType = option.eventType || 'RsocketEvents';
              this.confirmConnectionOpenCallback = option.confirmConnectionOpenCallback;
              this.debug = option.debug || false;
            }

            _createClass(EventsClient$1, [
              {
                key: 'connect',
                value: function connect(address) {
                  var _this12 = this;

                  var channel = new MessageChannel();

                  if (!channel) {
                    throw new Error('MessageChannel not supported');
                  } // send open message to the server with a port message

                  pingServer$1(this.eventType, channel, address);
                  listeners$1 = updateListeners$1({
                    func: initConnection$1,
                    type: 'message',
                    scope: 'port',
                  }); // start to listen to the port

                  startListen$1(channel, this.confirmConnectionOpenCallback);

                  if (channel && channel.port1) {
                    var port1 = channel.port1;
                    return Object.freeze({
                      disconnect: function disconnect() {
                        port1.postMessage(
                          newMessage$1({
                            payload: null,
                            type: 'close',
                          })
                        );
                        Array.isArray(listeners$1) &&
                          listeners$1.forEach(function(_ref10) {
                            var type = _ref10.type,
                              func = _ref10.func,
                              scope = _ref10.scope;
                            return scope === 'port'
                              ? port1 && port1.removeEventListener(type, func) // $FlowFixMe
                              : removeEventListener(type, func);
                          });
                      },
                      receive: function receive(cb) {
                        listeners$1 = updateListeners$1({
                          func: responseMessage$1,
                          listeners: listeners$1,
                          type: 'message',
                          scope: 'port',
                        });
                        port1.addEventListener('message', function(eventMsg) {
                          return responseMessage$1(eventMsg, _this12.debug, cb);
                        });
                      },
                      send: function send(msg) {
                        if (_this12.debug) {
                          console.log('Client send request with payload: '.concat(JSON.stringify(msg)));
                        }

                        port1.postMessage(
                          newMessage$1({
                            payload: msg,
                            type: 'request',
                          })
                        );
                      },
                    });
                  } else {
                    throw new Error('Unable to use port message');
                  }
                },
              },
            ]);

            return EventsClient$1;
          })();

        var pingServer$1 = function pingServer$1(type, channel, address) {
          genericPostMessage$2(
            {
              detail: {
                address: address,
                type: 'rsocket-events-open-connection',
              },
              type: type,
            },
            [channel.port2]
          );
        };

        var startListen$1 = function startListen$1(channel, confirmConnectionOpenCallback) {
          if (channel && channel.port1) {
            var port1 = channel.port1;
            port1.addEventListener('message', function(eventMsg) {
              return initConnection$1(eventMsg, channel, confirmConnectionOpenCallback, port1);
            });
            port1.start();
          }
        };

        var initConnection$1 = function initConnection$1(eventMsg, channel, confirmConnectionOpenCallback, port1) {
          var _getMessageData$ = getMessageData$1(eventMsg),
            type = _getMessageData$.type;

          switch (type) {
            case 'connect': {
              typeof confirmConnectionOpenCallback === 'function' && confirmConnectionOpenCallback();
              break;
            }

            case 'disconnect': {
              if (channel) {
                port1 && port1.close();
                Array.isArray(listeners$1) &&
                  listeners$1.forEach(function(_ref11) {
                    var type = _ref11.type,
                      func = _ref11.func,
                      scope = _ref11.scope;
                    return scope === 'port' && port1 && port1.removeEventListener(type, func);
                  });
                port1 = null;
                channel = null;
              }

              break;
            }
          }
        };

        var responseMessage$1 = function responseMessage$1(eventMsg, debug, cb) {
          var _getMessageData$2 = getMessageData$1(eventMsg),
            type = _getMessageData$2.type,
            payload = _getMessageData$2.payload;

          if (type === 'response') {
            if (debug) {
              console.log('Client receive response with payload: '.concat(payload));
            }

            cb(payload);
          }
        };
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var validateFormat$2 = function validateFormat(format) {};

        if ('development' !== 'production') {
          validateFormat$2 = function validateFormat(format) {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          };
        }

        function invariant$2(condition, format, a, b, c, d, e, f) {
          validateFormat$2(format);

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                'Minified exception occurred; use the non-minified dev environment ' +
                  'for the full error message and additional helpful warnings.'
              );
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                })
              );
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame

            throw error;
          }
        }

        var invariant_1$2 = invariant$2;
        /**
         * written with <3 by scaleCube-js maintainers
         *
         * RSocketEventsClient Transport provider for event base messages
         * browser <--> browser
         *
         *
         */

        /**
         * A WebSocket transport client for use in browser environments.
         */

        var RSocketEventsClient$1 =
          /*#__PURE__*/
          (function() {
            function RSocketEventsClient$1(_ref12) {
              var eventClient = _ref12.eventClient,
                address = _ref12.address,
                _ref12$debug = _ref12.debug,
                debug = _ref12$debug === void 0 ? false : _ref12$debug;

              _classCallCheck(this, RSocketEventsClient$1);

              this._receivers = new Set();
              this._eventsClient =
                eventClient ||
                new EventsClient$1({
                  confirmConnectionOpenCallback: this.confirmConnectionOpenCallback.bind(this),
                  eventType: 'RsocketEvents',
                  debug: debug,
                });
              this._address = address;
              this._statusSubscribers = new Set();
              this._status = build_1$1.NOT_CONNECTED;
              this.debug = debug;
            }

            _createClass(RSocketEventsClient$1, [
              {
                key: 'confirmConnectionOpenCallback',
                value: function confirmConnectionOpenCallback() {
                  this._setConnectionStatus(build_1$1.CONNECTED);
                },
                /**
                 * Send a single frame on the connection.
                 */
              },
              {
                key: 'sendOne',
                value: function sendOne(frame) {
                  if (!this.connection) {
                    return;
                  }

                  this.connection.send(frame);
                },
                /**
                 * Send all the `input` frames on this connection.
                 *
                 * Notes:
                 * - Implementations must not cancel the subscription.
                 * - Implementations must signal any errors by calling `onError` on the
                 *   `receive()` Publisher.
                 */
              },
              {
                key: 'send',
                value: function send(input) {
                  var _this13 = this;

                  if (!this.connection) {
                    return;
                  }

                  input.subscribe(function(frame) {
                    if (_this13.debug) {
                      console.log('RSocketEventsClient send frame: ', frame);
                    }

                    _this13.connection.send(frame);
                  });
                },
                /**
                 * Returns a stream of all `Frame`s received on this connection.
                 *
                 * Notes:
                 * - Implementations must call `onComplete` if the underlying connection is
                 *   closed by the peer or by calling `close()`.
                 * - Implementations must call `onError` if there are any errors
                 *   sending/receiving frames.
                 * - Implemenations may optionally support multi-cast receivers. Those that do
                 *   not should throw if `receive` is called more than once.
                 */
              },
              {
                key: 'receive',
                value: function receive() {
                  var _this14 = this;

                  return new build_4(function(subject) {
                    subject.onSubscribe({
                      cancel: function cancel() {
                        _this14._receivers['delete'](subject);
                      },
                      request: function request() {
                        _this14._receivers.add(subject);
                      },
                    });
                  });
                },
                /**
                 * Close the underlying connection, emitting `onComplete` on the receive()
                 * Publisher.
                 */
              },
              {
                key: 'close',
                value: function close(error) {
                  if (this._status.kind === 'CLOSED' || this._status.kind === 'ERROR') {
                    // already closed
                    return;
                  }

                  var status = error
                    ? {
                        error: error,
                        kind: 'ERROR',
                      }
                    : build_1$1.CLOSED;

                  this._setConnectionStatus(status);

                  this._receivers.forEach(function(subscriber) {
                    if (error) {
                      subscriber.onError(error);
                    } else {
                      subscriber.onComplete();
                    }
                  });

                  this._receivers.clear();

                  this.connection && typeof this.connection.disconnect === 'function' && this.connection.disconnect();
                  this._eventsClient = null;
                },
                /**
                 * Open the underlying connection. Throws if the connection is already in
                 * the CLOSED or ERROR state.
                 */
              },
              {
                key: 'connect',
                value: function connect() {
                  var _this15 = this;

                  invariant_1$2(
                    this._status.kind === 'NOT_CONNECTED',
                    'RSocketEventsClient: Cannot connect(), a connection is already ' + 'established.'
                  );

                  this._setConnectionStatus(build_1$1.CONNECTING);

                  if (this._eventsClient) {
                    var _eventsClient = this._eventsClient;

                    this._setConnectionStatus(build_1$1.CONNECTING);

                    this.connection = _eventsClient.connect(this._address);
                    this.connection.receive(function(frame) {
                      if (_this15.debug) {
                        console.log('RSocketEventsClient received frame: ', frame);
                      }

                      frame &&
                        _this15._receivers.forEach(function(subscriber) {
                          return subscriber.onNext(frame);
                        });
                    });
                  } else {
                    console.log('connection is closed');
                  }
                },
                /**
                 * Returns a Flowable that immediately publishes the current connection
                 * status and thereafter updates as it changes. Once a connection is in
                 * the CLOSED or ERROR state, it may not be connected again.
                 * Implementations must publish values per the comments on ConnectionStatus.
                 */
              },
              {
                key: 'connectionStatus',
                value: function connectionStatus() {
                  var _this16 = this;

                  return new build_4(function(subscriber) {
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        _this16._statusSubscribers['delete'](subscriber);
                      },
                      request: function request() {
                        _this16._statusSubscribers.add(subscriber);

                        subscriber.onNext(_this16._status);
                      },
                    });
                  });
                },
              },
              {
                key: '_setConnectionStatus',
                value: function _setConnectionStatus(status) {
                  this._status = status;

                  this._statusSubscribers.forEach(function(subscriber) {
                    return subscriber.onNext(status);
                  });
                },
              },
            ]);

            return RSocketEventsClient$1;
          })();
        /**
         *
         *
         */

        var newMessage$1$1 = function newMessage$1$1(_ref13) {
          var type = _ref13.type,
            payload = _ref13.payload;
          return {
            cid: Date.now() + '-' + Math.random(),
            payload: payload,
            type: type,
          };
        }; // $FlowFixMe

        var getMessageData$1$1 = function getMessageData$1$1(_ref14) {
          var data = _ref14.data;
          return data || null;
        };

        var updateListeners$1$1 = function updateListeners$1$1(_ref15) {
          var _ref15$listeners = _ref15.listeners,
            listeners = _ref15$listeners === void 0 ? [] : _ref15$listeners,
            type = _ref15.type,
            func = _ref15.func,
            scope = _ref15.scope;
          return type && func
            ? [].concat(_toConsumableArray(listeners), [
                {
                  func: func,
                  type: type,
                  scope: scope,
                },
              ])
            : _toConsumableArray(listeners);
        };

        var localAddress$1$1 = [];

        var setLocalAddress$1 = function setLocalAddress$1(address) {
          localAddress$1$1 = [].concat(_toConsumableArray(localAddress$1$1), [address]);
          return localAddress$1$1;
        };
        /**
         *
         */

        var listeners$1$1 = [];
        /**
         * EventsServer
         * Waiting for client to initiate connection.
         *
         * successful connection message contain a port message.
         * server will use the port message to return confirmation for the connection.
         */

        var EventsServer =
          /*#__PURE__*/
          (function() {
            function EventsServer(option) {
              var _this17 = this;

              _classCallCheck(this, EventsServer);

              this.eventType = option.eventType || 'RsocketEvents';
              this.address = option.address;
              this.debug = option.debug || false;

              this._getEventData =
                option.processEvent ||
                function(data) {
                  return data.type === _this17.eventType ? data.detail : null;
                };

              setLocalAddress$1(this.address);
              listeners$1$1 = updateListeners$1$1({
                func: this._handler,
                listeners: listeners$1$1,
                type: this.eventType,
                scope: 'global',
              }); // $FlowFixMe

              typeof addEventListener === 'function' && addEventListener('message', this._handler.bind(this)); // eslint-disable-line
            }

            _createClass(EventsServer, [
              {
                key: '_handler',
                value: function _handler(ev) {
                  var _this18 = this;

                  var event = this._getEventData(ev.data);

                  if (!event || event.address !== this.address || event.type !== 'rsocket-events-open-connection') {
                    return;
                  }

                  if (ev && Array.isArray(ev.ports)) {
                    this._clientChannelPort = ev.ports[0];

                    this._clientChannelPort.postMessage({
                      type: 'connect',
                    });

                    listeners$1$1 = updateListeners$1$1({
                      func: connectionHandler,
                      listeners: listeners$1$1,
                      type: 'message',
                      scope: 'port',
                    });
                    this._clientChannelPort &&
                      this._clientChannelPort.addEventListener('message', function(ev) {
                        return connectionHandler(ev, _this18.onStop.bind(_this18));
                      });
                    this._clientChannelPort && this._clientChannelPort.start();

                    this._onConnection(
                      new ServerChannel({
                        clientChannelPort: this._clientChannelPort || new MessagePort(),
                        debug: this.debug,
                      })
                    );
                  }
                },
              },
              {
                key: 'onConnect',
                value: function onConnect(cb) {
                  this._onConnection = cb;
                },
              },
              {
                key: 'onStop',
                value: function onStop() {
                  this._clientChannelPort &&
                    this._clientChannelPort.postMessage({
                      type: 'disconnect',
                    });
                  this._clientChannelPort && this._clientChannelPort.close();
                },
              },
            ]);

            return EventsServer;
          })();
        /**
         * ServerChannel implements IChannelServer
         *
         * server connection implementation
         */

        var ServerChannel =
          /*#__PURE__*/
          (function() {
            function ServerChannel(_ref16) {
              var clientChannelPort = _ref16.clientChannelPort,
                debug = _ref16.debug;

              _classCallCheck(this, ServerChannel);

              this.clientChannelPort = clientChannelPort;
              this.debug = debug || false;
            }

            _createClass(ServerChannel, [
              {
                key: 'connect',
                value: function connect() {
                  var _this19 = this;

                  return {
                    disconnect: function disconnect() {
                      _this19.clientChannelPort.postMessage(
                        newMessage$1$1({
                          payload: null,
                          type: 'disconnect',
                        })
                      );

                      listeners$1$1.forEach(function(_ref17) {
                        var func = _ref17.func,
                          type = _ref17.type,
                          scope = _ref17.scope;
                        return scope === 'port'
                          ? _this19.clientChannelPort.removeEventListener(type, func) // $FlowFixMe
                          : removeEventListener(type, func);
                      });
                    },
                    receive: function receive(cb) {
                      listeners$1$1 = updateListeners$1$1({
                        func: requestMessage,
                        listeners: listeners$1$1,
                        type: 'message',
                        scope: 'port',
                      });

                      _this19.clientChannelPort.addEventListener('message', function(eventMsg) {
                        return requestMessage(eventMsg, cb, _this19.debug);
                      });
                    },
                    send: function send(msg) {
                      if (_this19.debug) {
                        console.log('Server responses with payload: '.concat(JSON.stringify(msg)));
                      }

                      _this19.clientChannelPort.postMessage(
                        newMessage$1$1({
                          payload: msg,
                          type: 'response',
                        })
                      );
                    },
                  };
                },
              },
            ]);

            return ServerChannel;
          })();

        var requestMessage = function requestMessage(eventMsg, cb, debug) {
          var _getMessageData$1$ = getMessageData$1$1(eventMsg),
            payload = _getMessageData$1$.payload,
            type = _getMessageData$1$.type;

          if (type === 'request') {
            if (debug) {
              console.log('Server receive request with payload: '.concat(payload));
            }

            cb(payload);
          }
        };

        var connectionHandler = function connectionHandler(ev, onStop) {
          var event = getMessageData$1$1(ev);

          switch (event.type) {
            case 'close': {
              onStop();
            }
          }
        };
        /**
         * written with <3 by scaleCube-js maintainers
         *
         * RSocketEventsServer Transport provider for event base messages
         * browser <--> browser
         *
         *
         */

        /**
         * A Events transport server.
         */

        var RSocketEventsServer =
          /*#__PURE__*/
          (function() {
            function RSocketEventsServer(options) {
              _classCallCheck(this, RSocketEventsServer);

              this._subscribers = new Set();
              this.address = options.address;
              this._server = new EventsServer(options);
            }

            _createClass(RSocketEventsServer, [
              {
                key: 'start',
                value: function start() {
                  var _this20 = this;

                  return new build_4(function(subscriber) {
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        if (!_this20._server) {
                          return;
                        }

                        _this20._server.onStop();
                      },
                      request: function request() {
                        _this20._server.onConnect(function(eventClient) {
                          var eventClientConnection = new RSocketEventsClient$1({
                            address: _this20.address,
                            eventClient: eventClient,
                          });

                          if (eventClientConnection) {
                            _this20._subscribers.add(eventClientConnection);

                            eventClientConnection.connect();
                            subscriber.onNext(eventClientConnection);
                          } else {
                            subscriber.onError(
                              new Error('unable to create connection - address: '.concat(_this20.address))
                            );
                          }
                        });
                      },
                    });
                  });
                },
              },
              {
                key: 'stop',
                value: function stop() {
                  if (!this._subscribers) {
                    return;
                  }

                  this._subscribers.forEach(function(subscriber) {
                    return subscriber.close();
                  });

                  this._subscribers.clear();
                },
              },
            ]);

            return RSocketEventsServer;
          })();

        var serverFactory = function serverFactory(options) {
          var address = options.address,
            factoryOptions = options.factoryOptions;
          validateAddress(address);
          var protocol = address.protocol;

          switch (protocol.toLowerCase()) {
            case 'pm':
              return new RSocketEventsServer({
                address: getFullAddress(address),
              });

            default:
              throw Error(NOT_VALID_PROTOCOL);
          }
        };

        var serializers = {
          data: {
            deserialize: function deserialize(data) {
              return data;
            },
            serialize: function serialize(data) {
              return data;
            },
          },
          metadata: {
            deserialize: function deserialize(data) {
              return data;
            },
            serialize: function serialize(data) {
              return data;
            },
          },
        };
        var TransportBrowser = {
          clientProvider: {
            providerFactory: clientFactory,
            serializers: serializers,
            factoryOptions: null,
          },
          serverProvider: {
            providerFactory: serverFactory,
            serializers: serializers,
            factoryOptions: null,
          },
        };
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        function isFunction$1(x) {
          return typeof x === 'function';
        }
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        var _enable_super_gross_mode_that_will_cause_bad_things = false;
        var config = {
          Promise: undefined,

          set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
              var error =
                /*@__PURE__*/
                new Error();
              /*@__PURE__*/

              console.warn(
                'DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' +
                  error.stack
              );
            }

            _enable_super_gross_mode_that_will_cause_bad_things = value;
          },

          get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
          },
        };
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        function hostReportError(err) {
          setTimeout(function() {
            throw err;
          });
        }
        /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */

        var empty = {
          closed: true,
          next: function next(value) {},
          error: function error(err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
              throw err;
            } else {
              hostReportError(err);
            }
          },
          complete: function complete() {},
        };
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        var isArray$1 =
          Array.isArray ||
          function(x) {
            return x && typeof x.length === 'number';
          };
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        function isObject$1(x) {
          return x !== null && _typeof(x) === 'object';
        }
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        function UnsubscriptionErrorImpl(errors) {
          Error.call(this);
          this.message = errors
            ? errors.length +
              ' errors occurred during unsubscription:\n' +
              errors
                .map(function(err, i) {
                  return i + 1 + ') ' + err.toString();
                })
                .join('\n  ')
            : '';
          this.name = 'UnsubscriptionError';
          this.errors = errors;
          return this;
        }

        UnsubscriptionErrorImpl.prototype =
          /*@__PURE__*/
          Object.create(Error.prototype);
        var UnsubscriptionError = UnsubscriptionErrorImpl;
        /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */

        var Subscription =
          /*@__PURE__*/
          (function() {
            function Subscription(unsubscribe) {
              this.closed = false;
              this._parent = null;
              this._parents = null;
              this._subscriptions = null;

              if (unsubscribe) {
                this._unsubscribe = unsubscribe;
              }
            }

            Subscription.prototype.unsubscribe = function() {
              var hasErrors = false;
              var errors;

              if (this.closed) {
                return;
              }

              var _a = this,
                _parent = _a._parent,
                _parents = _a._parents,
                _unsubscribe = _a._unsubscribe,
                _subscriptions = _a._subscriptions;

              this.closed = true;
              this._parent = null;
              this._parents = null;
              this._subscriptions = null;
              var index = -1;
              var len = _parents ? _parents.length : 0;

              while (_parent) {
                _parent.remove(this);

                _parent = (++index < len && _parents[index]) || null;
              }

              if (isFunction$1(_unsubscribe)) {
                try {
                  _unsubscribe.call(this);
                } catch (e) {
                  hasErrors = true;
                  errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
              }

              if (isArray$1(_subscriptions)) {
                index = -1;
                len = _subscriptions.length;

                while (++index < len) {
                  var sub = _subscriptions[index];

                  if (isObject$1(sub)) {
                    try {
                      sub.unsubscribe();
                    } catch (e) {
                      hasErrors = true;
                      errors = errors || [];

                      if (e instanceof UnsubscriptionError) {
                        errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                      } else {
                        errors.push(e);
                      }
                    }
                  }
                }
              }

              if (hasErrors) {
                throw new UnsubscriptionError(errors);
              }
            };

            Subscription.prototype.add = function(teardown) {
              var subscription = teardown;

              switch (_typeof(teardown)) {
                case 'function':
                  subscription = new Subscription(teardown);

                case 'object':
                  if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                  } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                  } else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                  }

                  break;

                default: {
                  if (!teardown) {
                    return Subscription.EMPTY;
                  }

                  throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
              }

              if (subscription._addParent(this)) {
                var subscriptions = this._subscriptions;

                if (subscriptions) {
                  subscriptions.push(subscription);
                } else {
                  this._subscriptions = [subscription];
                }
              }

              return subscription;
            };

            Subscription.prototype.remove = function(subscription) {
              var subscriptions = this._subscriptions;

              if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);

                if (subscriptionIndex !== -1) {
                  subscriptions.splice(subscriptionIndex, 1);
                }
              }
            };

            Subscription.prototype._addParent = function(parent) {
              var _a = this,
                _parent = _a._parent,
                _parents = _a._parents;

              if (_parent === parent) {
                return false;
              } else if (!_parent) {
                this._parent = parent;
                return true;
              } else if (!_parents) {
                this._parents = [parent];
                return true;
              } else if (_parents.indexOf(parent) === -1) {
                _parents.push(parent);

                return true;
              }

              return false;
            };

            Subscription.EMPTY = (function(empty) {
              empty.closed = true;
              return empty;
            })(new Subscription());

            return Subscription;
          })();

        function flattenUnsubscriptionErrors(errors) {
          return errors.reduce(function(errs, err) {
            return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
          }, []);
        }
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        var rxSubscriber =
          typeof Symbol === 'function'
            ? /*@__PURE__*/
              Symbol('rxSubscriber')
            : '@@rxSubscriber_' +
              /*@__PURE__*/
              Math.random();
        /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */

        var Subscriber =
          /*@__PURE__*/
          (function(_super) {
            __extends(Subscriber, _super);

            function Subscriber(destinationOrNext, error, complete) {
              var _this = _super.call(this) || this;

              _this.syncErrorValue = null;
              _this.syncErrorThrown = false;
              _this.syncErrorThrowable = false;
              _this.isStopped = false;

              switch (arguments.length) {
                case 0:
                  _this.destination = empty;
                  break;

                case 1:
                  if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                  }

                  if (_typeof(destinationOrNext) === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                      _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                      _this.destination = destinationOrNext;
                      destinationOrNext.add(_this);
                    } else {
                      _this.syncErrorThrowable = true;
                      _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }

                    break;
                  }

                default:
                  _this.syncErrorThrowable = true;
                  _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                  break;
              }

              return _this;
            }

            Subscriber.prototype[rxSubscriber] = function() {
              return this;
            };

            Subscriber.create = function(next, error, complete) {
              var subscriber = new Subscriber(next, error, complete);
              subscriber.syncErrorThrowable = false;
              return subscriber;
            };

            Subscriber.prototype.next = function(value) {
              if (!this.isStopped) {
                this._next(value);
              }
            };

            Subscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                this.isStopped = true;

                this._error(err);
              }
            };

            Subscriber.prototype.complete = function() {
              if (!this.isStopped) {
                this.isStopped = true;

                this._complete();
              }
            };

            Subscriber.prototype.unsubscribe = function() {
              if (this.closed) {
                return;
              }

              this.isStopped = true;

              _super.prototype.unsubscribe.call(this);
            };

            Subscriber.prototype._next = function(value) {
              this.destination.next(value);
            };

            Subscriber.prototype._error = function(err) {
              this.destination.error(err);
              this.unsubscribe();
            };

            Subscriber.prototype._complete = function() {
              this.destination.complete();
              this.unsubscribe();
            };

            Subscriber.prototype._unsubscribeAndRecycle = function() {
              var _a = this,
                _parent = _a._parent,
                _parents = _a._parents;

              this._parent = null;
              this._parents = null;
              this.unsubscribe();
              this.closed = false;
              this.isStopped = false;
              this._parent = _parent;
              this._parents = _parents;
              return this;
            };

            return Subscriber;
          })(Subscription);

        var SafeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            __extends(SafeSubscriber, _super);

            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
              var _this = _super.call(this) || this;

              _this._parentSubscriber = _parentSubscriber;
              var next;
              var context = _this;

              if (isFunction$1(observerOrNext)) {
                next = observerOrNext;
              } else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;

                if (observerOrNext !== empty) {
                  context = Object.create(observerOrNext);

                  if (isFunction$1(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                  }

                  context.unsubscribe = _this.unsubscribe.bind(_this);
                }
              }

              _this._context = context;
              _this._next = next;
              _this._error = error;
              _this._complete = complete;
              return _this;
            }

            SafeSubscriber.prototype.next = function(value) {
              if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;

                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                  this.__tryOrUnsub(this._next, value);
                } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                  this.unsubscribe();
                }
              }
            };

            SafeSubscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;

                if (this._error) {
                  if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);

                    this.unsubscribe();
                  } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);

                    this.unsubscribe();
                  }
                } else if (!_parentSubscriber.syncErrorThrowable) {
                  this.unsubscribe();

                  if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                  }

                  hostReportError(err);
                } else {
                  if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                  } else {
                    hostReportError(err);
                  }

                  this.unsubscribe();
                }
              }
            };

            SafeSubscriber.prototype.complete = function() {
              var _this = this;

              if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;

                if (this._complete) {
                  var wrappedComplete = function wrappedComplete() {
                    return _this._complete.call(_this._context);
                  };

                  if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);

                    this.unsubscribe();
                  } else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);

                    this.unsubscribe();
                  }
                } else {
                  this.unsubscribe();
                }
              }
            };

            SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
              try {
                fn.call(this._context, value);
              } catch (err) {
                this.unsubscribe();

                if (config.useDeprecatedSynchronousErrorHandling) {
                  throw err;
                } else {
                  hostReportError(err);
                }
              }
            };

            SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
              if (!config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
              }

              try {
                fn.call(this._context, value);
              } catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                  parent.syncErrorValue = err;
                  parent.syncErrorThrown = true;
                  return true;
                } else {
                  hostReportError(err);
                  return true;
                }
              }

              return false;
            };

            SafeSubscriber.prototype._unsubscribe = function() {
              var _parentSubscriber = this._parentSubscriber;
              this._context = null;
              this._parentSubscriber = null;

              _parentSubscriber.unsubscribe();
            };

            return SafeSubscriber;
          })(Subscriber);
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */

        function canReportError(observer) {
          while (observer) {
            var _a = observer,
              closed_1 = _a.closed,
              destination = _a.destination,
              isStopped = _a.isStopped;

            if (closed_1 || isStopped) {
              return false;
            } else if (destination && destination instanceof Subscriber) {
              observer = destination;
            } else {
              observer = null;
            }
          }

          return true;
        }
        /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */

        function toSubscriber(nextOrObserver, error, complete) {
          if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber) {
              return nextOrObserver;
            }

            if (nextOrObserver[rxSubscriber]) {
              return nextOrObserver[rxSubscriber]();
            }
          }

          if (!nextOrObserver && !error && !complete) {
            return new Subscriber(empty);
          }

          return new Subscriber(nextOrObserver, error, complete);
        }
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        var observable = (typeof Symbol === 'function' && Symbol.observable) || '@@observable';
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        function noop() {}
        /** PURE_IMPORTS_START _noop PURE_IMPORTS_END */

        function pipeFromArray(fns) {
          if (!fns) {
            return noop;
          }

          if (fns.length === 1) {
            return fns[0];
          }

          return function piped(input) {
            return fns.reduce(function(prev, fn) {
              return fn(prev);
            }, input);
          };
        }
        /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */

        var Observable =
          /*@__PURE__*/
          (function() {
            function Observable(subscribe) {
              this._isScalar = false;

              if (subscribe) {
                this._subscribe = subscribe;
              }
            }

            Observable.prototype.lift = function(operator) {
              var observable = new Observable();
              observable.source = this;
              observable.operator = operator;
              return observable;
            };

            Observable.prototype.subscribe = function(observerOrNext, error, complete) {
              var operator = this.operator;
              var sink = toSubscriber(observerOrNext, error, complete);

              if (operator) {
                sink.add(operator.call(sink, this.source));
              } else {
                sink.add(
                  this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable)
                    ? this._subscribe(sink)
                    : this._trySubscribe(sink)
                );
              }

              if (config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                  sink.syncErrorThrowable = false;

                  if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                  }
                }
              }

              return sink;
            };

            Observable.prototype._trySubscribe = function(sink) {
              try {
                return this._subscribe(sink);
              } catch (err) {
                if (config.useDeprecatedSynchronousErrorHandling) {
                  sink.syncErrorThrown = true;
                  sink.syncErrorValue = err;
                }

                if (canReportError(sink)) {
                  sink.error(err);
                } else {
                  console.warn(err);
                }
              }
            };

            Observable.prototype.forEach = function(next, promiseCtor) {
              var _this = this;

              promiseCtor = getPromiseCtor(promiseCtor);
              return new promiseCtor(function(resolve, reject) {
                var subscription;
                subscription = _this.subscribe(
                  function(value) {
                    try {
                      next(value);
                    } catch (err) {
                      reject(err);

                      if (subscription) {
                        subscription.unsubscribe();
                      }
                    }
                  },
                  reject,
                  resolve
                );
              });
            };

            Observable.prototype._subscribe = function(subscriber) {
              var source = this.source;
              return source && source.subscribe(subscriber);
            };

            Observable.prototype[observable] = function() {
              return this;
            };

            Observable.prototype.pipe = function() {
              var operations = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
              }

              if (operations.length === 0) {
                return this;
              }

              return pipeFromArray(operations)(this);
            };

            Observable.prototype.toPromise = function(promiseCtor) {
              var _this = this;

              promiseCtor = getPromiseCtor(promiseCtor);
              return new promiseCtor(function(resolve, reject) {
                var value;

                _this.subscribe(
                  function(x) {
                    return (value = x);
                  },
                  function(err) {
                    return reject(err);
                  },
                  function() {
                    return resolve(value);
                  }
                );
              });
            };

            Observable.create = function(subscribe) {
              return new Observable(subscribe);
            };

            return Observable;
          })();

        function getPromiseCtor(promiseCtor) {
          if (!promiseCtor) {
            promiseCtor = Promise;
          }

          if (!promiseCtor) {
            throw new Error('no Promise impl found');
          }

          return promiseCtor;
        }
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

        var EMPTY =
          /*@__PURE__*/
          new Observable(function(subscriber) {
            return subscriber.complete();
          });

        function empty$1(scheduler) {
          return scheduler ? emptyScheduled(scheduler) : EMPTY;
        }

        function emptyScheduled(scheduler) {
          return new Observable(function(subscriber) {
            return scheduler.schedule(function() {
              return subscriber.complete();
            });
          });
        }
        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        function ArgumentOutOfRangeErrorImpl() {
          Error.call(this);
          this.message = 'argument out of range';
          this.name = 'ArgumentOutOfRangeError';
          return this;
        }

        ArgumentOutOfRangeErrorImpl.prototype =
          /*@__PURE__*/
          Object.create(Error.prototype);
        var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */

        function tap(nextOrObserver, error, complete) {
          return function tapOperatorFunction(source) {
            return source.lift(new DoOperator(nextOrObserver, error, complete));
          };
        }

        var DoOperator =
          /*@__PURE__*/
          (function() {
            function DoOperator(nextOrObserver, error, complete) {
              this.nextOrObserver = nextOrObserver;
              this.error = error;
              this.complete = complete;
            }

            DoOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            };

            return DoOperator;
          })();

        var TapSubscriber =
          /*@__PURE__*/
          (function(_super) {
            __extends(TapSubscriber, _super);

            function TapSubscriber(destination, observerOrNext, error, complete) {
              var _this = _super.call(this, destination) || this;

              _this._tapNext = noop;
              _this._tapError = noop;
              _this._tapComplete = noop;
              _this._tapError = error || noop;
              _this._tapComplete = complete || noop;

              if (isFunction$1(observerOrNext)) {
                _this._context = _this;
                _this._tapNext = observerOrNext;
              } else if (observerOrNext) {
                _this._context = observerOrNext;
                _this._tapNext = observerOrNext.next || noop;
                _this._tapError = observerOrNext.error || noop;
                _this._tapComplete = observerOrNext.complete || noop;
              }

              return _this;
            }

            TapSubscriber.prototype._next = function(value) {
              try {
                this._tapNext.call(this._context, value);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.next(value);
            };

            TapSubscriber.prototype._error = function(err) {
              try {
                this._tapError.call(this._context, err);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.error(err);
            };

            TapSubscriber.prototype._complete = function() {
              try {
                this._tapComplete.call(this._context);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              return this.destination.complete();
            };

            return TapSubscriber;
          })(Subscriber);
        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */

        function take(count) {
          return function(source) {
            if (count === 0) {
              return empty$1();
            } else {
              return source.lift(new TakeOperator(count));
            }
          };
        }

        var TakeOperator =
          /*@__PURE__*/
          (function() {
            function TakeOperator(total) {
              this.total = total;

              if (this.total < 0) {
                throw new ArgumentOutOfRangeError();
              }
            }

            TakeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new TakeSubscriber(subscriber, this.total));
            };

            return TakeOperator;
          })();

        var TakeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            __extends(TakeSubscriber, _super);

            function TakeSubscriber(destination, total) {
              var _this = _super.call(this, destination) || this;

              _this.total = total;
              _this.count = 0;
              return _this;
            }

            TakeSubscriber.prototype._next = function(value) {
              var total = this.total;
              var count = ++this.count;

              if (count <= total) {
                this.destination.next(value);

                if (count === total) {
                  this.destination.complete();
                  this.unsubscribe();
                }
              }
            };

            return TakeSubscriber;
          })(Subscriber);
        /** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _map PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

        /** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

        /** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */

        var ASYNC_MODEL_TYPES$1 = ASYNC_MODEL_TYPES;
        exports.ASYNC_MODEL_TYPES = ASYNC_MODEL_TYPES$1;
        var MICROSERVICE_NOT_EXISTS = 'MS0000 - microservice does not exists';
        var MESSAGE_NOT_PROVIDED = 'MS0001 - Message has not been provided';
        var MESSAGE_DATA_NOT_PROVIDED = 'MS0002 - Message data has not been provided';
        var MESSAGE_QUALIFIER_NOT_PROVIDED = 'MS0003 - Message qualifier has not been provided';
        var INVALID_MESSAGE = 'MS0004 - Message should not to be empty object';
        var INVALID_QUALIFIER = 'MS0005 - qualifier expected to be service/method format';
        var SERVICE_DEFINITION_NOT_PROVIDED = 'MS0006 - Service missing definition';
        var WRONG_DATA_FORMAT_IN_MESSAGE = 'MS0007 - Message format error: data must be Array';
        var SERVICES_IS_NOT_ARRAY = 'MS0008 - Not valid format, services must be an Array';
        var SERVICE_IS_NOT_OBJECT = 'MS0009 - Not valid format, service must be an Object';
        var MICROSERVICE_OPTIONS_IS_NOT_OBJECT = 'MS0000 - Not valid format, MicroserviceOptions must be an Object';
        var QUALIFIER_IS_NOT_STRING = 'MS0011 - qualifier should not be empty string';
        var TRANSPORT_NOT_PROVIDED = 'MS0013 - Transport provider is not define';
        var ROUTER_NOT_PROVIDED = 'MS0024 - Router is not define';

        var getServiceMethodIsMissingError = function getServiceMethodIsMissingError(methodName) {
          return "MS0014 - service method '" + methodName + "' missing in the serviceDefinition";
        };

        var getNotFoundByRouterError = function getNotFoundByRouterError(whoAmI, qualifier) {
          return (
            'MS0015 - ' +
            whoAmI +
            " can't find services that match the give criteria: '" +
            JSON.stringify(qualifier) +
            "'"
          );
        };

        var getAsyncModelMissmatch = function getAsyncModelMissmatch(expectedAsyncModel, receivedAsyncModel) {
          return (
            'MS0016 - asyncModel does not match, expect ' + expectedAsyncModel + ', but received ' + receivedAsyncModel
          );
        };

        var getMethodNotFoundError = function getMethodNotFoundError(message) {
          return "Can't find method " + message.qualifier;
        };

        var getInvalidMethodReferenceError = function getInvalidMethodReferenceError(qualifier) {
          return 'MS0017 - service (' + qualifier + ') has valid definition but reference is not a function.';
        };

        var getServiceReferenceNotProvidedError = function getServiceReferenceNotProvidedError(serviceName) {
          return 'MS0018 - service does not uphold the contract, ' + serviceName + ' is not provided';
        };

        var getInvalidServiceReferenceError = function getInvalidServiceReferenceError(serviceName) {
          return 'MS0019 - Not valid format, ' + serviceName + ' reference must be an Object';
        };

        var getIncorrectServiceImplementForPromise = function getIncorrectServiceImplementForPromise(
          whoAmI,
          qualifier
        ) {
          return (
            'MS0025 - ' + whoAmI + "'s service '" + qualifier + "' define as Promise but service return not Promise"
          );
        };

        var getIncorrectServiceImplementForObservable = function getIncorrectServiceImplementForObservable(
          whoAmI,
          qualifier
        ) {
          return (
            'MS0026 - ' +
            whoAmI +
            "'s service '" +
            qualifier +
            "' define as Observable but service return not Observable"
          );
        };

        var RSocketConnectionStatus = {
          NOT_CONNECTED: 'NOT_CONNECTED',
          CONNECTING: 'CONNECTING',
          CONNECTED: 'CONNECTED',
          CLOSED: 'CLOSED',
          ERROR: 'ERROR',
        };

        var validateMicroserviceOptions = function validateMicroserviceOptions(microserviceOptions) {
          assertObject(microserviceOptions, MICROSERVICE_OPTIONS_IS_NOT_OBJECT);
          var services = microserviceOptions.services,
            seedAddress = microserviceOptions.seedAddress,
            address = microserviceOptions.address;
          validateAddress(seedAddress, true);
          validateAddress(address, true);
          validateMicroserviceServices(services);
        };

        var validateMicroserviceServices = function validateMicroserviceServices(services) {
          assertArray(services, SERVICES_IS_NOT_ARRAY);
          services.forEach(validateService);
        };

        var validateService = function validateService(service) {
          assertNonEmptyObject(service, SERVICE_IS_NOT_OBJECT);
          var definition = service.definition,
            reference = service.reference;
          assertDefined(definition, SERVICE_DEFINITION_NOT_PROVIDED);
          validateServiceDefinition(definition);
          var serviceName = definition.serviceName;
          assertDefined(reference, getServiceReferenceNotProvidedError(serviceName));
        };

        var validateServiceReference = function validateServiceReference(reference, definition) {
          var serviceName = definition.serviceName;
          assertObject(reference, getInvalidServiceReferenceError(serviceName));
          Object.keys(definition.methods).forEach(function(methodName) {
            var qualifier = getQualifier({
              serviceName: serviceName,
              methodName: methodName,
            });
            var staticMethodRef = reference.constructor && reference.constructor[methodName];
            assertFunction(reference[methodName] || staticMethodRef, getInvalidMethodReferenceError(qualifier));
          });
        };

        var validateMessage = function validateMessage(message) {
          assertDefined(message, MESSAGE_NOT_PROVIDED);
          assertNonEmptyObject(message, INVALID_MESSAGE);
          var data = message.data,
            qualifier = message.qualifier;
          assertDefined(qualifier, MESSAGE_QUALIFIER_NOT_PROVIDED);
          validateQualifier(qualifier);
          assertDefined(data, MESSAGE_DATA_NOT_PROVIDED);
          assertArray(data, WRONG_DATA_FORMAT_IN_MESSAGE);
        };

        var validateQualifier = function validateQualifier(value) {
          assertNonEmptyString(value, QUALIFIER_IS_NOT_STRING);
          var parts = value.split('/');
          assert(parts.length === 2, INVALID_QUALIFIER);
          assertNonEmptyString(parts[0], INVALID_QUALIFIER);
          assertNonEmptyString(parts[1], INVALID_QUALIFIER);
        };

        var validateDiscoveryInstance = function validateDiscoveryInstance(discovery) {
          assertDefined(discovery, '');
          var discoveredItems$ = discovery.discoveredItems$,
            destroy = discovery.destroy;
          assertDefined(discoveredItems$, '');
          assertDefined(destroy, '');
        };

        var serviceCallError = function serviceCallError(_a) {
          var errorMessage = _a.errorMessage,
            microserviceContext = _a.microserviceContext;
          var error = new Error(errorMessage);

          if (microserviceContext) {
            var whoAmI = microserviceContext.whoAmI,
              debug = microserviceContext.debug;
            saveToLogs(whoAmI, errorMessage, {}, debug, 'warn');
          }

          return error;
        };

        var localCall = function localCall(_a) {
          var localService = _a.localService,
            asyncModel = _a.asyncModel,
            messageFormat = _a.messageFormat,
            message = _a.message,
            microserviceContext = _a.microserviceContext;
          return new _rxjs.Observable(function(obs) {
            var reference = localService.reference,
              asyncModelProvider = localService.asyncModel;
            var method = reference && reference[localService.methodName];

            if (!method) {
              throw serviceCallError({
                errorMessage: getMethodNotFoundError(message),
                microserviceContext: microserviceContext,
              });
            }

            if (asyncModelProvider !== asyncModel) {
              obs.error(
                serviceCallError({
                  errorMessage: getAsyncModelMissmatch(asyncModel, asyncModelProvider),
                  microserviceContext: microserviceContext,
                })
              );
            }

            var invoke = method.apply(void 0, message.data);

            switch (asyncModel) {
              case ASYNC_MODEL_TYPES$1.REQUEST_STREAM:
                typeof invoke.subscribe === 'function'
                  ? invoke.subscribe(
                      function() {
                        var data = [];

                        for (var _i = 0; _i < arguments.length; _i++) {
                          data[_i] = arguments[_i];
                        }

                        return obs.next.apply(obs, data);
                      },
                      function(err) {
                        return obs.error(err);
                      },
                      function() {
                        return obs.complete();
                      }
                    )
                  : obs.error(
                      serviceCallError({
                        errorMessage: getIncorrectServiceImplementForObservable(
                          microserviceContext.whoAmI,
                          message.qualifier
                        ),
                        microserviceContext: microserviceContext,
                      })
                    );
                break;

              case ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE:
                typeof invoke.then === 'function'
                  ? invoke
                      .then(function() {
                        var data = [];

                        for (var _i = 0; _i < arguments.length; _i++) {
                          data[_i] = arguments[_i];
                        }

                        obs.next.apply(obs, data);
                      })
                      ['catch'](function(error) {
                        obs.error(error);
                      })
                  : obs.error(
                      serviceCallError({
                        errorMessage: getIncorrectServiceImplementForPromise(
                          microserviceContext.whoAmI,
                          message.qualifier
                        ),
                        microserviceContext: microserviceContext,
                      })
                    );
                break;

              default:
                throw new Error('invalid async model');
            }
          });
        };
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @typechecks
         */

        var hasOwnProperty = Object.prototype.hasOwnProperty;
        /**
         * Executes the provided `callback` once for each enumerable own property in the
         * object. The `callback` is invoked with three arguments:
         *
         *  - the property value
         *  - the property name
         *  - the object being traversed
         *
         * Properties that are added after the call to `forEachObject` will not be
         * visited by `callback`. If the values of existing properties are changed, the
         * value passed to `callback` will be the value at the time `forEachObject`
         * visits them. Properties that are deleted before being visited are not
         * visited.
         *
         * @param {?object} object
         * @param {function} callback
         * @param {*} context
         */

        function forEachObject(object, callback, context) {
          for (var name in object) {
            if (hasOwnProperty.call(object, name)) {
              callback.call(context, object[name], name, object);
            }
          }
        }

        var forEachObject_1 = forEachObject;
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         * @typechecks
         */

        /**
         * Simple function for formatting strings.
         *
         * Replaces placeholders with values passed as extra arguments
         *
         * @param {string} format the base string
         * @param ...args the values to insert
         * @return {string} the replaced string
         */

        function sprintf(format) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var index = 0;
          return format.replace(/%s/g, function(match) {
            return args[index++];
          });
        }

        var sprintf_1 = sprintf;
        var RSocketFrame = createCommonjsModule(function(module, exports) {
          /* eslint-disable max-len, no-bitwise */
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.MAX_VERSION = exports.MAX_TTL = exports.MAX_STREAM_ID = exports.MAX_RESUME_LENGTH = exports.MAX_REQUEST_N = exports.MAX_REQUEST_COUNT = exports.MAX_MIME_LENGTH = exports.MAX_METADATA_LENGTH = exports.MAX_LIFETIME = exports.MAX_KEEPALIVE = exports.MAX_CODE = exports.FRAME_TYPE_OFFFSET = exports.FLAGS_MASK = exports.ERROR_EXPLANATIONS = exports.ERROR_CODES = exports.FLAGS = exports.FRAME_TYPE_NAMES = exports.FRAME_TYPES = exports.CONNECTION_STREAM_ID = undefined;
          exports.isIgnore = isIgnore;
          exports.isMetadata = isMetadata;
          exports.isComplete = isComplete;
          exports.isNext = isNext;
          exports.isRespond = isRespond;
          exports.isResumeEnable = isResumeEnable;
          exports.isLease = isLease;
          exports.isResumePositionFrameType = isResumePositionFrameType;
          exports.getFrameTypeName = getFrameTypeName;
          exports.createErrorFromFrame = createErrorFromFrame;
          exports.getErrorCodeExplanation = getErrorCodeExplanation;
          exports.printFrame = printFrame;

          var _forEachObject2 = _interopRequireDefault(forEachObject_1);

          var _sprintf2 = _interopRequireDefault(sprintf_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var CONNECTION_STREAM_ID = (exports.CONNECTION_STREAM_ID = 0);
          var FRAME_TYPES = (exports.FRAME_TYPES = {
            CANCEL: 0x09,
            // Cancel Request: Cancel outstanding request.
            ERROR: 0x0b,
            // Error: Error at connection or application level.
            EXT: 0x3f,
            // Extension Header: Used To Extend more frame types as well as extensions.
            KEEPALIVE: 0x03,
            // Keepalive: Connection keepalive.
            LEASE: 0x02,
            // Lease: Sent by Responder to grant the ability to send requests.
            METADATA_PUSH: 0x0c,
            // Metadata: Asynchronous Metadata frame
            PAYLOAD: 0x0a,
            // Payload: Payload on a stream. For example, response to a request, or message on a channel.
            REQUEST_CHANNEL: 0x07,
            // Request Channel: Request a completable stream in both directions.
            REQUEST_FNF: 0x05,
            // Fire And Forget: A single one-way message.
            REQUEST_N: 0x08,
            // Request N: Request N more items with Reactive Streams semantics.
            REQUEST_RESPONSE: 0x04,
            // Request Response: Request single response.
            REQUEST_STREAM: 0x06,
            // Request Stream: Request a completable stream.
            RESERVED: 0x00,
            // Reserved
            RESUME: 0x0d,
            // Resume: Replaces SETUP for Resuming Operation (optional)
            RESUME_OK: 0x0e,
            // Resume OK : Sent in response to a RESUME if resuming operation possible (optional)
            SETUP: 0x01, // Setup: Sent by client to initiate protocol processing.
          }); // Maps frame type codes to type names

          var FRAME_TYPE_NAMES = (exports.FRAME_TYPE_NAMES = {});
          (0, _forEachObject2['default'])(FRAME_TYPES, function(value, name) {
            FRAME_TYPE_NAMES[value] = name;
          });
          var FLAGS = (exports.FLAGS = {
            COMPLETE: 0x40,
            // PAYLOAD, REQUEST_CHANNEL: indicates stream completion, if set onComplete will be invoked on receiver.
            FOLLOWS: 0x80,
            // (unused)
            IGNORE: 0x200,
            // (all): Ignore frame if not understood.
            LEASE: 0x40,
            // SETUP: Will honor lease or not.
            METADATA: 0x100,
            // (all): must be set if metadata is present in the frame.
            NEXT: 0x20,
            // PAYLOAD: indicates data/metadata present, if set onNext will be invoked on receiver.
            RESPOND: 0x80,
            // KEEPALIVE: should KEEPALIVE be sent by peer on receipt.
            RESUME_ENABLE: 0x80, // SETUP: Client requests resume capability if possible. Resume Identification Token present.
          }); // Maps error names to codes

          var ERROR_CODES = (exports.ERROR_CODES = {
            APPLICATION_ERROR: 0x00000201,
            CANCELED: 0x00000203,
            CONNECTION_CLOSE: 0x00000102,
            CONNECTION_ERROR: 0x00000101,
            INVALID: 0x00000204,
            INVALID_SETUP: 0x00000001,
            REJECTED: 0x00000202,
            REJECTED_RESUME: 0x00000004,
            REJECTED_SETUP: 0x00000003,
            RESERVED: 0x00000000,
            RESERVED_EXTENSION: 0xffffffff,
            UNSUPPORTED_SETUP: 0x00000002,
          }); // Maps error codes to names

          var ERROR_EXPLANATIONS = (exports.ERROR_EXPLANATIONS = {});
          (0, _forEachObject2['default'])(ERROR_CODES, function(code, explanation) {
            ERROR_EXPLANATIONS[code] = explanation;
          });
          var FLAGS_MASK = (exports.FLAGS_MASK = 0x3ff); // low 10 bits

          var FRAME_TYPE_OFFFSET = (exports.FRAME_TYPE_OFFFSET = 10); // frame type is offset 10 bytes within the uint16 containing type + flags

          var MAX_CODE = (exports.MAX_CODE = 0x7fffffff); // uint31

          var MAX_KEEPALIVE = (exports.MAX_KEEPALIVE = 0x7fffffff); // uint31

          var MAX_LIFETIME = (exports.MAX_LIFETIME = 0x7fffffff); // uint31

          var MAX_METADATA_LENGTH = (exports.MAX_METADATA_LENGTH = 0xffffff); // uint24

          var MAX_MIME_LENGTH = (exports.MAX_MIME_LENGTH = 0xff); // int8

          var MAX_REQUEST_COUNT = (exports.MAX_REQUEST_COUNT = 0x7fffffff); // uint31

          var MAX_REQUEST_N = (exports.MAX_REQUEST_N = 0x7fffffff); // uint31

          var MAX_RESUME_LENGTH = (exports.MAX_RESUME_LENGTH = 0xffff); // uint16

          var MAX_STREAM_ID = (exports.MAX_STREAM_ID = 0x7fffffff); // uint31

          var MAX_TTL = (exports.MAX_TTL = 0x7fffffff); // uint31

          var MAX_VERSION = (exports.MAX_VERSION = 0xffff); // uint16

          /**
           * Returns true iff the flags have the IGNORE bit set.
           */

          function isIgnore(flags) {
            return (flags & FLAGS.IGNORE) === FLAGS.IGNORE;
          }
          /**
           * Returns true iff the flags have the METADATA bit set.
           */

          function isMetadata(flags) {
            return (flags & FLAGS.METADATA) === FLAGS.METADATA;
          }
          /**
           * Returns true iff the flags have the COMPLETE bit set.
           */

          function isComplete(flags) {
            return (flags & FLAGS.COMPLETE) === FLAGS.COMPLETE;
          }
          /**
           * Returns true iff the flags have the NEXT bit set.
           */

          function isNext(flags) {
            return (flags & FLAGS.NEXT) === FLAGS.NEXT;
          }
          /**
           * Returns true iff the flags have the RESPOND bit set.
           */

          function isRespond(flags) {
            return (flags & FLAGS.RESPOND) === FLAGS.RESPOND;
          }
          /**
           * Returns true iff the flags have the RESUME_ENABLE bit set.
           */

          function isResumeEnable(flags) {
            return (flags & FLAGS.RESUME_ENABLE) === FLAGS.RESUME_ENABLE;
          }
          /**
           * Returns true iff the flags have the LEASE bit set.
           */

          function isLease(flags) {
            return (flags & FLAGS.LEASE) === FLAGS.LEASE;
          }
          /**
           * Returns true iff the frame type is counted toward the implied
           * client/server position used for the resumption protocol.
           */

          function isResumePositionFrameType(type) {
            return (
              type === FRAME_TYPES.CANCEL ||
              type === FRAME_TYPES.ERROR ||
              type === FRAME_TYPES.PAYLOAD ||
              type === FRAME_TYPES.REQUEST_CHANNEL ||
              type === FRAME_TYPES.REQUEST_FNF ||
              type === FRAME_TYPES.REQUEST_RESPONSE ||
              type === FRAME_TYPES.REQUEST_STREAM ||
              type === FRAME_TYPES.REQUEST_N
            );
          }

          function getFrameTypeName(type) {
            var name = FRAME_TYPE_NAMES[type];
            return name != null ? name : toHex(type);
          }
          /**
           * Constructs an Error object given the contents of an error frame. The
           * `source` property contains metadata about the error for use in introspecting
           * the error at runtime:
           * - `error.source.code: number`: the error code returned by the server.
           * - `error.source.explanation: string`: human-readable explanation of the code
           *   (this value is not standardized and may change).
           * - `error.source.message: string`: the error string returned by the server.
           */

          function createErrorFromFrame(frame) {
            var code = frame.code,
              message = frame.message;
            var explanation = getErrorCodeExplanation(code);
            var error = new Error(
              (0, _sprintf2['default'])(
                'RSocket error %s (%s): %s. See error `source` property for details.',
                toHex(code),
                explanation,
                message
              )
            );
            error.source = {
              code: code,
              explanation: explanation,
              message: message,
            };
            return error;
          }
          /**
           * Given a RSocket error code, returns a human-readable explanation of that
           * code, following the names used in the protocol specification.
           */

          function getErrorCodeExplanation(code) {
            var explanation = ERROR_EXPLANATIONS[code];

            if (explanation != null) {
              return explanation;
            } else if (code <= 0x00300) {
              return 'RESERVED (PROTOCOL)';
            } else {
              return 'RESERVED (APPLICATION)';
            }
          }
          /**
           * Pretty-prints the frame for debugging purposes, with types, flags, and
           * error codes annotated with descriptive names.
           */

          function printFrame(frame) {
            var obj = Object.assign({}, frame);
            obj.type = getFrameTypeName(frame.type) + ' ('.concat(toHex(frame.type), ')');
            var flagNames = [];
            (0, _forEachObject2['default'])(FLAGS, function(flag, name) {
              if ((frame.flags & flag) === flag) {
                flagNames.push(name);
              }
            });

            if (!flagNames.length) {
              flagNames.push('NO FLAGS');
            }

            obj.flags = flagNames.join(' | ') + ' ('.concat(toHex(frame.flags), ')');

            if (frame.type === FRAME_TYPES.ERROR) {
              obj.code = getErrorCodeExplanation(frame.code) + ' ('.concat(toHex(frame.code), ')');
            }

            return JSON.stringify(obj, null, 2);
          }

          function toHex(n) {
            return '0x' + n.toString(16);
          }
        });
        unwrapExports(RSocketFrame);
        var RSocketFrame_1 = RSocketFrame.MAX_VERSION;
        var RSocketFrame_2 = RSocketFrame.MAX_TTL;
        var RSocketFrame_3 = RSocketFrame.MAX_STREAM_ID;
        var RSocketFrame_4 = RSocketFrame.MAX_RESUME_LENGTH;
        var RSocketFrame_5 = RSocketFrame.MAX_REQUEST_N;
        var RSocketFrame_6 = RSocketFrame.MAX_REQUEST_COUNT;
        var RSocketFrame_7 = RSocketFrame.MAX_MIME_LENGTH;
        var RSocketFrame_8 = RSocketFrame.MAX_METADATA_LENGTH;
        var RSocketFrame_9 = RSocketFrame.MAX_LIFETIME;
        var RSocketFrame_10 = RSocketFrame.MAX_KEEPALIVE;
        var RSocketFrame_11 = RSocketFrame.MAX_CODE;
        var RSocketFrame_12 = RSocketFrame.FRAME_TYPE_OFFFSET;
        var RSocketFrame_13 = RSocketFrame.FLAGS_MASK;
        var RSocketFrame_14 = RSocketFrame.ERROR_EXPLANATIONS;
        var RSocketFrame_15 = RSocketFrame.ERROR_CODES;
        var RSocketFrame_16 = RSocketFrame.FLAGS;
        var RSocketFrame_17 = RSocketFrame.FRAME_TYPE_NAMES;
        var RSocketFrame_18 = RSocketFrame.FRAME_TYPES;
        var RSocketFrame_19 = RSocketFrame.CONNECTION_STREAM_ID;
        var RSocketFrame_20 = RSocketFrame.isIgnore;
        var RSocketFrame_21 = RSocketFrame.isMetadata;
        var RSocketFrame_22 = RSocketFrame.isComplete;
        var RSocketFrame_23 = RSocketFrame.isNext;
        var RSocketFrame_24 = RSocketFrame.isRespond;
        var RSocketFrame_25 = RSocketFrame.isResumeEnable;
        var RSocketFrame_26 = RSocketFrame.isLease;
        var RSocketFrame_27 = RSocketFrame.isResumePositionFrameType;
        var RSocketFrame_28 = RSocketFrame.getFrameTypeName;
        var RSocketFrame_29 = RSocketFrame.createErrorFromFrame;
        var RSocketFrame_30 = RSocketFrame.getErrorCodeExplanation;
        var RSocketFrame_31 = RSocketFrame.printFrame;
        var RSocketVersion = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          var MAJOR_VERSION = (exports.MAJOR_VERSION = 1);
          var MINOR_VERSION = (exports.MINOR_VERSION = 0);
        });
        unwrapExports(RSocketVersion);
        var RSocketVersion_1 = RSocketVersion.MAJOR_VERSION;
        var RSocketVersion_2 = RSocketVersion.MINOR_VERSION;
        var LiteBuffer_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.Buffer = Buffer;
          var K_MAX_LENGTH = 0x7fffffff;

          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            } // Return an augmented `Uint8Array` instance

            var buf = new Uint8Array(length); // $FlowFixMe

            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          var bufferExists = typeof commonjsGlobal !== 'undefined' && commonjsGlobal.hasOwnProperty('Buffer'); // export const LiteBuffer =  bufferExists ? gloval.Buffer : Buffer;

          var LiteBuffer = (exports.LiteBuffer = bufferExists ? commonjsGlobal.Buffer : Buffer);

          function Buffer(arg, encodingOrOffset, length) {
            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new TypeError('The "string" argument must be of type string. Received type number');
              }

              return allocUnsafe(arg);
            }

            return from(arg, encodingOrOffset, length);
          }

          function from(value, encodingOrOffset, length) {
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }

            if (value == null) {
              throw TypeError(
                'The first argument must be one of type, Buffer, ArrayBuffer, Array, ' +
                  'or Array-like Object. Received type ' +
                  _typeof(value)
              );
            }

            if (isInstance(value, ArrayBuffer) || (value && isInstance(value.buffer, ArrayBuffer))) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }

            if (typeof value === 'number') {
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            }

            var valueOf = value.valueOf && value.valueOf();

            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }

            var b = fromObject(value);

            if (b) {
              return b;
            }

            throw new TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, ' +
                'Array, or Array-like Object. Received type ' +
                _typeof(value)
            );
          }

          Buffer.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          }; // $FlowFixMe

          Buffer.prototype.__proto__ = Uint8Array.prototype; // $FlowFixMe

          Buffer.__proto__ = Uint8Array;

          function assertSize(size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }

          function alloc(size, fill, encoding) {
            assertSize(size);
            return createBuffer(size);
          }

          Buffer.alloc = function(size, fill, encoding) {
            return alloc(size);
          };

          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }

          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);

            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }

            return buf;
          }

          function fromArrayBuffer(array, byteOffset, length) {
            var buf;

            if (byteOffset === undefined && length === undefined) {
              buf = new Uint8Array(array);
            } else if (length === undefined) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            } // $FlowFixMe

            buf.__proto__ = Buffer.prototype;
            return buf;
          }

          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);

              if (buf.length === 0) {
                return buf;
              }

              obj.copy(buf, 0, 0, len);
              return buf;
            }

            if (obj.length !== undefined) {
              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }

              return fromArrayLike(obj);
            }

            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }

          function checked(length) {
            if (length >= K_MAX_LENGTH) {
              throw new RangeError(
                'Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes'
              );
            }

            return length | 0;
          }

          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype;
          };

          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true;

              default:
                return false;
            }
          };

          Buffer.prototype._isBuffer = true;

          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };

          function blitBuffer(src, dst, offset, length) {
            var i = 0;

            for (; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length) break;
              dst[i + offset] = src[i];
            }

            return i;
          }

          function utf8Write(buf, input, offset, length) {
            return blitBuffer(utf8ToBytes(input, buf.length - offset), buf, offset, length);
          }

          Buffer.prototype.write = function write(input, offset, length, encoding) {
            switch (encoding) {
              case 'utf8':
                return utf8Write(this, input, offset, length);

              default:
                throw new TypeError('Unknown encoding: ' + encoding);
            }
          };

          var MAX_ARGUMENTS_LENGTH = 0x1000;

          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;

            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
            } // Decode in chunks to avoid "call stack size exceeded".

            var res = '';
            var i = 0;

            while (i < len) {
              res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));
            }

            return res;
          }

          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === undefined ? len : ~~end;

            if (start < 0) {
              start += len;
              if (start < 0) start = 0;
            } else if (start > len) {
              start = len;
            }

            if (end < 0) {
              end += len;
              if (end < 0) end = 0;
            } else if (end > len) {
              end = len;
            }

            if (end < start) end = start;
            var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

            newBuf.__proto__ = Buffer.prototype;
            return newBuf;
          };

          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
          }

          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            return this[offset];
          };

          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            return (this[offset] << 8) | this[offset + 1];
          };

          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return this[offset] * 0x1000000 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
          };

          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 1, this.length);
            if (!(this[offset] & 0x80)) return this[offset];
            return (0xff - this[offset] + 1) * -1;
          };

          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | (this[offset] << 8);
            return val & 0x8000 ? val | 0xffff0000 : val;
          };

          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert) checkOffset(offset, 4, this.length);
            return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3];
          };

          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError('Index out of range');
          }

          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
            this[offset] = value & 0xff;
            return offset + 1;
          };

          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          };

          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
            return offset + 2;
          };

          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
            if (value < 0) value = 0xffffffff + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
            return offset + 4;
          }; // $FlowFixMe

          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0) return '';
            return slowToString.apply(this, arguments);
          };

          function slowToString(encoding, start, end) {
            var loweredCase = false;

            if (start === undefined || start < 0) {
              start = 0;
            }

            if (start > this.length) {
              return '';
            }

            if (end === undefined || end > this.length) {
              end = this.length;
            }

            if (end <= 0) {
              return '';
            } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.

            end >>>= 0;
            start >>>= 0;

            if (end <= start) {
              return '';
            }

            if (!encoding) encoding = 'utf8';

            while (true) {
              switch (encoding) {
                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end);

                default:
                  if (loweredCase) throw new TypeError('Unsupported encoding: ' + encoding);
                  encoding = (encoding + '').toLowerCase();
                  loweredCase = true;
              }
            }
          }

          function utf8ToBytes(str) {
            var pUnits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
            var units = pUnits;
            var codePoint;
            var length = str.length;
            var leadSurrogate = null;
            var bytes = [];

            for (var i = 0; i < length; ++i) {
              codePoint = str.charCodeAt(i); // is surrogate component

              if (codePoint > 0xd7ff && codePoint < 0xe000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xdbff) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    continue;
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                    continue;
                  } // valid lead

                  leadSurrogate = codePoint;
                  continue;
                } // 2 leads in a row

                if (codePoint < 0xdc00) {
                  if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
                  leadSurrogate = codePoint;
                  continue;
                } // valid surrogate pair

                codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xef, 0xbf, 0xbd);
              }

              leadSurrogate = null; // encode utf8

              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break;
                bytes.push(codePoint);
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break;
                bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break;
                bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break;
                bytes.push(
                  (codePoint >> 0x12) | 0xf0,
                  ((codePoint >> 0xc) & 0x3f) | 0x80,
                  ((codePoint >> 0x6) & 0x3f) | 0x80,
                  (codePoint & 0x3f) | 0x80
                );
              } else {
                throw new Error('Invalid code point');
              }
            }

            return bytes;
          }

          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }

            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }

            if (typeof string !== 'string') {
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ' +
                  'ArrayBuffer. Received type ' +
                  _typeof(string)
              );
            }

            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

            var loweredCase = false;

            for (;;) {
              switch (encoding) {
                case 'utf8':
                case 'utf-8':
                  return utf8ToBytes(string).length;

                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                  }

                  encoding = ('' + encoding).toLowerCase();
                  loweredCase = true;
              }
            }

            throw new Error('Unexpected path in function');
          }

          Buffer.byteLength = byteLength;

          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;

            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;

              if (i + bytesPerSequence <= end) {
                var secondByte = void 0,
                  thirdByte = void 0,
                  fourthByte = void 0,
                  tempCodePoint = void 0;

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte;
                    }

                    break;

                  case 2:
                    secondByte = buf[i + 1];

                    if ((secondByte & 0xc0) === 0x80) {
                      tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);

                      if (tempCodePoint > 0x7f) {
                        codePoint = tempCodePoint;
                      }
                    }

                    break;

                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];

                    if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {
                      tempCodePoint = ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);

                      if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {
                        codePoint = tempCodePoint;
                      }
                    }

                    break;

                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];

                    if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {
                      tempCodePoint =
                        ((firstByte & 0xf) << 0x12) |
                        ((secondByte & 0x3f) << 0xc) |
                        ((thirdByte & 0x3f) << 0x6) |
                        (fourthByte & 0x3f);

                      if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xfffd;
                bytesPerSequence = 1;
              } else if (codePoint > 0xffff) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000;
                res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);
                codePoint = 0xdc00 | (codePoint & 0x3ff);
              }

              res.push(codePoint);
              i += bytesPerSequence;
            }

            return decodeCodePointsArray(res);
          } // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)

          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
            if (!start) start = 0;
            if (!end && end !== 0) end = this.length;
            if (targetStart >= target.length) targetStart = target.length;
            if (!targetStart) targetStart = 0;
            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

            if (end === start) return 0;
            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds');
            }

            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

            if (end > this.length) end = this.length;

            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }

            var len = end - start;

            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
              // Use built-in when available, missing from IE11
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            }

            return len;
          };

          function isInstance(obj, type) {
            return (
              obj instanceof type ||
              (obj != null &&
                obj.constructor != null &&
                obj.constructor.name != null &&
                obj.constructor.name === type.name)
            );
          }

          function numberIsNaN(obj) {
            // For IE11 support
            return obj !== obj; // eslint-disable-line no-self-compare
          }
        });
        unwrapExports(LiteBuffer_1);
        var LiteBuffer_2 = LiteBuffer_1.Buffer;
        var LiteBuffer_3 = LiteBuffer_1.LiteBuffer;
        var RSocketSerialization = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.IdentitySerializers = exports.IdentitySerializer = exports.JsonSerializers = exports.JsonSerializer = undefined;

          var _invariant2 = _interopRequireDefault(invariant_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          } // JSON serializer

          /**
           * A Serializer transforms data between the application encoding used in
           * Payloads and the Encodable type accepted by the transport client.
           */

          var JsonSerializer = (exports.JsonSerializer = {
            deserialize: function deserialize(data) {
              var str;

              if (data == null) {
                return null;
              } else if (typeof data === 'string') {
                str = data;
              } else if (LiteBuffer_1.LiteBuffer.isBuffer(data)) {
                var buffer = data;
                str = buffer.toString('utf8');
              } else {
                var _buffer = LiteBuffer_1.LiteBuffer.from(data);

                str = _buffer.toString('utf8');
              }

              return JSON.parse(str);
            },
            serialize: JSON.stringify,
          });
          var JsonSerializers = (exports.JsonSerializers = {
            data: JsonSerializer,
            metadata: JsonSerializer,
          }); // Pass-through serializer

          var IdentitySerializer = (exports.IdentitySerializer = {
            deserialize: function deserialize(data) {
              (0, _invariant2['default'])(
                data == null ||
                  typeof data === 'string' ||
                  LiteBuffer_1.LiteBuffer.isBuffer(data) ||
                  data instanceof Uint8Array,
                'RSocketSerialization: Expected data to be a string, Buffer, or ' + 'Uint8Array. Got `%s`.',
                data
              );
              return data;
            },
            serialize: function serialize(data) {
              return data;
            },
          });
          var IdentitySerializers = (exports.IdentitySerializers = {
            data: IdentitySerializer,
            metadata: IdentitySerializer,
          });
        });
        unwrapExports(RSocketSerialization);
        var RSocketSerialization_1 = RSocketSerialization.IdentitySerializers;
        var RSocketSerialization_2 = RSocketSerialization.IdentitySerializer;
        var RSocketSerialization_3 = RSocketSerialization.JsonSerializers;
        var RSocketSerialization_4 = RSocketSerialization.JsonSerializer;
        var RSocketLease = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.ResponderLeaseHandler = exports.RequesterLeaseHandler = exports.Leases = exports.Lease = undefined;

          var _invariant2 = _interopRequireDefault(invariant_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var Lease =
            /*#__PURE__*/
            (function() {
              function Lease(timeToLiveMillis, allowedRequests, metadata) {
                _classCallCheck(this, Lease);

                (0, _invariant2['default'])(timeToLiveMillis > 0, 'Lease time-to-live must be positive');
                (0, _invariant2['default'])(allowedRequests > 0, 'Lease allowed requests must be positive');
                this.timeToLiveMillis = timeToLiveMillis;
                this.allowedRequests = allowedRequests;
                this.startingAllowedRequests = allowedRequests;
                this.expiry = Date.now() + timeToLiveMillis;
                this.metadata = metadata;
              }

              _createClass(Lease, [
                {
                  key: 'expired',
                  value: function expired() {
                    return Date.now() > this.expiry;
                  },
                },
                {
                  key: 'valid',
                  value: function valid() {
                    return this.allowedRequests > 0 && !this.expired();
                  }, // todo hide
                },
                {
                  key: '_use',
                  value: function _use() {
                    if (this.expired()) {
                      return false;
                    }

                    var allowed = this.allowedRequests;
                    var success = allowed > 0;

                    if (success) {
                      this.allowedRequests = allowed - 1;
                    }

                    return success;
                  },
                },
              ]);

              return Lease;
            })();

          exports.Lease = Lease;

          var Leases =
            /*#__PURE__*/
            (function() {
              function Leases() {
                _classCallCheck(this, Leases);

                this._sender = function() {
                  return build.Flowable.never();
                };

                this._receiver = function(leases) {};
              }

              _createClass(Leases, [
                {
                  key: 'sender',
                  value: function sender(_sender) {
                    this._sender = _sender;
                    return this;
                  },
                },
                {
                  key: 'receiver',
                  value: function receiver(_receiver) {
                    this._receiver = _receiver;
                    return this;
                  },
                },
                {
                  key: 'stats',
                  value: function stats(_stats) {
                    this._stats = _stats;
                    return this;
                  },
                },
              ]);

              return Leases;
            })();

          exports.Leases = Leases;

          var RequesterLeaseHandler =
            /*#__PURE__*/
            (function() {
              function RequesterLeaseHandler(leaseReceiver) {
                var _this21 = this;

                _classCallCheck(this, RequesterLeaseHandler);

                this._requestN = -1;
                leaseReceiver(
                  new build.Flowable(function(subscriber) {
                    if (_this21._subscriber) {
                      subscriber.onError(new Error('only 1 subscriber is allowed'));
                      return;
                    }

                    if (_this21.isDisposed()) {
                      subscriber.onComplete();
                      return;
                    }

                    _this21._subscriber = subscriber;
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        _this21.dispose();
                      },
                      request: function request(n) {
                        if (n <= 0) {
                          subscriber.onError(new Error('request demand must be positive: '.concat(n)));
                        }

                        if (!_this21.isDisposed()) {
                          var curReqN = _this21._requestN;

                          _this21._onRequestN(curReqN);

                          _this21._requestN = Math.min(Number.MAX_SAFE_INTEGER, Math.max(0, curReqN) + n);
                        }
                      },
                    });
                  })
                );
              }
              /*negative value means received lease was not signalled due to missing requestN*/

              _createClass(RequesterLeaseHandler, [
                {
                  key: 'use',
                  value: function use() {
                    var l = this._lease;
                    return l ? l._use() : false;
                  },
                },
                {
                  key: 'errorMessage',
                  value: function errorMessage() {
                    return _errorMessage(this._lease);
                  },
                },
                {
                  key: 'receive',
                  value: function receive(frame) {
                    if (!this.isDisposed()) {
                      var timeToLiveMillis = frame.ttl;
                      var requestCount = frame.requestCount;
                      var metadata = frame.metadata;

                      this._onLease(new Lease(timeToLiveMillis, requestCount, metadata));
                    }
                  },
                },
                {
                  key: 'availability',
                  value: function availability() {
                    var l = this._lease;

                    if (l && l.valid()) {
                      return l.allowedRequests / l.startingAllowedRequests;
                    }

                    return 0.0;
                  },
                },
                {
                  key: 'dispose',
                  value: function dispose() {
                    if (!this._isDisposed) {
                      this._isDisposed = true;
                      var s = this._subscriber;

                      if (s) {
                        s.onComplete();
                      }
                    }
                  },
                },
                {
                  key: 'isDisposed',
                  value: function isDisposed() {
                    return this._isDisposed;
                  },
                },
                {
                  key: '_onRequestN',
                  value: function _onRequestN(requestN) {
                    var l = this._lease;
                    var s = this._subscriber;

                    if (requestN < 0 && l && s) {
                      s.onNext(l);
                    }
                  },
                },
                {
                  key: '_onLease',
                  value: function _onLease(lease) {
                    var s = this._subscriber;
                    var newReqN = this._requestN - 1;

                    if (newReqN >= 0 && s) {
                      s.onNext(lease);
                    }

                    this._requestN = Math.max(-1, newReqN);
                    this._lease = lease;
                  },
                },
              ]);

              return RequesterLeaseHandler;
            })();

          exports.RequesterLeaseHandler = RequesterLeaseHandler;

          var ResponderLeaseHandler =
            /*#__PURE__*/
            (function() {
              function ResponderLeaseHandler(leaseSender, stats, errorConsumer) {
                _classCallCheck(this, ResponderLeaseHandler);

                this._leaseSender = leaseSender;
                this._stats = stats;
                this._errorConsumer = errorConsumer;
              }

              _createClass(ResponderLeaseHandler, [
                {
                  key: 'use',
                  value: function use() {
                    var l = this._lease;
                    var success = l ? l._use() : false;

                    this._onStatsEvent(success);

                    return success;
                  },
                },
                {
                  key: 'errorMessage',
                  value: function errorMessage() {
                    return _errorMessage(this._lease);
                  },
                },
                {
                  key: 'send',
                  value: function send(_send) {
                    var _this22 = this;

                    var subscription;

                    var _isDisposed;

                    this._leaseSender(this._stats).subscribe({
                      onComplete: function onComplete() {
                        return _this22._onStatsEvent();
                      },
                      onError: function onError(error) {
                        _this22._onStatsEvent();

                        var errConsumer = _this22._errorConsumer;

                        if (errConsumer) {
                          errConsumer(error);
                        }
                      },
                      onNext: function onNext(lease) {
                        _this22._lease = lease;

                        _send(lease);
                      },
                      onSubscribe: function onSubscribe(s) {
                        if (_isDisposed) {
                          s.cancel();
                          return;
                        }

                        s.request(RSocketFrame.MAX_REQUEST_N);
                        subscription = s;
                      },
                    });

                    return {
                      dispose: function dispose() {
                        if (!_isDisposed) {
                          _isDisposed = true;

                          this._onStatsEvent();

                          if (subscription) {
                            subscription.cancel();
                          }
                        }
                      },
                      isDisposed: function isDisposed() {
                        return _isDisposed;
                      },
                    };
                  },
                },
                {
                  key: '_onStatsEvent',
                  value: function _onStatsEvent(success) {
                    var s = this._stats;

                    if (s) {
                      var event = success === undefined ? 'Terminate' : success ? 'Accept' : 'Reject';
                      s.onEvent(event);
                    }
                  },
                },
              ]);

              return ResponderLeaseHandler;
            })();

          exports.ResponderLeaseHandler = ResponderLeaseHandler;

          function _errorMessage(lease) {
            if (!lease) {
              return 'Lease was not received yet';
            }

            if (lease.valid()) {
              return 'Missing leases';
            } else {
              var isExpired = lease.expired();
              var requests = lease.allowedRequests;
              return 'Missing leases. Expired: '.concat(isExpired.toString(), ', allowedRequests: ').concat(requests);
            }
          }
        });
        unwrapExports(RSocketLease);
        var RSocketLease_1 = RSocketLease.ResponderLeaseHandler;
        var RSocketLease_2 = RSocketLease.RequesterLeaseHandler;
        var RSocketLease_3 = RSocketLease.Leases;
        var RSocketLease_4 = RSocketLease.Lease;
        var RSocketMachine = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.createServerMachine = createServerMachine;
          exports.createClientMachine = createClientMachine;

          var _emptyFunction2 = _interopRequireDefault(emptyFunction_1);

          var _invariant2 = _interopRequireDefault(invariant_1);

          var _warning2 = _interopRequireDefault(warning_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var ResponderWrapper =
            /*#__PURE__*/
            (function() {
              function ResponderWrapper(responder) {
                _classCallCheck(this, ResponderWrapper);

                this._responder = responder || {};
              }

              _createClass(ResponderWrapper, [
                {
                  key: 'setResponder',
                  value: function setResponder(responder) {
                    this._responder = responder || {};
                  },
                },
                {
                  key: 'fireAndForget',
                  value: function fireAndForget(payload) {
                    if (this._responder.fireAndForget) {
                      try {
                        this._responder.fireAndForget(payload);
                      } catch (error) {
                        console.error('fireAndForget threw an exception', error);
                      }
                    }
                  },
                },
                {
                  key: 'requestResponse',
                  value: function requestResponse(payload) {
                    var error;

                    if (this._responder.requestResponse) {
                      try {
                        return this._responder.requestResponse(payload);
                      } catch (_error) {
                        console.error('requestResponse threw an exception', _error);
                        error = _error;
                      }
                    }

                    return build.Single.error(error || new Error('not implemented'));
                  },
                },
                {
                  key: 'requestStream',
                  value: function requestStream(payload) {
                    var error;

                    if (this._responder.requestStream) {
                      try {
                        return this._responder.requestStream(payload);
                      } catch (_error) {
                        console.error('requestStream threw an exception', _error);
                        error = _error;
                      }
                    }

                    return build.Flowable.error(error || new Error('not implemented'));
                  },
                },
                {
                  key: 'requestChannel',
                  value: function requestChannel(payloads) {
                    var error;

                    if (this._responder.requestChannel) {
                      try {
                        return this._responder.requestChannel(payloads);
                      } catch (_error) {
                        console.error('requestChannel threw an exception', _error);
                        error = _error;
                      }
                    }

                    return build.Flowable.error(error || new Error('not implemented'));
                  },
                },
                {
                  key: 'metadataPush',
                  value: function metadataPush(payload) {
                    var error;

                    if (this._responder.metadataPush) {
                      try {
                        return this._responder.metadataPush(payload);
                      } catch (_error) {
                        console.error('metadataPush threw an exception', _error);
                        error = _error;
                      }
                    }

                    return build.Single.error(error || new Error('not implemented'));
                  },
                },
              ]);

              return ResponderWrapper;
            })();

          function createServerMachine(
            connection,
            connectionPublisher,
            serializers,
            requesterLeaseHandler,
            responderLeaseHandler
          ) {
            return new RSocketMachineImpl(
              'SERVER',
              connection,
              connectionPublisher,
              serializers,
              undefined,
              requesterLeaseHandler,
              responderLeaseHandler
            );
          }

          function createClientMachine(
            connection,
            connectionPublisher,
            serializers,
            requestHandler,
            requesterLeaseHandler,
            responderLeaseHandler
          ) {
            return new RSocketMachineImpl(
              'CLIENT',
              connection,
              connectionPublisher,
              serializers,
              requestHandler,
              requesterLeaseHandler,
              responderLeaseHandler
            );
          }

          var RSocketMachineImpl =
            /*#__PURE__*/
            (function() {
              function RSocketMachineImpl(
                role,
                connection,
                connectionPublisher,
                serializers,
                requestHandler,
                requesterLeaseHandler,
                responderLeaseHandler
              ) {
                var _this23 = this;

                _classCallCheck(this, RSocketMachineImpl);

                this._connectionAvailability = 1.0;

                this._handleTransportClose = function() {
                  _this23._handleError(new Error('RSocket: The connection was closed.'));
                };

                this._handleError = function(error) {
                  // Error any open request streams
                  _this23._receivers.forEach(function(receiver) {
                    receiver.onError(error);
                  });

                  _this23._receivers.clear(); // Cancel any active subscriptions

                  _this23._subscriptions.forEach(function(subscription) {
                    subscription.cancel();
                  });

                  _this23._subscriptions.clear();

                  _this23._connectionAvailability = 0.0;

                  _this23._dispose(_this23._requesterLeaseHandler, _this23._responderLeaseSenderDisposable);
                };

                this._handleFrame = function(frame) {
                  var streamId = frame.streamId;

                  if (streamId === RSocketFrame.CONNECTION_STREAM_ID) {
                    _this23._handleConnectionFrame(frame);
                  } else {
                    _this23._handleStreamFrame(streamId, frame);
                  }
                };

                this._connection = connection;
                this._requesterLeaseHandler = requesterLeaseHandler;
                this._responderLeaseHandler = responderLeaseHandler;
                this._nextStreamId = role === 'CLIENT' ? 1 : 2;
                this._receivers = new Map();
                this._subscriptions = new Map();
                this._serializers = serializers || RSocketSerialization.IdentitySerializers;
                this._requestHandler = new ResponderWrapper(requestHandler); // Subscribe to completion/errors before sending anything

                connectionPublisher({
                  onComplete: this._handleTransportClose,
                  onError: this._handleError,
                  onNext: this._handleFrame,
                  onSubscribe: function onSubscribe(subscription) {
                    return subscription.request(Number.MAX_SAFE_INTEGER);
                  },
                });
                var responderHandler = this._responderLeaseHandler;

                if (responderHandler) {
                  this._responderLeaseSenderDisposable = responderHandler.send(this._leaseFrameSender());
                } // Cleanup when the connection closes

                this._connection.connectionStatus().subscribe({
                  onNext: function onNext(status) {
                    if (status.kind === 'CLOSED') {
                      _this23._handleTransportClose();
                    } else if (status.kind === 'ERROR') {
                      _this23._handleError(status.error);
                    }
                  },
                  onSubscribe: function onSubscribe(subscription) {
                    return subscription.request(Number.MAX_SAFE_INTEGER);
                  },
                });
              }

              _createClass(RSocketMachineImpl, [
                {
                  key: 'setRequestHandler',
                  value: function setRequestHandler(requestHandler) {
                    this._requestHandler.setResponder(requestHandler);
                  },
                },
                {
                  key: 'close',
                  value: function close() {
                    this._connection.close();
                  },
                },
                {
                  key: 'connectionStatus',
                  value: function connectionStatus() {
                    return this._connection.connectionStatus();
                  },
                },
                {
                  key: 'availability',
                  value: function availability() {
                    var r = this._requesterLeaseHandler;
                    var requesterAvailability = r ? r.availability() : 1.0;
                    return Math.min(this._connectionAvailability, requesterAvailability);
                  },
                },
                {
                  key: 'fireAndForget',
                  value: function fireAndForget(payload) {
                    if (this._useLeaseOrError(this._requesterLeaseHandler)) {
                      //todo need to signal error to user provided error handler
                      return;
                    }

                    var streamId = this._getNextStreamId(this._receivers);

                    var data = this._serializers.data.serialize(payload.data);

                    var metadata = this._serializers.metadata.serialize(payload.metadata);

                    var frame = {
                      data: data,
                      flags: payload.metadata !== undefined ? RSocketFrame.FLAGS.METADATA : 0,
                      metadata: metadata,
                      streamId: streamId,
                      type: RSocketFrame.FRAME_TYPES.REQUEST_FNF,
                    };

                    this._connection.sendOne(frame);
                  },
                },
                {
                  key: 'requestResponse',
                  value: function requestResponse(payload) {
                    var _this24 = this;

                    var leaseError = this._useLeaseOrError(this._requesterLeaseHandler);

                    if (leaseError) {
                      return build.Single.error(new Error(leaseError));
                    }

                    var streamId = this._getNextStreamId(this._receivers);

                    return new build.Single(function(subscriber) {
                      _this24._receivers.set(streamId, {
                        onComplete: _emptyFunction2['default'],
                        onError: function onError(error) {
                          return subscriber.onError(error);
                        },
                        onNext: function onNext(data) {
                          return subscriber.onComplete(data);
                        },
                      });

                      var data = _this24._serializers.data.serialize(payload.data);

                      var metadata = _this24._serializers.metadata.serialize(payload.metadata);

                      var frame = {
                        data: data,
                        flags: payload.metadata !== undefined ? RSocketFrame.FLAGS.METADATA : 0,
                        metadata: metadata,
                        streamId: streamId,
                        type: RSocketFrame.FRAME_TYPES.REQUEST_RESPONSE,
                      };

                      _this24._connection.sendOne(frame);

                      subscriber.onSubscribe(function() {
                        _this24._receivers['delete'](streamId);

                        var cancelFrame = {
                          flags: 0,
                          streamId: streamId,
                          type: RSocketFrame.FRAME_TYPES.CANCEL,
                        };

                        _this24._connection.sendOne(cancelFrame);
                      });
                    });
                  },
                },
                {
                  key: 'requestStream',
                  value: function requestStream(payload) {
                    var _this25 = this;

                    var leaseError = this._useLeaseOrError(this._requesterLeaseHandler);

                    if (leaseError) {
                      return build.Flowable.error(new Error(leaseError));
                    }

                    var streamId = this._getNextStreamId(this._receivers);

                    return new build.Flowable(function(subscriber) {
                      _this25._receivers.set(streamId, subscriber);

                      var initialized = false;
                      subscriber.onSubscribe({
                        cancel: function cancel() {
                          _this25._receivers['delete'](streamId);

                          if (!initialized) {
                            return;
                          }

                          var cancelFrame = {
                            flags: 0,
                            streamId: streamId,
                            type: RSocketFrame.FRAME_TYPES.CANCEL,
                          };

                          _this25._connection.sendOne(cancelFrame);
                        },
                        request: function request(n) {
                          if (n > RSocketFrame.MAX_REQUEST_N) {
                            n = RSocketFrame.MAX_REQUEST_N;
                          }

                          if (initialized) {
                            var requestNFrame = {
                              flags: 0,
                              requestN: n,
                              streamId: streamId,
                              type: RSocketFrame.FRAME_TYPES.REQUEST_N,
                            };

                            _this25._connection.sendOne(requestNFrame);
                          } else {
                            initialized = true;

                            var data = _this25._serializers.data.serialize(payload.data);

                            var metadata = _this25._serializers.metadata.serialize(payload.metadata);

                            var requestStreamFrame = {
                              data: data,
                              flags: payload.metadata !== undefined ? RSocketFrame.FLAGS.METADATA : 0,
                              metadata: metadata,
                              requestN: n,
                              streamId: streamId,
                              type: RSocketFrame.FRAME_TYPES.REQUEST_STREAM,
                            };

                            _this25._connection.sendOne(requestStreamFrame);
                          }
                        },
                      });
                    }, RSocketFrame.MAX_REQUEST_N);
                  },
                },
                {
                  key: 'requestChannel',
                  value: function requestChannel(payloads) {
                    var _this26 = this;

                    var leaseError = this._useLeaseOrError(this._requesterLeaseHandler);

                    if (leaseError) {
                      return build.Flowable.error(new Error(leaseError));
                    }

                    var streamId = this._getNextStreamId(this._receivers);

                    var payloadsSubscribed = false;
                    return new build.Flowable(function(subscriber) {
                      try {
                        _this26._receivers.set(streamId, subscriber);

                        var initialized = false;
                        subscriber.onSubscribe({
                          cancel: function cancel() {
                            _this26._receivers['delete'](streamId);

                            if (!initialized) {
                              return;
                            }

                            var cancelFrame = {
                              flags: 0,
                              streamId: streamId,
                              type: RSocketFrame.FRAME_TYPES.CANCEL,
                            };

                            _this26._connection.sendOne(cancelFrame);
                          },
                          request: function request(n) {
                            if (n > RSocketFrame.MAX_REQUEST_N) {
                              n = RSocketFrame.MAX_REQUEST_N;
                            }

                            if (initialized) {
                              var requestNFrame = {
                                flags: 0,
                                requestN: n,
                                streamId: streamId,
                                type: RSocketFrame.FRAME_TYPES.REQUEST_N,
                              };

                              _this26._connection.sendOne(requestNFrame);
                            } else {
                              if (!payloadsSubscribed) {
                                payloadsSubscribed = true;
                                payloads.subscribe({
                                  onComplete: function onComplete() {
                                    _this26._sendStreamComplete(streamId);
                                  },
                                  onError: function onError(error) {
                                    _this26._sendStreamError(streamId, error.message);
                                  },
                                  //Subscriber methods
                                  onNext: function onNext(payload) {
                                    var data = _this26._serializers.data.serialize(payload.data);

                                    var metadata = _this26._serializers.metadata.serialize(payload.metadata);

                                    if (!initialized) {
                                      initialized = true;
                                      var requestChannelFrame = {
                                        data: data,
                                        flags: payload.metadata !== undefined ? RSocketFrame.FLAGS.METADATA : 0,
                                        metadata: metadata,
                                        requestN: n,
                                        streamId: streamId,
                                        type: RSocketFrame.FRAME_TYPES.REQUEST_CHANNEL,
                                      };

                                      _this26._connection.sendOne(requestChannelFrame);
                                    } else {
                                      var payloadFrame = {
                                        data: data,
                                        flags:
                                          RSocketFrame.FLAGS.NEXT |
                                          (payload.metadata !== undefined ? RSocketFrame.FLAGS.METADATA : 0),
                                        metadata: metadata,
                                        streamId: streamId,
                                        type: RSocketFrame.FRAME_TYPES.PAYLOAD,
                                      };

                                      _this26._connection.sendOne(payloadFrame);
                                    }
                                  },
                                  onSubscribe: function onSubscribe(subscription) {
                                    _this26._subscriptions.set(streamId, subscription);

                                    subscription.request(1);
                                  },
                                });
                              } else {
                                (0, _warning2['default'])(
                                  false,
                                  'RSocketClient: re-entrant call to request n before initial' + ' channel established.'
                                );
                              }
                            }
                          },
                        });
                      } catch (err) {
                        console.warn('Exception while subscribing to channel flowable:' + err);
                      }
                    }, RSocketFrame.MAX_REQUEST_N);
                  },
                },
                {
                  key: 'metadataPush',
                  value: function metadataPush(payload) {
                    // TODO #18065331: implement metadataPush
                    throw new Error('metadataPush() is not implemented');
                  },
                },
                {
                  key: '_getNextStreamId',
                  value: function _getNextStreamId(streamIds) {
                    var streamId = this._nextStreamId;

                    do {
                      this._nextStreamId = (this._nextStreamId + 2) & RSocketFrame.MAX_STREAM_ID;
                    } while (this._nextStreamId === 0 || streamIds.has(streamId));

                    return streamId;
                  },
                },
                {
                  key: '_useLeaseOrError',
                  value: function _useLeaseOrError(leaseHandler) {
                    if (leaseHandler) {
                      if (!leaseHandler.use()) {
                        return leaseHandler.errorMessage();
                      }
                    }
                  },
                },
                {
                  key: '_leaseFrameSender',
                  value: function _leaseFrameSender() {
                    var _this27 = this;

                    return function(lease) {
                      return _this27._connection.sendOne({
                        flags: 0,
                        metadata: lease.metadata,
                        requestCount: lease.allowedRequests,
                        streamId: RSocketFrame.CONNECTION_STREAM_ID,
                        ttl: lease.timeToLiveMillis,
                        type: RSocketFrame.FRAME_TYPES.LEASE,
                      });
                    };
                  },
                },
                {
                  key: '_dispose',
                  value: function _dispose() {
                    for (
                      var _len4 = arguments.length, disposables = new Array(_len4), _key4 = 0;
                      _key4 < _len4;
                      _key4++
                    ) {
                      disposables[_key4] = arguments[_key4];
                    }

                    disposables.forEach(function(d) {
                      if (d) {
                        d.dispose();
                      }
                    });
                  },
                },
                {
                  key: '_isRequest',
                  value: function _isRequest(frameType) {
                    switch (frameType) {
                      case RSocketFrame.FRAME_TYPES.REQUEST_FNF:
                      case RSocketFrame.FRAME_TYPES.REQUEST_RESPONSE:
                      case RSocketFrame.FRAME_TYPES.REQUEST_STREAM:
                      case RSocketFrame.FRAME_TYPES.REQUEST_CHANNEL:
                        return true;

                      default:
                        return false;
                    }
                  },
                  /**
                   * Handle the connection closing normally: this is an error for any open streams.
                   */

                  /**
                   * Handle the transport connection closing abnormally or a connection-level protocol error.
                   */
                },
                {
                  key: '_handleConnectionError',
                  value: function _handleConnectionError(error) {
                    this._handleError(error);

                    this._connection.close();
                  },
                  /**
                   * Handle a frame received from the transport client.
                   */

                  /**
                   * Handle connection frames (stream id === 0).
                   */
                },
                {
                  key: '_handleConnectionFrame',
                  value: function _handleConnectionFrame(frame) {
                    switch (frame.type) {
                      case RSocketFrame.FRAME_TYPES.ERROR:
                        var error = (0, RSocketFrame.createErrorFromFrame)(frame);

                        this._handleConnectionError(error);

                        break;

                      case RSocketFrame.FRAME_TYPES.EXT:
                        // Extensions are not supported
                        break;

                      case RSocketFrame.FRAME_TYPES.KEEPALIVE:
                        if ((0, RSocketFrame.isRespond)(frame.flags)) {
                          this._connection.sendOne(
                            Object.assign({}, frame, {
                              flags: frame.flags ^ RSocketFrame.FLAGS.RESPOND,
                              // eslint-disable-line no-bitwise
                              lastReceivedPosition: 0,
                            })
                          );
                        }

                        break;

                      case RSocketFrame.FRAME_TYPES.LEASE:
                        var r = this._requesterLeaseHandler;

                        if (r) {
                          r.receive(frame);
                        }

                        break;

                      case RSocketFrame.FRAME_TYPES.METADATA_PUSH:
                      case RSocketFrame.FRAME_TYPES.REQUEST_CHANNEL:
                      case RSocketFrame.FRAME_TYPES.REQUEST_FNF:
                      case RSocketFrame.FRAME_TYPES.REQUEST_RESPONSE:
                      case RSocketFrame.FRAME_TYPES.REQUEST_STREAM:
                        // TODO #18064706: handle requests from server
                        break;

                      case RSocketFrame.FRAME_TYPES.RESERVED:
                        // No-op
                        break;

                      case RSocketFrame.FRAME_TYPES.RESUME:
                      case RSocketFrame.FRAME_TYPES.RESUME_OK:
                        // TODO #18065016: support resumption
                        break;
                    }
                  },
                  /**
                   * Handle stream-specific frames (stream id !== 0).
                   */
                },
                {
                  key: '_handleStreamFrame',
                  value: function _handleStreamFrame(streamId, frame) {
                    if (this._isRequest(frame.type)) {
                      var leaseError = this._useLeaseOrError(this._responderLeaseHandler);

                      if (leaseError) {
                        this._sendStreamError(streamId, leaseError);

                        return;
                      }
                    }

                    switch (frame.type) {
                      case RSocketFrame.FRAME_TYPES.CANCEL:
                        this._handleCancel(streamId, frame);

                        break;

                      case RSocketFrame.FRAME_TYPES.REQUEST_N:
                        this._handleRequestN(streamId, frame);

                        break;

                      case RSocketFrame.FRAME_TYPES.REQUEST_FNF:
                        this._handleFireAndForget(streamId, frame);

                        break;

                      case RSocketFrame.FRAME_TYPES.REQUEST_RESPONSE:
                        this._handleRequestResponse(streamId, frame);

                        break;

                      case RSocketFrame.FRAME_TYPES.REQUEST_STREAM:
                        this._handleRequestStream(streamId, frame);

                        break;

                      case RSocketFrame.FRAME_TYPES.REQUEST_CHANNEL:
                        this._handleRequestChannel(streamId, frame);

                        break;

                      case RSocketFrame.FRAME_TYPES.ERROR:
                        var error = (0, RSocketFrame.createErrorFromFrame)(frame);

                        this._handleStreamError(streamId, error);

                        break;

                      case RSocketFrame.FRAME_TYPES.PAYLOAD:
                        var receiver = this._receivers.get(streamId);

                        if (receiver != null) {
                          if ((0, RSocketFrame.isNext)(frame.flags)) {
                            var payload = {
                              data: this._serializers.data.deserialize(frame.data),
                              metadata: this._serializers.metadata.deserialize(frame.metadata),
                            };
                            receiver.onNext(payload);
                          }

                          if ((0, RSocketFrame.isComplete)(frame.flags)) {
                            this._receivers['delete'](streamId);

                            receiver.onComplete();
                          }
                        }

                        break;
                    }
                  },
                },
                {
                  key: '_handleCancel',
                  value: function _handleCancel(streamId, frame) {
                    var subscription = this._subscriptions.get(streamId);

                    if (subscription) {
                      subscription.cancel();

                      this._subscriptions['delete'](streamId);
                    }
                  },
                },
                {
                  key: '_handleRequestN',
                  value: function _handleRequestN(streamId, frame) {
                    var subscription = this._subscriptions.get(streamId);

                    if (subscription) {
                      subscription.request(frame.requestN);
                    }
                  },
                },
                {
                  key: '_handleFireAndForget',
                  value: function _handleFireAndForget(streamId, frame) {
                    var payload = this._deserializePayload(frame);

                    this._requestHandler.fireAndForget(payload);
                  },
                },
                {
                  key: '_handleRequestResponse',
                  value: function _handleRequestResponse(streamId, frame) {
                    var _this28 = this;

                    var payload = this._deserializePayload(frame);

                    this._requestHandler.requestResponse(payload).subscribe({
                      onComplete: function onComplete(payload) {
                        _this28._sendStreamPayload(streamId, payload, true);
                      },
                      onError: function onError(error) {
                        return _this28._sendStreamError(streamId, error.message);
                      },
                      onSubscribe: function onSubscribe(cancel) {
                        var subscription = {
                          cancel: cancel,
                          request: _emptyFunction2['default'],
                        };

                        _this28._subscriptions.set(streamId, subscription);
                      },
                    });
                  },
                },
                {
                  key: '_handleRequestStream',
                  value: function _handleRequestStream(streamId, frame) {
                    var _this29 = this;

                    var payload = this._deserializePayload(frame);

                    this._requestHandler.requestStream(payload).subscribe({
                      onComplete: function onComplete() {
                        return _this29._sendStreamComplete(streamId);
                      },
                      onError: function onError(error) {
                        return _this29._sendStreamError(streamId, error.message);
                      },
                      onNext: function onNext(payload) {
                        return _this29._sendStreamPayload(streamId, payload);
                      },
                      onSubscribe: function onSubscribe(subscription) {
                        _this29._subscriptions.set(streamId, subscription);

                        subscription.request(frame.requestN);
                      },
                    });
                  },
                },
                {
                  key: '_handleRequestChannel',
                  value: function _handleRequestChannel(streamId, frame) {
                    var _this30 = this;

                    var existingSubscription = this._subscriptions.get(streamId);

                    if (existingSubscription) {
                      //Likely a duplicate REQUEST_CHANNEL frame, ignore per spec
                      return;
                    }

                    var payloads = new build.Flowable(function(subscriber) {
                      var firstRequest = true;
                      subscriber.onSubscribe({
                        cancel: function cancel() {
                          _this30._receivers['delete'](streamId);

                          var cancelFrame = {
                            flags: 0,
                            streamId: streamId,
                            type: RSocketFrame.FRAME_TYPES.CANCEL,
                          };

                          _this30._connection.sendOne(cancelFrame);
                        },
                        request: function request(n) {
                          if (n > RSocketFrame.MAX_REQUEST_N) {
                            n = RSocketFrame.MAX_REQUEST_N;
                          }

                          if (firstRequest) {
                            n--;
                          }

                          if (n > 0) {
                            var requestNFrame = {
                              flags: 0,
                              requestN: n,
                              streamId: streamId,
                              type: RSocketFrame.FRAME_TYPES.REQUEST_N,
                            };

                            _this30._connection.sendOne(requestNFrame);
                          } //critically, if n is 0 now, that's okay because we eagerly decremented it

                          if (firstRequest && n >= 0) {
                            firstRequest = false; //release the initial frame we received in frame form due to map operator

                            subscriber.onNext(frame);
                          }
                        },
                      });
                    }, RSocketFrame.MAX_REQUEST_N);
                    var framesToPayloads = new build.FlowableProcessor(payloads, function(frame) {
                      return _this30._deserializePayload(frame);
                    });

                    this._receivers.set(streamId, framesToPayloads);

                    this._requestHandler.requestChannel(framesToPayloads).subscribe({
                      onComplete: function onComplete() {
                        return _this30._sendStreamComplete(streamId);
                      },
                      onError: function onError(error) {
                        return _this30._sendStreamError(streamId, error.message);
                      },
                      onNext: function onNext(payload) {
                        return _this30._sendStreamPayload(streamId, payload);
                      },
                      onSubscribe: function onSubscribe(subscription) {
                        _this30._subscriptions.set(streamId, subscription);

                        subscription.request(frame.requestN);
                      },
                    });
                  },
                },
                {
                  key: '_sendStreamComplete',
                  value: function _sendStreamComplete(streamId) {
                    this._subscriptions['delete'](streamId);

                    this._connection.sendOne({
                      data: null,
                      flags: RSocketFrame.FLAGS.COMPLETE,
                      metadata: null,
                      streamId: streamId,
                      type: RSocketFrame.FRAME_TYPES.PAYLOAD,
                    });
                  },
                },
                {
                  key: '_sendStreamError',
                  value: function _sendStreamError(streamId, errorMessage) {
                    this._subscriptions['delete'](streamId);

                    this._connection.sendOne({
                      code: RSocketFrame.ERROR_CODES.APPLICATION_ERROR,
                      flags: 0,
                      message: errorMessage,
                      streamId: streamId,
                      type: RSocketFrame.FRAME_TYPES.ERROR,
                    });
                  },
                },
                {
                  key: '_sendStreamPayload',
                  value: function _sendStreamPayload(streamId, payload) {
                    var complete = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var flags = RSocketFrame.FLAGS.NEXT;

                    if (complete) {
                      // eslint-disable-next-line no-bitwise
                      flags |= RSocketFrame.FLAGS.COMPLETE;

                      this._subscriptions['delete'](streamId);
                    }

                    var data = this._serializers.data.serialize(payload.data);

                    var metadata = this._serializers.metadata.serialize(payload.metadata);

                    this._connection.sendOne({
                      data: data,
                      flags: flags,
                      metadata: metadata,
                      streamId: streamId,
                      type: RSocketFrame.FRAME_TYPES.PAYLOAD,
                    });
                  },
                },
                {
                  key: '_deserializePayload',
                  value: function _deserializePayload(frame) {
                    return deserializePayload(this._serializers, frame);
                  },
                  /**
                   * Handle an error specific to a stream.
                   */
                },
                {
                  key: '_handleStreamError',
                  value: function _handleStreamError(streamId, error) {
                    var receiver = this._receivers.get(streamId);

                    if (receiver != null) {
                      this._receivers['delete'](streamId);

                      receiver.onError(error);
                    }
                  },
                },
              ]);

              return RSocketMachineImpl;
            })();

          function deserializePayload(serializers, frame) {
            return {
              data: serializers.data.deserialize(frame.data),
              metadata: serializers.metadata.deserialize(frame.metadata),
            };
          }
        });
        unwrapExports(RSocketMachine);
        var RSocketMachine_1 = RSocketMachine.createServerMachine;
        var RSocketMachine_2 = RSocketMachine.createClientMachine;
        var RSocketClient_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _invariant2 = _interopRequireDefault(invariant_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * RSocketClient: A client in an RSocket connection that will communicates with
           * the peer via the given transport client. Provides methods for establishing a
           * connection and initiating the RSocket interactions:
           * - fireAndForget()
           * - requestResponse()
           * - requestStream()
           * - requestChannel()
           * - metadataPush()
           */

          var RSocketClient =
            /*#__PURE__*/
            (function() {
              function RSocketClient(config) {
                _classCallCheck(this, RSocketClient);

                this._cancel = null;
                this._config = config;
                this._connection = null;
                this._socket = null;
              }

              _createClass(RSocketClient, [
                {
                  key: 'close',
                  value: function close() {
                    this._config.transport.close();
                  },
                },
                {
                  key: 'connect',
                  value: function connect() {
                    var _this31 = this;

                    (0, _invariant2['default'])(
                      !this._connection,
                      'RSocketClient: Unexpected call to connect(), already connected.'
                    );
                    this._connection = new build.Single(function(subscriber) {
                      var transport = _this31._config.transport;
                      var subscription;
                      transport.connectionStatus().subscribe({
                        onNext: function onNext(status) {
                          if (status.kind === 'CONNECTED') {
                            subscription && subscription.cancel();
                            subscriber.onComplete(new RSocketClientSocket(_this31._config, transport));
                          } else if (status.kind === 'ERROR') {
                            subscription && subscription.cancel();
                            subscriber.onError(status.error);
                          } else if (status.kind === 'CLOSED') {
                            subscription && subscription.cancel();
                            subscriber.onError(new Error('RSocketClient: Connection closed.'));
                          }
                        },
                        onSubscribe: function onSubscribe(_subscription) {
                          subscriber.onSubscribe(function() {
                            return _subscription.cancel();
                          });
                          subscription = _subscription;
                          subscription.request(Number.MAX_SAFE_INTEGER);
                        },
                      });
                      transport.connect();
                    });
                    return this._connection;
                  },
                },
              ]);

              return RSocketClient;
            })();

          exports['default'] = RSocketClient;
          /**
           * @private
           */

          var RSocketClientSocket =
            /*#__PURE__*/
            (function() {
              function RSocketClientSocket(config, connection) {
                _classCallCheck(this, RSocketClientSocket);

                var requesterLeaseHandler;
                var responderLeaseHandler;
                var leasesSupplier = config.leases;

                if (leasesSupplier) {
                  var lease = leasesSupplier();
                  requesterLeaseHandler = new RSocketLease.RequesterLeaseHandler(lease._receiver);
                  responderLeaseHandler = new RSocketLease.ResponderLeaseHandler(lease._sender, lease._stats);
                }

                this._machine = (0, RSocketMachine.createClientMachine)(
                  connection,
                  function(subscriber) {
                    return connection.receive().subscribe(subscriber);
                  },
                  config.serializers,
                  config.responder,
                  requesterLeaseHandler,
                  responderLeaseHandler
                ); // Send SETUP

                connection.sendOne(this._buildSetupFrame(config)); // Send KEEPALIVE frames

                var keepAlive = config.setup.keepAlive;
                var navigator = config.navigator;

                if (
                  keepAlive > 30000 &&
                  navigator &&
                  navigator.userAgent &&
                  (navigator.userAgent.includes('Trident') || navigator.userAgent.includes('Edg'))
                ) {
                  console.warn(
                    'rsocket-js: Due to a browser bug, Internet Explorer and Edge users may experience WebSocket instability with keepAlive values longer than 30 seconds.'
                  );
                }

                var keepAliveFrames = (0, build.every)(keepAlive).map(function() {
                  return {
                    data: null,
                    flags: RSocketFrame.FLAGS.RESPOND,
                    lastReceivedPosition: 0,
                    streamId: RSocketFrame.CONNECTION_STREAM_ID,
                    type: RSocketFrame.FRAME_TYPES.KEEPALIVE,
                  };
                });
                connection.send(keepAliveFrames);
              }

              _createClass(RSocketClientSocket, [
                {
                  key: 'fireAndForget',
                  value: function fireAndForget(payload) {
                    this._machine.fireAndForget(payload);
                  },
                },
                {
                  key: 'requestResponse',
                  value: function requestResponse(payload) {
                    return this._machine.requestResponse(payload);
                  },
                },
                {
                  key: 'requestStream',
                  value: function requestStream(payload) {
                    return this._machine.requestStream(payload);
                  },
                },
                {
                  key: 'requestChannel',
                  value: function requestChannel(payloads) {
                    return this._machine.requestChannel(payloads);
                  },
                },
                {
                  key: 'metadataPush',
                  value: function metadataPush(payload) {
                    return this._machine.metadataPush(payload);
                  },
                },
                {
                  key: 'close',
                  value: function close() {
                    this._machine.close();
                  },
                },
                {
                  key: 'connectionStatus',
                  value: function connectionStatus() {
                    return this._machine.connectionStatus();
                  },
                },
                {
                  key: 'availability',
                  value: function availability() {
                    return this._machine.availability();
                  },
                },
                {
                  key: '_buildSetupFrame',
                  value: function _buildSetupFrame(config) {
                    var _config$setup = config.setup,
                      dataMimeType = _config$setup.dataMimeType,
                      keepAlive = _config$setup.keepAlive,
                      lifetime = _config$setup.lifetime,
                      metadata = _config$setup.metadata,
                      metadataMimeType = _config$setup.metadataMimeType,
                      data = _config$setup.data;
                    var flags = 0;

                    if (metadata !== undefined) {
                      flags |= RSocketFrame.FLAGS.METADATA;
                    }

                    return {
                      data: data,
                      dataMimeType: dataMimeType,
                      flags: flags | (config.leases ? RSocketFrame.FLAGS.LEASE : 0),
                      keepAlive: keepAlive,
                      lifetime: lifetime,
                      majorVersion: RSocketVersion.MAJOR_VERSION,
                      metadata: metadata,
                      metadataMimeType: metadataMimeType,
                      minorVersion: RSocketVersion.MINOR_VERSION,
                      resumeToken: null,
                      streamId: RSocketFrame.CONNECTION_STREAM_ID,
                      type: RSocketFrame.FRAME_TYPES.SETUP,
                    };
                  },
                },
              ]);

              return RSocketClientSocket;
            })();
        });
        var RSocketClient = unwrapExports(RSocketClient_1); // @ts-ignore

        var remoteResponse = function remoteResponse(_a) {
          var address = _a.address,
            asyncModel = _a.asyncModel,
            message = _a.message,
            transportClientProvider = _a.transportClientProvider,
            microserviceContext = _a.microserviceContext;
          return new _rxjs.Observable(function(observer) {
            var connection = getClientConnection({
              address: address,
              transportClientProvider: transportClientProvider,
              microserviceContext: microserviceContext,
            });
            connection.then(function(socket) {
              var socketConnect = socket[asyncModel]({
                data: message,
                metadata: '',
              });

              var flowableNext = function flowableNext(_a) {
                var data = _a.data,
                  metadata = _a.metadata;
                observer.next(data);
              };

              var flowableError = function flowableError(err) {
                if (err && err.source && err.source.message) {
                  var _a = err.source.message,
                    metadata = _a.metadata,
                    data = _a.data;
                  observer.error(metadata && metadata.isErrorFormat === true ? new Error(data) : data);
                } else {
                  observer.error(new Error('RemoteCall exception occur.'));
                }
              };

              switch (asyncModel) {
                case ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE:
                  socketConnect.subscribe({
                    onComplete: flowableNext,
                    onError: flowableError,
                  }); // Single type

                  break;

                case ASYNC_MODEL_TYPES$1.REQUEST_STREAM:
                  var max_1 = socketConnect._max;
                  socketConnect.subscribe({
                    onNext: flowableNext,
                    onError: flowableError,
                    onComplete: function onComplete() {
                      return observer.complete();
                    },
                    onSubscribe: function onSubscribe(subscription) {
                      subscription.request(max_1);
                    },
                  }); // Flowable type

                  break;

                default:
                  observer.error(new Error('Unable to find asyncModel'));
              }

              socket.connectionStatus().subscribe(function(_a) {
                var kind = _a.kind,
                  error = _a.error;

                if (kind.toUpperCase() === RSocketConnectionStatus.ERROR) {
                  destoryClientConnection(getFullAddress(address), microserviceContext);
                  observer.error(error);
                }
              });
            });
          });
        };

        var getClientConnection = function getClientConnection(_a) {
          var address = _a.address,
            transportClientProvider = _a.transportClientProvider,
            microserviceContext = _a.microserviceContext;
          var fullAddress = getFullAddress(address);
          var connectionManager = microserviceContext.connectionManager;
          var connection = connectionManager.getConnection(fullAddress);

          if (!connection) {
            var client_1 = createClient({
              address: address,
              transportClientProvider: transportClientProvider,
            });
            connection = new Promise(function(resolve, reject) {
              client_1.connect().subscribe({
                onComplete: function onComplete(socket) {
                  return resolve(socket);
                },
                onError: function onError(error) {
                  return reject(error);
                },
              });
            });
            connectionManager.setConnection(fullAddress, connection);
          }

          return connection;
        };

        var createClient = function createClient(_a) {
          var address = _a.address,
            transportClientProvider = _a.transportClientProvider;
          var factoryOptions = transportClientProvider.factoryOptions,
            providerFactory = transportClientProvider.providerFactory,
            serializers = transportClientProvider.serializers,
            setup = transportClientProvider.setup;
          return new RSocketClient({
            serializers: serializers,
            setup: {
              dataMimeType: (setup && setup.dataMimeType) || 'text/plain',
              keepAlive: (setup && setup.keepAlive) || 1000000,
              lifetime: (setup && setup.lifetime) || 1000000,
              metadataMimeType: (setup && setup.metadataMimeType) || 'text/plain',
            },
            transport: providerFactory({
              address: address,
              factoryOptions: factoryOptions,
            }),
          });
        };

        var destoryClientConnection = function destoryClientConnection(fullAddress, microserviceContext) {
          var connectionManager = microserviceContext.connectionManager,
            whoAmI = microserviceContext.whoAmI,
            debug = microserviceContext.debug;
          var connection = connectionManager.getConnection(fullAddress);

          if (connection) {
            connection.then(function(socket) {
              try {
                socket.close();
              } catch (e) {
                saveToLogs(whoAmI, 'RSocket unable to close connection ' + e, {}, debug, 'warn');
              }

              connectionManager.removeConnection(fullAddress);
            });
          }
        };

        var destroyAllClientConnections = function destroyAllClientConnections(microserviceContext) {
          var connectionManager = microserviceContext.connectionManager;
          Object.keys(connectionManager.getAllConnections()).forEach(function(key) {
            return destoryClientConnection(key, microserviceContext);
          });
        };

        var remoteCall = function remoteCall(_a) {
          var router = _a.router,
            microserviceContext = _a.microserviceContext,
            message = _a.message,
            asyncModel = _a.asyncModel,
            transportClientProvider = _a.transportClientProvider;
          return new _rxjs.Observable(function(obs) {
            router({
              lookUp: microserviceContext.remoteRegistry.lookUp,
              message: message,
            })
              .then(function(endPoint) {
                var asyncModelProvider = endPoint.asyncModel;

                if (asyncModelProvider !== asyncModel) {
                  obs.error(
                    serviceCallError({
                      errorMessage: getAsyncModelMissmatch(asyncModel, asyncModelProvider),
                      microserviceContext: microserviceContext,
                    })
                  );
                }

                if (!transportClientProvider) {
                  obs.error(
                    serviceCallError({
                      errorMessage: TRANSPORT_NOT_PROVIDED,
                      microserviceContext: microserviceContext,
                    })
                  );
                } else {
                  remoteResponse({
                    address: endPoint.address,
                    asyncModel: asyncModel,
                    message: message,
                    transportClientProvider: transportClientProvider,
                    microserviceContext: microserviceContext,
                  }).subscribe(obs);
                }
              })
              ['catch'](function() {
                obs.error(
                  serviceCallError({
                    errorMessage: getNotFoundByRouterError(microserviceContext.whoAmI, message.qualifier),
                    microserviceContext: microserviceContext,
                  })
                );
              });
          });
        };

        var getServiceCall = function getServiceCall(_a) {
          var router = _a.router,
            microserviceContext = _a.microserviceContext,
            transportClientProvider = _a.transportClientProvider;
          return function(_a) {
            var message = _a.message,
              asyncModel = _a.asyncModel,
              messageFormat = _a.messageFormat;

            try {
              validateMessage(message);
            } catch (e) {
              var err = serviceCallError({
                errorMessage: e.message,
                microserviceContext: microserviceContext,
              });
              return asyncModel === ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE
                ? Promise.reject(err)
                : (0, _rxjs.throwError)(err);
            }

            var localService = microserviceContext.localRegistry.lookUp({
              qualifier: message.qualifier,
            });
            var res$ = localService
              ? localCall({
                  localService: localService,
                  asyncModel: asyncModel,
                  messageFormat: messageFormat,
                  message: message,
                  microserviceContext: microserviceContext,
                })
              : remoteCall({
                  router: router,
                  microserviceContext: microserviceContext,
                  message: message,
                  asyncModel: asyncModel,
                  transportClientProvider: transportClientProvider,
                });
            return asyncModel === ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE ? res$.pipe(take(1)).toPromise() : res$;
          };
        };

        var _createServiceCall = function createServiceCall(_a) {
          var router = _a.router,
            microserviceContext = _a.microserviceContext,
            transportClientProvider = _a.transportClientProvider;

          if (!microserviceContext) {
            throw new Error(MICROSERVICE_NOT_EXISTS);
          }

          var serviceCall = getServiceCall({
            router: router,
            microserviceContext: microserviceContext,
            transportClientProvider: transportClientProvider,
          });
          return Object.freeze({
            requestStream: function requestStream(message, messageFormat) {
              if (messageFormat === void 0) {
                messageFormat = false;
              }

              return serviceCall({
                message: message,
                asyncModel: ASYNC_MODEL_TYPES$1.REQUEST_STREAM,
                messageFormat: messageFormat,
              });
            },
            requestResponse: function requestResponse(message, messageFormat) {
              if (messageFormat === void 0) {
                messageFormat = false;
              }

              return serviceCall({
                message: message,
                asyncModel: ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE,
                messageFormat: messageFormat,
              });
            },
          });
        };

        var createRemoteRegistry = function createRemoteRegistry() {
          var remoteRegistryMap = {};
          return Object.freeze({
            lookUp: function lookUp(_a) {
              var qualifier = _a.qualifier;

              if (!remoteRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
              }

              return remoteRegistryMap[qualifier] || [];
            },
            createEndPoints: function createEndPoints(options) {
              if (!remoteRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
              }

              return getEndpointsFromServices(options); // all services => endPoints[]
            },
            update: function update(_a) {
              var type = _a.type,
                items = _a.items;

              if (type === 'IDLE') {
                return;
              }

              if (!remoteRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
              }

              remoteRegistryMap = updatedRemoteRegistry({
                type: type,
                items: items,
                remoteRegistryMap: remoteRegistryMap,
              });
            },
            destroy: function destroy() {
              remoteRegistryMap = null;
            },
          });
        }; // Helpers

        var getEndpointsFromServices = function getEndpointsFromServices(options) {
          var services = options.services,
            address = options.address;
          return services && address
            ? services.reduce(function(res, service) {
                return res.concat(
                  getEndpointsFromService({
                    service: service,
                    address: address,
                  })
                );
              }, [])
            : [];
        };

        var updatedRemoteRegistry = function updatedRemoteRegistry(_a) {
          var type = _a.type,
            items = _a.items,
            remoteRegistryMap = _a.remoteRegistryMap;

          switch (type) {
            case 'REGISTERED':
              remoteRegistryMap = items.reduce(function(res, endpoint) {
                var _a;

                return _assign$1(
                  {},
                  res,
                  ((_a = {}), (_a[endpoint.qualifier] = (res[endpoint.qualifier] || []).concat([endpoint])), _a)
                );
              }, remoteRegistryMap || {});
              break;

            case 'UNREGISTERED':
              items.forEach(function(unregisteredEndpoint) {
                remoteRegistryMap[unregisteredEndpoint.qualifier] = remoteRegistryMap[
                  unregisteredEndpoint.qualifier
                ].filter(function(registryEndpoint) {
                  return getFullAddress(registryEndpoint.address) !== getFullAddress(unregisteredEndpoint.address);
                });
              });
              break;
          }

          return _assign$1({}, remoteRegistryMap);
        };

        var getEndpointsFromService = function getEndpointsFromService(_a) {
          var service = _a.service,
            address = _a.address;
          var definition = service.definition;
          var serviceName = definition.serviceName,
            methods = definition.methods;
          return (
            Object.keys(methods).map(function(methodName) {
              return {
                qualifier: getQualifier({
                  serviceName: serviceName,
                  methodName: methodName,
                }),
                serviceName: serviceName,
                methodName: methodName,
                asyncModel: methods[methodName].asyncModel,
                address: address,
              };
            }) || []
          );
        };

        var getReferencePointer = function getReferencePointer(_a) {
          var reference = _a.reference,
            methodName = _a.methodName;
          var methodRef = reference[methodName];

          if (methodRef) {
            return methodRef.bind(reference);
          } // static method

          return reference.constructor && reference.constructor[methodName];
        };

        var flatteningServices = function flatteningServices(_a) {
          var services = _a.services,
            serviceFactoryOptions = _a.serviceFactoryOptions;
          return services && Array.isArray(services)
            ? services.map(function(service) {
                var reference = service.reference,
                  definition = service.definition;

                if (isFunction(reference)) {
                  var ref = reference(serviceFactoryOptions);
                  validateServiceReference(ref, definition);
                  return {
                    reference: ref,
                    definition: definition,
                  };
                } else {
                  validateServiceReference(reference, definition);
                  return {
                    reference: reference,
                    definition: definition,
                  };
                }
              })
            : services;
        };

        var createLocalRegistry = function createLocalRegistry() {
          var localRegistryMap = {};
          return Object.freeze({
            lookUp: function lookUp(_a) {
              var qualifier = _a.qualifier;

              if (!localRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
              }

              return localRegistryMap[qualifier] || null;
            },
            add: function add(_a) {
              var _b = _a.services,
                services = _b === void 0 ? [] : _b;

              if (!localRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
              }

              var references = getReferenceFromServices({
                services: services,
              });
              localRegistryMap = getUpdatedLocalRegistry({
                localRegistryMap: localRegistryMap,
                references: references,
              });
            },
            destroy: function destroy() {
              localRegistryMap = null;
            },
          });
        }; // Helpers

        var getReferenceFromServices = function getReferenceFromServices(_a) {
          var _b = _a.services,
            services = _b === void 0 ? [] : _b;
          return services.reduce(function(res, service) {
            return res.concat(
              getReferenceFromService({
                service: service,
              })
            );
          }, []);
        };

        var getUpdatedLocalRegistry = function getUpdatedLocalRegistry(_a) {
          var localRegistryMap = _a.localRegistryMap,
            references = _a.references;
          return _assign$1(
            {},
            localRegistryMap,
            references.reduce(function(res, reference) {
              var _a;

              return _assign$1({}, res, ((_a = {}), (_a[reference.qualifier] = reference), _a));
            }, localRegistryMap || {})
          );
        };

        var getReferenceFromService = function getReferenceFromService(_a) {
          var service = _a.service;
          var data = [];
          var definition = service.definition,
            reference = service.reference;
          var serviceName = definition.serviceName,
            methods = definition.methods;
          Object.keys(methods).forEach(function(methodName) {
            var _a;

            var qualifier = getQualifier({
              serviceName: serviceName,
              methodName: methodName,
            });
            data.push({
              qualifier: qualifier,
              serviceName: serviceName,
              methodName: methodName,
              asyncModel: methods[methodName].asyncModel,
              reference:
                ((_a = {}),
                (_a[methodName] = getReferencePointer({
                  reference: reference,
                  methodName: methodName,
                })),
                _a),
            });
          });
          return data;
        };

        var RSocketServer_1 = createCommonjsModule(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _invariant2 = _interopRequireDefault(invariant_1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * RSocketServer: A server in an RSocket connection that accepts connections
           * from peers via the given transport server.
           */

          var RSocketServer =
            /*#__PURE__*/
            (function() {
              function RSocketServer(config) {
                var _this32 = this;

                _classCallCheck(this, RSocketServer);

                this._handleTransportComplete = function() {
                  _this32._handleTransportError(new Error('RSocketServer: Connection closed unexpectedly.'));
                };

                this._handleTransportError = function(error) {
                  _this32._connections.forEach(function(connection) {
                    // TODO: Allow passing in error
                    connection.close();
                  });
                };

                this._handleTransportConnection = function(connection) {
                  var swapper = new SubscriberSwapper();
                  var subscription;
                  connection.receive().subscribe(
                    swapper.swap({
                      onError: function onError(error) {
                        return console.error(error);
                      },
                      onNext: function onNext(frame) {
                        switch (frame.type) {
                          case RSocketFrame.FRAME_TYPES.RESUME:
                            connection.sendOne({
                              code: RSocketFrame.ERROR_CODES.REJECTED_RESUME,
                              flags: 0,
                              message: 'RSocketServer: RESUME not supported.',
                              streamId: RSocketFrame.CONNECTION_STREAM_ID,
                              type: RSocketFrame.FRAME_TYPES.ERROR,
                            });
                            connection.close();
                            break;

                          case RSocketFrame.FRAME_TYPES.SETUP:
                            if (_this32._setupLeaseError(frame)) {
                              connection.sendOne({
                                code: RSocketFrame.ERROR_CODES.INVALID_SETUP,
                                flags: 0,
                                message: 'RSocketServer: LEASE not supported.',
                                streamId: RSocketFrame.CONNECTION_STREAM_ID,
                                type: RSocketFrame.FRAME_TYPES.ERROR,
                              });
                              connection.close();
                              break;
                            }

                            var _serializers = _this32._getSerializers();

                            var requesterLeaseHandler;
                            var responderLeaseHandler;
                            var leasesSupplier = _this32._config.leases;

                            if (leasesSupplier) {
                              var lease = leasesSupplier();
                              requesterLeaseHandler = new RSocketLease.RequesterLeaseHandler(lease._receiver);
                              responderLeaseHandler = new RSocketLease.ResponderLeaseHandler(
                                lease._sender,
                                lease._stats
                              );
                            }

                            var serverMachine = (0, RSocketMachine.createServerMachine)(
                              connection,
                              function(subscriber) {
                                swapper.swap(subscriber);
                              },
                              _serializers,
                              requesterLeaseHandler,
                              responderLeaseHandler
                            );

                            try {
                              var requestHandler = _this32._config.getRequestHandler(
                                serverMachine,
                                deserializePayload(_serializers, frame)
                              );

                              serverMachine.setRequestHandler(requestHandler);

                              _this32._connections.add(serverMachine);
                            } catch (error) {
                              connection.sendOne({
                                code: RSocketFrame.ERROR_CODES.REJECTED_SETUP,
                                flags: 0,
                                message: 'Application rejected setup, reason: ' + error.message,
                                streamId: RSocketFrame.CONNECTION_STREAM_ID,
                                type: RSocketFrame.FRAME_TYPES.ERROR,
                              });
                              connection.close();
                            } // TODO(blom): We should subscribe to connection status
                            // so we can remove the connection when it goes away

                            break;

                          default:
                            (0, _invariant2['default'])(
                              false,
                              'RSocketServer: Expected first frame to be SETUP or RESUME, ' + 'got `%s`.',
                              (0, RSocketFrame.getFrameTypeName)(frame.type)
                            );
                        }
                      },
                      onSubscribe: function onSubscribe(_subscription) {
                        subscription = _subscription;
                        subscription.request(1);
                      },
                    })
                  );
                };

                this._config = config;
                this._connections = new Set();
                this._started = false;
                this._subscription = null;
              }

              _createClass(RSocketServer, [
                {
                  key: 'start',
                  value: function start() {
                    var _this33 = this;

                    (0, _invariant2['default'])(
                      !this._started,
                      'RSocketServer: Unexpected call to start(), already started.'
                    );
                    this._started = true;

                    this._config.transport.start().subscribe({
                      onComplete: this._handleTransportComplete,
                      onError: this._handleTransportError,
                      onNext: this._handleTransportConnection,
                      onSubscribe: function onSubscribe(subscription) {
                        _this33._subscription = subscription;
                        subscription.request(Number.MAX_SAFE_INTEGER);
                      },
                    });
                  },
                },
                {
                  key: 'stop',
                  value: function stop() {
                    if (this._subscription) {
                      this._subscription.cancel();
                    }

                    this._config.transport.stop();

                    this._handleTransportError(new Error('RSocketServer: Connection terminated via stop().'));
                  },
                },
                {
                  key: '_getSerializers',
                  value: function _getSerializers() {
                    return this._config.serializers || RSocketSerialization.IdentitySerializers;
                  },
                },
                {
                  key: '_setupLeaseError',
                  value: function _setupLeaseError(frame) {
                    var clientLeaseEnabled = (frame.flags & RSocketFrame.FLAGS.LEASE) === RSocketFrame.FLAGS.LEASE;
                    var serverLeaseEnabled = this._config.leases;
                    return clientLeaseEnabled && !serverLeaseEnabled;
                  },
                },
              ]);

              return RSocketServer;
            })();

          exports['default'] = RSocketServer;

          var SubscriberSwapper =
            /*#__PURE__*/
            (function() {
              function SubscriberSwapper(target) {
                _classCallCheck(this, SubscriberSwapper);

                this._target = target;
              }

              _createClass(SubscriberSwapper, [
                {
                  key: 'swap',
                  value: function swap(next) {
                    this._target = next;

                    if (this._subscription) {
                      this._target.onSubscribe && this._target.onSubscribe(this._subscription);
                    }

                    return this;
                  },
                },
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    (0, _invariant2['default'])(this._target, 'must have target');
                    this._target.onComplete && this._target.onComplete();
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    (0, _invariant2['default'])(this._target, 'must have target');
                    this._target.onError && this._target.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(value) {
                    (0, _invariant2['default'])(this._target, 'must have target');
                    this._target.onNext && this._target.onNext(value);
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    (0, _invariant2['default'])(this._target, 'must have target');
                    this._subscription = subscription;
                    this._target.onSubscribe && this._target.onSubscribe(subscription);
                  },
                },
              ]);

              return SubscriberSwapper;
            })();

          function deserializePayload(serializers, frame) {
            return {
              data: serializers.data.deserialize(frame.data),
              metadata: serializers.metadata.deserialize(frame.metadata),
            };
          }
        });
        var RSocketServer = unwrapExports(RSocketServer_1);

        var startServer = function startServer(_a) {
          var address = _a.address,
            serviceCall = _a.serviceCall,
            transportServerProvider = _a.transportServerProvider,
            _b = _a.debug,
            debug = _b === void 0 ? false : _b,
            whoAmI = _a.whoAmI;
          var factoryOptions = transportServerProvider.factoryOptions,
            providerFactory = transportServerProvider.providerFactory,
            serializers = transportServerProvider.serializers;
          var server = new RSocketServer({
            getRequestHandler: function getRequestHandler(socket) {
              return {
                requestResponse: function requestResponse(payload) {
                  return _requestResponse(
                    _assign$1({}, payload, {
                      serviceCall: serviceCall,
                      debug: debug,
                      whoAmI: whoAmI,
                    })
                  );
                },
                requestStream: function requestStream(payload) {
                  return _requestStream(
                    _assign$1({}, payload, {
                      serviceCall: serviceCall,
                      debug: debug,
                      whoAmI: whoAmI,
                    })
                  );
                },
              };
            },
            serializers: serializers,
            transport: providerFactory({
              address: address,
              factoryOptions: factoryOptions,
            }),
          });
          server.start();
          return function() {
            try {
              server.stop.bind(server);
            } catch (e) {
              console.error('RSocket unable to close connection ' + e);
            }
          };
        };

        var _requestResponse = function _requestResponse(_a) {
          var data = _a.data,
            metadata = _a.metadata,
            serviceCall = _a.serviceCall,
            debug = _a.debug,
            whoAmI = _a.whoAmI;
          return new build_2(function(subscriber) {
            subscriber.onSubscribe();
            serviceCall({
              message: data,
              asyncModel: ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE,
              messageFormat: true,
            })
              .then(function(response) {
                subscriber.onComplete({
                  data: response,
                  metadata: {
                    status: true,
                  },
                });
              })
              ['catch'](function(error) {
                saveToLogs(whoAmI, error.message, error, debug, 'warn');
                subscriber.onError({
                  message: {
                    data: error instanceof Error ? error.message : error,
                    metadata: {
                      isErrorFormat: error instanceof Error,
                    },
                  },
                });
              });
          });
        };

        var _requestStream = function _requestStream(_a) {
          var data = _a.data,
            metadata = _a.metadata,
            serviceCall = _a.serviceCall,
            debug = _a.debug,
            whoAmI = _a.whoAmI;
          return new build_4(function(subscriber) {
            subscriber.onSubscribe();
            serviceCall({
              message: data,
              asyncModel: ASYNC_MODEL_TYPES$1.REQUEST_STREAM,
              messageFormat: true,
            }).subscribe(
              function(response) {
                subscriber.onNext({
                  data: response,
                  metadata: {
                    status: true,
                  },
                });
              },
              function(error) {
                saveToLogs(whoAmI, error.message, error, debug, 'warn');
                subscriber.onError({
                  message: {
                    data: error instanceof Error ? error.message : error,
                    metadata: {
                      isErrorFormat: error instanceof Error,
                    },
                  },
                });
              },
              function() {
                return subscriber.onComplete();
              }
            );
          });
        };

        var createConnectionManager = function createConnectionManager() {
          var openConnections = {};
          return {
            getConnection: function getConnection(connectionAddress) {
              return openConnections[connectionAddress];
            },
            getAllConnections: function getAllConnections() {
              return _assign$1({}, openConnections);
            },
            setConnection: function setConnection(connectionAddress, value) {
              return (openConnections[connectionAddress] = value);
            },
            removeConnection: function removeConnection(connectionAddress) {
              return delete openConnections[connectionAddress];
            },
          };
        };

        var getProxy = function getProxy(_a) {
          var serviceCall = _a.serviceCall,
            serviceDefinition = _a.serviceDefinition; // workaround to support old browsers

          var obj = {};
          Object.keys(serviceDefinition.methods).forEach(function(key) {
            return (obj[key] = function() {});
          });
          return new Proxy(obj, {
            get: preServiceCall({
              serviceDefinition: serviceDefinition,
              serviceCall: serviceCall,
            }),
          });
        };

        var preServiceCall = function preServiceCall(_a) {
          var serviceCall = _a.serviceCall,
            serviceDefinition = _a.serviceDefinition;
          return function(target, prop) {
            if (!serviceDefinition.methods[prop]) {
              throw new Error(getServiceMethodIsMissingError(prop));
            }

            var asyncModel = serviceDefinition.methods[prop].asyncModel;
            return function() {
              var data = [];

              for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
              }

              var message = {
                qualifier: getQualifier({
                  serviceName: serviceDefinition.serviceName,
                  methodName: prop,
                }),
                data: data,
              };
              return serviceCall({
                message: message,
                asyncModel: asyncModel,
                messageFormat: false,
              });
            };
          };
        };

        var _createProxy = function createProxy(_a) {
          var router = _a.router,
            serviceDefinition = _a.serviceDefinition,
            microserviceContext = _a.microserviceContext,
            transportClientProvider = _a.transportClientProvider;

          if (!microserviceContext) {
            throw new Error(MICROSERVICE_NOT_EXISTS);
          }

          validateServiceDefinition(serviceDefinition);
          return getProxy({
            serviceCall: getServiceCall({
              router: router,
              microserviceContext: microserviceContext,
              transportClientProvider: transportClientProvider,
            }),
            serviceDefinition: serviceDefinition,
          });
        };

        var _destroy = function destroy(_a) {
          var microserviceContext = _a.microserviceContext,
            discovery = _a.discovery,
            serverStop = _a.serverStop;

          if (!microserviceContext) {
            throw new Error(MICROSERVICE_NOT_EXISTS);
          }

          return new Promise(function(resolve, reject) {
            if (microserviceContext) {
              var localRegistry = microserviceContext.localRegistry,
                remoteRegistry = microserviceContext.remoteRegistry;
              localRegistry.destroy();
              remoteRegistry.destroy();
              destroyAllClientConnections(microserviceContext);
            }

            serverStop && serverStop();
            discovery &&
              discovery.destroy().then(function() {
                microserviceContext = null;
                resolve('');
              });
          });
        };

        var setMicroserviceInstance = function setMicroserviceInstance(_a) {
          var microserviceContext = _a.microserviceContext,
            transportClientProvider = _a.transportClientProvider,
            serverStop = _a.serverStop,
            discoveryInstance = _a.discoveryInstance,
            endPointsToPublishInCluster = _a.endPointsToPublishInCluster,
            address = _a.address,
            debug = _a.debug,
            defaultRouter = _a.defaultRouter;
          var remoteRegistry = microserviceContext.remoteRegistry;
          discoveryInstance
            .discoveredItems$()
            .pipe(printLogs(microserviceContext.whoAmI, debug))
            .subscribe(remoteRegistry.update);
          var serviceFactoryOptions = getServiceFactoryOptions({
            microserviceContext: microserviceContext,
            transportClientProvider: transportClientProvider,
            defaultRouter: defaultRouter,
          });
          return Object.freeze(
            _assign$1(
              {
                destroy: function destroy() {
                  return _destroy({
                    microserviceContext: microserviceContext,
                    discovery: discoveryInstance,
                    serverStop: serverStop,
                  });
                },
              },
              serviceFactoryOptions
            )
          );
        };

        var getServiceFactoryOptions = function getServiceFactoryOptions(_a) {
          var microserviceContext = _a.microserviceContext,
            transportClientProvider = _a.transportClientProvider,
            defaultRouter = _a.defaultRouter;
          return {
            createProxy: function createProxy(_a) {
              var serviceDefinition = _a.serviceDefinition,
                _b = _a.router,
                router = _b === void 0 ? defaultRouter : _b;
              return _createProxy({
                serviceDefinition: serviceDefinition,
                router: router,
                microserviceContext: microserviceContext,
                transportClientProvider: transportClientProvider,
              });
            },
            createServiceCall: function createServiceCall(_a) {
              var _b = _a.router,
                router = _b === void 0 ? defaultRouter : _b;
              return _createServiceCall({
                router: router,
                microserviceContext: microserviceContext,
                transportClientProvider: transportClientProvider,
              });
            },
          };
        };

        var printLogs = function printLogs(whoAmI, debug) {
          return tap(function(_a) {
            var type = _a.type,
              items = _a.items;

            var _b;

            return (
              type !== 'IDLE' &&
              saveToLogs(
                whoAmI,
                'microservice received an updated',
                ((_b = {}),
                (_b[type] = items.map(function(item) {
                  return item.qualifier;
                })),
                _b),
                debug
              )
            );
          });
        };

        var createMicroservice = function createMicroservice(options) {
          var microserviceOptions = _assign$1(
            {
              defaultRouter: function defaultRouter() {
                throw new Error(ROUTER_NOT_PROVIDED);
              },
              services: [],
              debug: false,
              transport: !isNodejs() ? TransportBrowser : undefined,
            },
            options
          );

          if (isString(microserviceOptions.address)) {
            microserviceOptions = _assign$1({}, microserviceOptions, {
              address: getAddress(microserviceOptions.address),
            });
          }

          if (isString(microserviceOptions.seedAddress)) {
            microserviceOptions = _assign$1({}, microserviceOptions, {
              seedAddress: getAddress(microserviceOptions.seedAddress),
            });
          }

          validateMicroserviceOptions(microserviceOptions);
          var connectionManager = createConnectionManager();
          var cluster = microserviceOptions.cluster,
            debug = microserviceOptions.debug;
          var transport = microserviceOptions.transport;
          var address = microserviceOptions.address;
          var seedAddress = microserviceOptions.seedAddress;
          var transportClientProvider = transport && transport.clientProvider;
          var fallBackAddress = address || getAddress(Date.now().toString()); // tslint:disable-next-line

          var microserviceContext = createMicroserviceContext({
            address: fallBackAddress,
            debug: debug || false,
            connectionManager: connectionManager,
          });
          var remoteRegistry = microserviceContext.remoteRegistry,
            localRegistry = microserviceContext.localRegistry;
          var serviceFactoryOptions = getServiceFactoryOptions({
            microserviceContext: microserviceContext,
            transportClientProvider: transportClientProvider,
            defaultRouter: microserviceOptions.defaultRouter,
          });
          var services = microserviceOptions
            ? flatteningServices({
                services: microserviceOptions.services,
                serviceFactoryOptions: serviceFactoryOptions,
              })
            : [];
          localRegistry.add({
            services: services,
            address: address,
          }); // if address is not available then microservice can't share services

          var endPointsToPublishInCluster = address
            ? remoteRegistry.createEndPoints({
                services: services,
                address: address,
              }) || []
            : [];
          var discoveryInstance = createDiscovery({
            address: fallBackAddress,
            itemsToPublish: endPointsToPublishInCluster,
            seedAddress: seedAddress,
            cluster: cluster,
            debug: debug,
          });
          validateDiscoveryInstance(discoveryInstance); // if address is not available then microservice can't start a server and get serviceCall requests

          var serverStop =
            address && transport
              ? startServer({
                  address: address,
                  // server use only localCall therefor, router is irrelevant
                  serviceCall: getServiceCall({
                    router: microserviceOptions.defaultRouter,
                    microserviceContext: microserviceContext,
                    transportClientProvider: transportClientProvider,
                  }),
                  transportServerProvider: transport.serverProvider,
                  debug: debug,
                  whoAmI: getFullAddress(fallBackAddress),
                })
              : null;
          return setMicroserviceInstance({
            microserviceContext: microserviceContext,
            transportClientProvider: transportClientProvider,
            discoveryInstance: discoveryInstance,
            serverStop: serverStop,
            address: fallBackAddress,
            debug: debug,
            endPointsToPublishInCluster: endPointsToPublishInCluster,
            defaultRouter: microserviceOptions.defaultRouter,
          });
        };

        var createMicroserviceContext = function createMicroserviceContext(_a) {
          var address = _a.address,
            debug = _a.debug,
            connectionManager = _a.connectionManager;
          var remoteRegistry = createRemoteRegistry();
          var localRegistry = createLocalRegistry();
          return {
            remoteRegistry: remoteRegistry,
            localRegistry: localRegistry,
            debug: debug,
            whoAmI: getFullAddress(address),
            connectionManager: connectionManager,
          };
        };

        var assert$1 = function assert(predicate, msg) {
          if (!predicate) {
            throw new Error(msg);
          }
        };

        var isDefined$1 = function isDefined(val) {
          return typeof val !== 'undefined';
        };

        var isString$1 = function isString(val) {
          return typeof val === 'string' || val instanceof String;
        };

        var assertString$1 = function assertString(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be a string';
          }

          assert$1(isDefined$1(val) && isString$1(val), msg);
        };

        var isArray$2 = function isArray(val) {
          return Array.isArray(val);
        };

        var isObject$2 = function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]';
        };

        var assertObject$1 = function assertObject(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be an object';
          }

          assert$1(isObject$2(val), msg);
        };

        var assertNonEmptyObject$1 = function assertNonEmptyObject(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be non empty object';
          }

          assertObject$1(val, msg);
          assert$1(Object.keys(val).length > 0, msg);
        };

        var isOneOf$1 = function isOneOf(collection, val) {
          if (isArray$2(collection)) {
            return collection.includes(val);
          }

          if (isObject$2(collection)) {
            return Object.values(collection).includes(val);
          }

          return false;
        };

        var isNumber$1 = function isNumber(val) {
          return typeof val === 'number' && !isNaN(val);
        };

        var assertNumber$1 = function assertNumber(val, msg) {
          if (msg === void 0) {
            msg = 'Expected to be a number';
          }

          assert$1(isNumber$1(val), msg);
        };

        var NOT_VALID_PROTOCOL$1 = 'Not a valid protocol';
        var NOT_VALID_ADDRESS$1 = 'Address must be of type object';
        var NOT_VALID_HOST$1 = 'Not a valid host';
        var NOT_VALID_PATH$1 = 'Not a valid path';
        var NOT_VALID_PORT$1 = 'Not a valid port';

        var validateAddress$1 = function validateAddress(address, isOptional) {
          if (isOptional === void 0) {
            isOptional = true;
          }

          if (isOptional && typeof address === 'undefined') {
            return true;
          }

          assertNonEmptyObject$1(address, NOT_VALID_ADDRESS$1);
          var host = address.host,
            path = address.path,
            protocol = address.protocol;
          var port = address.port;
          port = isString$1(port) ? Number(port) : port;
          assertString$1(host, NOT_VALID_HOST$1);
          assertString$1(path, NOT_VALID_PATH$1);
          assertNumber$1(port, NOT_VALID_PORT$1);
          assertString$1(protocol, NOT_VALID_PROTOCOL$1);
          assert$1(isOneOf$1(['pm', 'ws', 'wss', 'tcp'], protocol), NOT_VALID_PROTOCOL$1);
          return true;
        };
        /**
         * address is <protocol>://<host>:<port>/<path>
         */

        var getFullAddress$1 = function getFullAddress(address) {
          validateAddress$1(address, false);
          var host = address.host,
            path = address.path,
            port = address.port,
            protocol = address.protocol;
          return protocol + '://' + host + ':' + port + '/' + path;
        };

        var colorsMap$1 = {};

        var getRandomColor$1 = function getRandomColor() {
          var letters = '0123456789ABCDEF';
          var color = '#';

          for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
          }

          return color;
        };

        var saveToLogs$1 = function saveToLogs(identifier, msg, extra, debug, type) {
          if (type === void 0) {
            type = 'log';
          }

          if (!colorsMap$1[identifier]) {
            colorsMap$1[identifier] = getRandomColor$1();
          } // tslint:disable

          if (debug) {
            var logColor = 'color:' + colorsMap$1[identifier];
            extra && console[type]('%c******** address: ' + identifier + '********', logColor);
            console[type](msg);
            extra &&
              Object.keys(extra).forEach(function(key) {
                if (Array.isArray(extra[key])) {
                  Object.values(extra[key]).forEach(function(props) {
                    console[type](key + ': ' + JSON.stringify(props.qualifier || props, null, 2));
                  });
                } else {
                  console[type](key + ': ' + JSON.stringify(extra[key], null, 2));
                }
              });
          } // tslint:enable
        };

        var __assign =
          (undefined && undefined.__assign) ||
          function() {
            __assign =
              Object.assign ||
              function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];

                  for (var p in s) {
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                  }
                }

                return t;
              };

            return __assign.apply(this, arguments);
          }; // polyfill MessagePort and MessageChannel

        var MessagePortPolyfill$1 =
          /** @class */
          (function() {
            function MessagePortPolyfill(whoami) {
              this.onmessage = null;
              this.onmessageerror = null;
              this.otherPort = null;
              this.onmessageListeners = [];
              this.queue = [];
              this.otherSideStart = false;
              this.whoami = whoami;
            }

            MessagePortPolyfill.prototype.dispatchEvent = function(event) {
              if (this.onmessage) {
                this.onmessage(event);
              }

              this.onmessageListeners.forEach(function(listener) {
                return listener(event);
              });
              return true;
            };

            MessagePortPolyfill.prototype.postMessage = function(message) {
              if (!this.otherPort) {
                return;
              }

              if (this.otherSideStart) {
                this.otherPort.dispatchEvent({
                  data: message,
                });
              } else {
                this.queue.push(message);
              }
            };

            MessagePortPolyfill.prototype.addEventListener = function(type, listener) {
              if (type !== 'message') {
                return;
              }

              if (typeof listener !== 'function' || this.onmessageListeners.indexOf(listener) !== -1) {
                return;
              }

              this.onmessageListeners.push(listener);
            };

            MessagePortPolyfill.prototype.removeEventListener = function(type, listener) {
              if (type !== 'message') {
                return;
              }

              var index = this.onmessageListeners.indexOf(listener);

              if (index === -1) {
                return;
              }

              this.onmessageListeners.splice(index, 1);
            };

            MessagePortPolyfill.prototype.start = function() {
              var _this = this;

              setTimeout(function() {
                return _this.otherPort && _this.otherPort.startSending.apply(_this.otherPort, []);
              }, 0);
            };

            MessagePortPolyfill.prototype.close = function() {
              var _this = this;

              setTimeout(function() {
                return _this.otherPort && _this.otherPort.stopSending.apply(_this.otherPort, []);
              }, 0);
            };

            MessagePortPolyfill.prototype.startSending = function() {
              var _this = this;

              this.otherSideStart = true;
              this.queue.forEach(function(message) {
                return (
                  _this.otherPort &&
                  _this.otherPort.dispatchEvent({
                    data: message,
                  })
                );
              });
            };

            MessagePortPolyfill.prototype.stopSending = function() {
              this.otherSideStart = false;
              this.queue.length = 0;
            };

            return MessagePortPolyfill;
          })();

        var MessageChannelPolyfill$1 =
          /** @class */
          (function() {
            function MessageChannelPolyfill() {
              this.port1 = new MessagePortPolyfill$1('client');
              this.port2 = new MessagePortPolyfill$1('server');
              this.port1.otherPort = this.port2;
              this.port2.otherPort = this.port1;
            }

            return MessageChannelPolyfill;
          })();

        var globalObj$1 =
          typeof window !== 'undefined' && window.Math === Math
            ? window
            : typeof self !== 'undefined' && self.Math === Math
            ? self
            : Function('return this')();

        function applyMessageChannelPolyfill$1() {
          globalObj$1.MessagePort = MessagePortPolyfill$1;
          globalObj$1.MessageChannel = MessageChannelPolyfill$1;
        }

        if (!globalObj$1.MessagePort || !globalObj$1.MessageChannel) {
          applyMessageChannelPolyfill$1();
        }

        function unwrapExports$1(x) {
          return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
        }

        function createCommonjsModule$1(fn, module) {
          return (
            (module = {
              exports: {},
            }),
            fn(module, module.exports),
            module.exports
          );
        }
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         *
         */

        var nullthrows$1 = function nullthrows(x) {
          if (x != null) {
            return x;
          }

          throw new Error('Got unexpected null or undefined');
        };

        var nullthrows_1$1 = nullthrows$1;
        var FlowableMapOperator_1$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _nullthrows2 = _interopRequireDefault(nullthrows_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * An operator that acts like Array.map, applying a given function to
           * all values provided by its `Subscription` and passing the result to its
           * `Subscriber`.
           */

          var FlowableMapOperator =
            /*#__PURE__*/
            (function() {
              function FlowableMapOperator(subscriber, fn) {
                _classCallCheck(this, FlowableMapOperator);

                this._fn = fn;
                this._subscriber = subscriber;
                this._subscription = null;
              }

              _createClass(FlowableMapOperator, [
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    this._subscriber.onComplete();
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(t) {
                    try {
                      this._subscriber.onNext(this._fn(t));
                    } catch (e) {
                      (0, _nullthrows2['default'])(this._subscription).cancel();

                      this._subscriber.onError(e);
                    }
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    this._subscription = subscription;

                    this._subscriber.onSubscribe(subscription);
                  },
                },
              ]);

              return FlowableMapOperator;
            })();

          exports['default'] = FlowableMapOperator;
        });
        unwrapExports$1(FlowableMapOperator_1$1);
        var FlowableTakeOperator_1$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _nullthrows2 = _interopRequireDefault(nullthrows_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * An operator that requests a fixed number of values from its source
           * `Subscription` and forwards them to its `Subscriber`, cancelling the
           * subscription when the requested number of items has been reached.
           */

          var FlowableTakeOperator =
            /*#__PURE__*/
            (function() {
              function FlowableTakeOperator(subscriber, toTake) {
                _classCallCheck(this, FlowableTakeOperator);

                this._subscriber = subscriber;
                this._subscription = null;
                this._toTake = toTake;
              }

              _createClass(FlowableTakeOperator, [
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    this._subscriber.onComplete();
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(t) {
                    try {
                      this._subscriber.onNext(t);

                      if (--this._toTake === 0) {
                        this._cancelAndComplete();
                      }
                    } catch (e) {
                      (0, _nullthrows2['default'])(this._subscription).cancel();

                      this._subscriber.onError(e);
                    }
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    this._subscription = subscription;

                    this._subscriber.onSubscribe(subscription);

                    if (this._toTake <= 0) {
                      this._cancelAndComplete();
                    }
                  },
                },
                {
                  key: '_cancelAndComplete',
                  value: function _cancelAndComplete() {
                    (0, _nullthrows2['default'])(this._subscription).cancel();

                    this._subscriber.onComplete();
                  },
                },
              ]);

              return FlowableTakeOperator;
            })();

          exports['default'] = FlowableTakeOperator;
        });
        unwrapExports$1(FlowableTakeOperator_1$1);
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         *
         */

        var validateFormat$3 =
          'development' !== 'production'
            ? function(format) {}
            : function(format) {
                if (format === undefined) {
                  throw new Error('invariant(...): Second argument must be a string.');
                }
              };
        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments to provide
         * information about what broke and what you were expecting.
         *
         * The invariant message will be stripped in production, but the invariant will
         * remain to ensure logic does not differ in production.
         */

        function invariant$3(condition, format) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          validateFormat$3(format);

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                'Minified exception occurred; use the non-minified dev environment ' +
                  'for the full error message and additional helpful warnings.'
              );
            } else {
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return String(args[argIndex++]);
                })
              );
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // Skip invariant's own stack frame.

            throw error;
          }
        }

        var invariant_1$3 = invariant$3;
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         *
         */

        function makeEmptyFunction$1(arg) {
          return function() {
            return arg;
          };
        }
        /**
         * This function accepts and discards inputs; it has no side effects. This is
         * primarily useful idiomatically for overridable function endpoints which
         * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
         */

        var emptyFunction$1 = function emptyFunction() {};

        emptyFunction$1.thatReturns = makeEmptyFunction$1;
        emptyFunction$1.thatReturnsFalse = makeEmptyFunction$1(false);
        emptyFunction$1.thatReturnsTrue = makeEmptyFunction$1(true);
        emptyFunction$1.thatReturnsNull = makeEmptyFunction$1(null);

        emptyFunction$1.thatReturnsThis = function() {
          return this;
        };

        emptyFunction$1.thatReturnsArgument = function(arg) {
          return arg;
        };

        var emptyFunction_1$1 = emptyFunction$1;
        /**
         * Similar to invariant but only logs a warning if the condition is not met.
         * This can be used to log issues in development environments in critical
         * paths. Removing the logging code for production environments will keep the
         * same logic and follow the same code paths.
         */

        function printWarning$1(format) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          var argIndex = 0;
          var message =
            'Warning: ' +
            format.replace(/%s/g, function() {
              return args[argIndex++];
            });

          if (typeof console !== 'undefined') {
            console.error(message);
          }

          try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch (x) {}
        }

        var warning$1 =
          'development' !== 'production'
            ? function(condition, format) {
                if (format === undefined) {
                  throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
                }

                if (!condition) {
                  for (
                    var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 2] = arguments[_key2];
                  }

                  printWarning$1.apply(void 0, [format].concat(args));
                }
              }
            : emptyFunction_1$1;
        var warning_1$1 = warning$1;
        var Flowable_1$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _FlowableMapOperator2 = _interopRequireDefault(FlowableMapOperator_1$1);

          var _FlowableTakeOperator2 = _interopRequireDefault(FlowableTakeOperator_1$1);

          var _invariant2 = _interopRequireDefault(invariant_1$3);

          var _warning2 = _interopRequireDefault(warning_1$1);

          var _emptyFunction2 = _interopRequireDefault(emptyFunction_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * Implements the ReactiveStream `Publisher` interface with Rx-style operators.
           */

          var Flowable =
            /*#__PURE__*/
            (function() {
              _createClass(Flowable, null, [
                {
                  key: 'just',
                  value: function just() {
                    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
                      values[_key] = arguments[_key];
                    }

                    return new Flowable(function(subscriber) {
                      var cancelled = false;
                      var i = 0;
                      subscriber.onSubscribe({
                        cancel: function cancel() {
                          cancelled = true;
                        },
                        request: function request(n) {
                          while (!cancelled && n > 0 && i < values.length) {
                            subscriber.onNext(values[i++]);
                            n--;
                          }

                          if (!cancelled && i == values.length) {
                            subscriber.onComplete();
                          }
                        },
                      });
                    });
                  },
                },
                {
                  key: 'error',
                  value: function error(_error) {
                    return new Flowable(function(subscriber) {
                      subscriber.onSubscribe({
                        cancel: function cancel() {},
                        request: function request() {
                          subscriber.onError(_error);
                        },
                      });
                    });
                  },
                },
                {
                  key: 'never',
                  value: function never() {
                    return new Flowable(function(subscriber) {
                      subscriber.onSubscribe({
                        cancel: _emptyFunction2['default'],
                        request: _emptyFunction2['default'],
                      });
                    });
                  },
                },
              ]);

              function Flowable(source) {
                var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_SAFE_INTEGER;

                _classCallCheck(this, Flowable);

                this._max = max;
                this._source = source;
              }

              _createClass(Flowable, [
                {
                  key: 'subscribe',
                  value: function subscribe(subscriberOrCallback) {
                    var partialSubscriber;

                    if (typeof subscriberOrCallback === 'function') {
                      partialSubscriber = this._wrapCallback(subscriberOrCallback);
                    } else {
                      partialSubscriber = subscriberOrCallback;
                    }

                    var subscriber = new FlowableSubscriber(partialSubscriber, this._max);

                    this._source(subscriber);
                  },
                },
                {
                  key: 'lift',
                  value: function lift(onSubscribeLift) {
                    var _this = this;

                    return new Flowable(function(subscriber) {
                      return _this._source(onSubscribeLift(subscriber));
                    });
                  },
                },
                {
                  key: 'map',
                  value: function map(fn) {
                    return this.lift(function(subscriber) {
                      return new _FlowableMapOperator2['default'](subscriber, fn);
                    });
                  },
                },
                {
                  key: 'take',
                  value: function take(toTake) {
                    return this.lift(function(subscriber) {
                      return new _FlowableTakeOperator2['default'](subscriber, toTake);
                    });
                  },
                },
                {
                  key: '_wrapCallback',
                  value: function _wrapCallback(callback) {
                    var max = this._max;
                    return {
                      onNext: callback,
                      onSubscribe: function onSubscribe(subscription) {
                        subscription.request(max);
                      },
                    };
                  },
                },
              ]);

              return Flowable;
            })();

          exports['default'] = Flowable;
          /**
           * @private
           */

          var FlowableSubscriber =
            /*#__PURE__*/
            (function() {
              function FlowableSubscriber(subscriber, max) {
                var _this2 = this;

                _classCallCheck(this, FlowableSubscriber);

                this._cancel = function() {
                  if (!_this2._active) {
                    return;
                  }

                  _this2._active = false;

                  if (_this2._subscription) {
                    _this2._subscription.cancel();
                  }
                };

                this._request = function(n) {
                  (0, _invariant2['default'])(
                    Number.isInteger(n) && n >= 1 && n <= _this2._max,
                    'Flowable: Expected request value to be an integer with a ' +
                      'value greater than 0 and less than or equal to %s, got ' +
                      '`%s`.',
                    _this2._max,
                    n
                  );

                  if (!_this2._active) {
                    return;
                  }

                  if (n === _this2._max) {
                    _this2._pending = _this2._max;
                  } else {
                    _this2._pending += n;

                    if (_this2._pending >= _this2._max) {
                      _this2._pending = _this2._max;
                    }
                  }

                  if (_this2._subscription) {
                    _this2._subscription.request(n);
                  }
                };

                this._active = false;
                this._max = max;
                this._pending = 0;
                this._started = false;
                this._subscriber = subscriber || {};
                this._subscription = null;
              }

              _createClass(FlowableSubscriber, [
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    if (!this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onComplete(): %s.',
                        this._started ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;

                    try {
                      if (this._subscriber.onComplete) {
                        this._subscriber.onComplete();
                      }
                    } catch (error) {
                      if (this._subscriber.onError) {
                        this._subscriber.onError(error);
                      }
                    }
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    if (this._started && !this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onError(): %s.',
                        this._active ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;
                    this._subscriber.onError && this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(data) {
                    if (!this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onNext(): %s.',
                        this._active ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    if (this._pending === 0) {
                      (0, _warning2['default'])(
                        false,
                        'Flowable: Invalid call to onNext(), all request()ed values have been ' + 'published.'
                      );
                      return;
                    }

                    if (this._pending !== this._max) {
                      this._pending--;
                    }

                    try {
                      this._subscriber.onNext && this._subscriber.onNext(data);
                    } catch (error) {
                      if (this._subscription) {
                        this._subscription.cancel();
                      }

                      this.onError(error);
                    }
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    if (this._started) {
                      (0, _warning2['default'])(false, 'Flowable: Invalid call to onSubscribe(): already called.');
                      return;
                    }

                    this._active = true;
                    this._started = true;
                    this._subscription = subscription;

                    try {
                      this._subscriber.onSubscribe &&
                        this._subscriber.onSubscribe({
                          cancel: this._cancel,
                          request: this._request,
                        });
                    } catch (error) {
                      this.onError(error);
                    }
                  },
                },
              ]);

              return FlowableSubscriber;
            })();
        });
        unwrapExports$1(Flowable_1$1);
        var Single_1$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _warning2 = _interopRequireDefault(warning_1$1);

          var _emptyFunction2 = _interopRequireDefault(emptyFunction_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * Represents a lazy computation that will either produce a value of type T
           * or fail with an error. Calling `subscribe()` starts the
           * computation and returns a subscription object, which has an `unsubscribe()`
           * method that can be called to prevent completion/error callbacks from being
           * invoked and, where supported, to also cancel the computation.
           * Implementations may optionally implement cancellation; if they do not
           * `cancel()` is a no-op.
           *
           * Note: Unlike Promise, callbacks (onComplete/onError) may be invoked
           * synchronously.
           *
           * Example:
           *
           * ```
           * const value = new Single(subscriber => {
           *   const id = setTimeout(
           *     () => subscriber.onComplete('Hello!'),
           *     250
           *   );
           *   // Optional: Call `onSubscribe` with a cancellation callback
           *   subscriber.onSubscribe(() => clearTimeout(id));
           * });
           *
           * // Start the computation. onComplete will be called after the timeout
           * // with 'hello'  unless `cancel()` is called first.
           * value.subscribe({
           *   onComplete: value => console.log(value),
           *   onError: error => console.error(error),
           *   onSubscribe: cancel => ...
           * });
           * ```
           */

          var Single =
            /*#__PURE__*/
            (function() {
              _createClass(Single, null, [
                {
                  key: 'of',
                  value: function of(value) {
                    return new Single(function(subscriber) {
                      subscriber.onSubscribe();
                      subscriber.onComplete(value);
                    });
                  },
                },
                {
                  key: 'error',
                  value: function error(_error) {
                    return new Single(function(subscriber) {
                      subscriber.onSubscribe();
                      subscriber.onError(_error);
                    });
                  },
                },
              ]);

              function Single(source) {
                _classCallCheck(this, Single);

                this._source = source;
              }

              _createClass(Single, [
                {
                  key: 'subscribe',
                  value: function subscribe(partialSubscriber) {
                    var subscriber = new FutureSubscriber(partialSubscriber);

                    try {
                      this._source(subscriber);
                    } catch (error) {
                      subscriber.onError(error);
                    }
                  },
                },
                {
                  key: 'flatMap',
                  value: function flatMap(fn) {
                    var _this = this;

                    return new Single(function(subscriber) {
                      var currentCancel;

                      var cancel = function cancel() {
                        currentCancel && currentCancel();
                        currentCancel = null;
                      };

                      _this._source({
                        onComplete: function onComplete(value) {
                          fn(value).subscribe({
                            onComplete: function onComplete(mapValue) {
                              subscriber.onComplete(mapValue);
                            },
                            onError: function onError(error) {
                              return subscriber.onError(error);
                            },
                            onSubscribe: function onSubscribe(_cancel) {
                              currentCancel = _cancel;
                            },
                          });
                        },
                        onError: function onError(error) {
                          return subscriber.onError(error);
                        },
                        onSubscribe: function onSubscribe(_cancel) {
                          currentCancel = _cancel;
                          subscriber.onSubscribe(cancel);
                        },
                      });
                    });
                  },
                  /**
                   * Return a new Single that resolves to the value of this Single applied to
                   * the given mapping function.
                   */
                },
                {
                  key: 'map',
                  value: function map(fn) {
                    var _this2 = this;

                    return new Single(function(subscriber) {
                      return _this2._source({
                        onComplete: function onComplete(value) {
                          return subscriber.onComplete(fn(value));
                        },
                        onError: function onError(error) {
                          return subscriber.onError(error);
                        },
                        onSubscribe: function onSubscribe(cancel) {
                          return subscriber.onSubscribe(cancel);
                        },
                      });
                    });
                  },
                },
                {
                  key: 'then',
                  value: function then(successFn, errorFn) {
                    this.subscribe({
                      onComplete: successFn || _emptyFunction2['default'],
                      onError: errorFn || _emptyFunction2['default'],
                    });
                  },
                },
              ]);

              return Single;
            })();

          exports['default'] = Single;
          /**
           * @private
           */

          var FutureSubscriber =
            /*#__PURE__*/
            (function() {
              function FutureSubscriber(subscriber) {
                _classCallCheck(this, FutureSubscriber);

                this._active = false;
                this._started = false;
                this._subscriber = subscriber || {};
              }

              _createClass(FutureSubscriber, [
                {
                  key: 'onComplete',
                  value: function onComplete(value) {
                    if (!this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Single: Invalid call to onComplete(): %s.',
                        this._started ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;

                    try {
                      if (this._subscriber.onComplete) {
                        this._subscriber.onComplete(value);
                      }
                    } catch (error) {
                      if (this._subscriber.onError) {
                        this._subscriber.onError(error);
                      }
                    }
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    if (this._started && !this._active) {
                      (0, _warning2['default'])(
                        false,
                        'Single: Invalid call to onError(): %s.',
                        this._active ? 'onComplete/onError was already called' : 'onSubscribe has not been called'
                      );
                      return;
                    }

                    this._active = false;
                    this._started = true;
                    this._subscriber.onError && this._subscriber.onError(error);
                  },
                },
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(cancel) {
                    var _this3 = this;

                    if (this._started) {
                      (0, _warning2['default'])(false, 'Single: Invalid call to onSubscribe(): already called.');
                      return;
                    }

                    this._active = true;
                    this._started = true;

                    try {
                      this._subscriber.onSubscribe &&
                        this._subscriber.onSubscribe(function() {
                          if (!_this3._active) {
                            return;
                          }

                          _this3._active = false;
                          cancel && cancel();
                        });
                    } catch (error) {
                      this.onError(error);
                    }
                  },
                },
              ]);

              return FutureSubscriber;
            })();
        });
        unwrapExports$1(Single_1$1);
        var FlowableProcessor_1$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });

          var _warning2 = _interopRequireDefault(warning_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }

          var FlowableProcessor =
            /*#__PURE__*/
            (function() {
              function FlowableProcessor(source, fn) {
                _classCallCheck(this, FlowableProcessor);

                this._source = source;
                this._transformer = fn;
                this._done = false;
                this._mappers = []; //mappers for map function
              }

              _createClass(FlowableProcessor, [
                {
                  key: 'onSubscribe',
                  value: function onSubscribe(subscription) {
                    this._subscription = subscription;
                  },
                },
                {
                  key: 'onNext',
                  value: function onNext(t) {
                    if (!this._sink) {
                      (0, _warning2['default'])('Warning, premature onNext for processor, dropping value');
                      return;
                    }

                    var val = t;

                    if (this._transformer) {
                      val = this._transformer(t);
                    }

                    var finalVal = this._mappers.reduce(function(interimVal, mapper) {
                      return mapper(interimVal);
                    }, val);

                    this._sink.onNext(finalVal);
                  },
                },
                {
                  key: 'onError',
                  value: function onError(error) {
                    this._error = error;

                    if (!this._sink) {
                      (0, _warning2['default'])('Warning, premature onError for processor, marking complete/errored');
                    } else {
                      this._sink.onError(error);
                    }
                  },
                },
                {
                  key: 'onComplete',
                  value: function onComplete() {
                    this._done = true;

                    if (!this._sink) {
                      (0, _warning2['default'])('Warning, premature onError for processor, marking complete');
                    } else {
                      this._sink.onComplete();
                    }
                  },
                },
                {
                  key: 'subscribe',
                  value: function subscribe(subscriber) {
                    if (this._source.subscribe) {
                      this._source.subscribe(this);
                    }

                    this._sink = subscriber;

                    this._sink.onSubscribe(this);

                    if (this._error) {
                      this._sink.onError(this._error);
                    } else if (this._done) {
                      this._sink.onComplete();
                    }
                  },
                },
                {
                  key: 'map',
                  value: function map(fn) {
                    this._mappers.push(fn);

                    return this;
                  },
                },
                {
                  key: 'request',
                  value: function request(n) {
                    this._subscription && this._subscription.request(n);
                  },
                },
                {
                  key: 'cancel',
                  value: function cancel() {
                    this._subscription && this._subscription.cancel();
                  },
                },
              ]);

              return FlowableProcessor;
            })();

          exports['default'] = FlowableProcessor;
        });
        unwrapExports$1(FlowableProcessor_1$1);
        var FlowableTimer$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.every = every;

          var _Flowable2 = _interopRequireDefault(Flowable_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * Returns a Publisher that provides the current time (Date.now()) every `ms`
           * milliseconds.
           *
           * The timer is established on the first call to `request`: on each
           * interval a value is published if there are outstanding requests,
           * otherwise nothing occurs for that interval. This approach ensures
           * that the interval between `onNext` calls is as regular as possible
           * and means that overlapping `request` calls (ie calling again before
           * the previous values have been vended) behaves consistently.
           */

          function every(ms) {
            return new _Flowable2['default'](function(subscriber) {
              var intervalId = null;
              var pending = 0;
              subscriber.onSubscribe({
                cancel: function cancel() {
                  if (intervalId != null) {
                    clearInterval(intervalId);
                    intervalId = null;
                  }
                },
                request: function request(n) {
                  if (n < Number.MAX_SAFE_INTEGER) {
                    pending += n;
                  } else {
                    pending = Number.MAX_SAFE_INTEGER;
                  }

                  if (intervalId != null) {
                    return;
                  }

                  intervalId = setInterval(function() {
                    if (pending > 0) {
                      if (pending !== Number.MAX_SAFE_INTEGER) {
                        pending--;
                      }

                      subscriber.onNext(Date.now());
                    }
                  }, ms);
                },
              });
            });
          }
        });
        unwrapExports$1(FlowableTimer$1);
        var FlowableTimer_1$1 = FlowableTimer$1.every;
        var build$2 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          exports.every = exports.Single = exports.FlowableProcessor = exports.Flowable = undefined;

          var _Flowable2 = _interopRequireDefault(Flowable_1$1);

          var _Single2 = _interopRequireDefault(Single_1$1);

          var _FlowableProcessor2 = _interopRequireDefault(FlowableProcessor_1$1);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule
              ? obj
              : {
                  default: obj,
                };
          }
          /**
           * The public API of the `flowable` package.
           */

          exports.Flowable = _Flowable2['default'];
          exports.FlowableProcessor = _FlowableProcessor2['default'];
          exports.Single = _Single2['default'];
          exports.every = FlowableTimer$1.every;
        });
        unwrapExports$1(build$2);
        var build_1$2 = build$2.every;
        var build_2$1 = build$2.Single;
        var build_3$1 = build$2.FlowableProcessor;
        var build_4$1 = build$2.Flowable;
        var ReactiveSocketTypes$1 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          /** Copyright (c) Facebook, Inc. and its affiliates.
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *     http://www.apache.org/licenses/LICENSE-2.0
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           *
           *
           */

          /**
           * Represents a network connection with input/output used by a ReactiveSocket to
           * send/receive data.
           */

          var CONNECTION_STATUS = exports.CONNECTION_STATUS = {
    CLOSED: Object.freeze({
      kind: 'CLOSED'
    }),
    CONNECTED: Object.freeze({
      kind: 'CONNECTED'
    }),
    CONNECTING: Object.freeze({
      kind: 'CONNECTING'
    }),
    NOT_CONNECTED: Object.freeze({
      kind: 'NOT_CONNECTED'
    })
  };
          /**
           * Describes the connection status of a ReactiveSocket/DuplexConnection.
           * - NOT_CONNECTED: no connection established or pending.
           * - CONNECTING: when `connect()` has been called but a connection is not yet
           *   established.
           * - CONNECTED: when a connection is established.
           * - CLOSED: when the connection has been explicitly closed via `close()`.
           * - ERROR: when the connection has been closed for any other reason.
           */

          /**
   * A contract providing different interaction models per the [ReactiveSocket protocol]
   (https://github.com/ReactiveSocket/reactivesocket/blob/master/Protocol.md).
   */

          /**
           * A single unit of data exchanged between the peers of a `ReactiveSocket`.
           */

          /**
           * A type that can be written to a buffer.
           */
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
          // prettier-ignore
        });
        unwrapExports$1(ReactiveSocketTypes$1);
        var ReactiveSocketTypes_1$1 = ReactiveSocketTypes$1.CONNECTION_STATUS;
        var ReactiveStreamTypes$1 =
          /*#__PURE__*/
          Object.freeze({
            __proto__: null,
          });
        var build$3 = createCommonjsModule$1(function(module, exports) {
          Object.defineProperty(exports, '__esModule', {
            value: true,
          });
          Object.keys(ReactiveSocketTypes$1).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return ReactiveSocketTypes$1[key];
              },
            });
          });
          Object.keys(ReactiveStreamTypes$1).forEach(function(key) {
            if (key === 'default' || key === '__esModule') return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function get() {
                return ReactiveStreamTypes$1[key];
              },
            });
          });
        });
        unwrapExports$1(build$3);
        var build_1$3 = build$3.CONNECTION_STATUS;
        /**
         *
         *
         */

        var newMessage$2 = function newMessage(_ref) {
          var type = _ref.type,
            payload = _ref.payload;
          return {
            cid: Date.now() + '-' + Math.random(),
            payload: payload,
            type: type,
          };
        }; // $FlowFixMe

        var getMessageData$2 = function getMessageData(_ref2) {
          var data = _ref2.data;
          return data || null;
        };

        var updateListeners$2 = function updateListeners(_ref3) {
          var _ref3$listeners = _ref3.listeners,
            listeners = _ref3$listeners === void 0 ? [] : _ref3$listeners,
            type = _ref3.type,
            func = _ref3.func,
            scope = _ref3.scope;
          return type && func
            ? [].concat(_toConsumableArray(listeners), [
                {
                  func: func,
                  type: type,
                  scope: scope,
                },
              ])
            : _toConsumableArray(listeners);
        };

        var localAddress$3 = [];

        var genericPostMessage$3 = function genericPostMessage(data, transfer) {
          try {
            // $FlowFixMe
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              if (localAddress$3.indexOf(data.detail.address) > -1) {
                var event = new MessageEvent('message', {
                  data: data,
                  ports: transfer ? transfer : undefined,
                });
                dispatchEvent(event);
              } else {
                // $FlowFixMe
                postMessage(data, transfer ? transfer : undefined);
              }
            } else {
              // $FlowFixMe
              postMessage(data, '*', transfer ? transfer : undefined);
            }
          } catch (e) {
            console.error('Unable to post message ', e);
          }
        };
        /**
         *
         */

        /**
         * EventsClient implements IChannelClient
         *
         * initiate connection with a server.
         *
         */

        var listeners$2 = [];

        var EventsClient$2 =
          /*#__PURE__*/
          (function() {
            function EventsClient(option) {
              _classCallCheck(this, EventsClient);

              this.eventType = option.eventType || 'RsocketEvents';
              this.confirmConnectionOpenCallback = option.confirmConnectionOpenCallback;
              this.debug = option.debug || false;
            }

            _createClass(EventsClient, [
              {
                key: 'connect',
                value: function connect(address) {
                  var _this = this;

                  var channel = new MessageChannel();

                  if (!channel) {
                    throw new Error('MessageChannel not supported');
                  } // send open message to the server with a port message

                  pingServer$2(this.eventType, channel, address);
                  listeners$2 = updateListeners$2({
                    func: initConnection$2,
                    type: 'message',
                    scope: 'port',
                  }); // start to listen to the port

                  startListen$2(channel, this.confirmConnectionOpenCallback);

                  if (channel && channel.port1) {
                    var port1 = channel.port1;
                    return Object.freeze({
                      disconnect: function disconnect() {
                        port1.postMessage(
                          newMessage$2({
                            payload: null,
                            type: 'close',
                          })
                        );
                        Array.isArray(listeners$2) &&
                          listeners$2.forEach(function(_ref4) {
                            var type = _ref4.type,
                              func = _ref4.func,
                              scope = _ref4.scope;
                            return scope === 'port'
                              ? port1 && port1.removeEventListener(type, func) // $FlowFixMe
                              : removeEventListener(type, func);
                          });
                      },
                      receive: function receive(cb) {
                        listeners$2 = updateListeners$2({
                          func: responseMessage$2,
                          listeners: listeners$2,
                          type: 'message',
                          scope: 'port',
                        });
                        port1.addEventListener('message', function(eventMsg) {
                          return responseMessage$2(eventMsg, _this.debug, cb);
                        });
                      },
                      send: function send(msg) {
                        if (_this.debug) {
                          console.log('Client send request with payload: '.concat(JSON.stringify(msg)));
                        }

                        port1.postMessage(
                          newMessage$2({
                            payload: msg,
                            type: 'request',
                          })
                        );
                      },
                    });
                  } else {
                    throw new Error('Unable to use port message');
                  }
                },
              },
            ]);

            return EventsClient;
          })();

        var pingServer$2 = function pingServer(type, channel, address) {
          genericPostMessage$3(
            {
              detail: {
                address: address,
                type: 'rsocket-events-open-connection',
              },
              type: type,
            },
            [channel.port2]
          );
        };

        var startListen$2 = function startListen(channel, confirmConnectionOpenCallback) {
          if (channel && channel.port1) {
            var port1 = channel.port1;
            port1.addEventListener('message', function(eventMsg) {
              return initConnection$2(eventMsg, channel, confirmConnectionOpenCallback, port1);
            });
            port1.start();
          }
        };

        var initConnection$2 = function initConnection(eventMsg, channel, confirmConnectionOpenCallback, port1) {
          var _getMessageData = getMessageData$2(eventMsg),
            type = _getMessageData.type;

          switch (type) {
            case 'connect': {
              typeof confirmConnectionOpenCallback === 'function' && confirmConnectionOpenCallback();
              break;
            }

            case 'disconnect': {
              if (channel) {
                port1 && port1.close();
                Array.isArray(listeners$2) &&
                  listeners$2.forEach(function(_ref5) {
                    var type = _ref5.type,
                      func = _ref5.func,
                      scope = _ref5.scope;
                    return scope === 'port' && port1 && port1.removeEventListener(type, func);
                  });
                port1 = null;
                channel = null;
              }

              break;
            }
          }
        };

        var responseMessage$2 = function responseMessage(eventMsg, debug, cb) {
          var _getMessageData2 = getMessageData$2(eventMsg),
            type = _getMessageData2.type,
            payload = _getMessageData2.payload;

          if (type === 'response') {
            if (debug) {
              console.log('Client receive response with payload: '.concat(payload));
            }

            cb(payload);
          }
        };
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var validateFormat$4 = function validateFormat(format) {};

        if ('development' !== 'production') {
          validateFormat$4 = function validateFormat(format) {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          };
        }

        function invariant$4(condition, format, a, b, c, d, e, f) {
          validateFormat$4(format);

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                'Minified exception occurred; use the non-minified dev environment ' +
                  'for the full error message and additional helpful warnings.'
              );
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                })
              );
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame

            throw error;
          }
        }

        var invariant_1$4 = invariant$4;
        /**
         * written with <3 by scaleCube-js maintainers
         *
         * RSocketEventsClient Transport provider for event base messages
         * browser <--> browser
         *
         *
         */

        /**
         * A WebSocket transport client for use in browser environments.
         */

        var RSocketEventsClient$2 =
          /*#__PURE__*/
          (function() {
            function RSocketEventsClient(_ref6) {
              var eventClient = _ref6.eventClient,
                address = _ref6.address,
                _ref6$debug = _ref6.debug,
                debug = _ref6$debug === void 0 ? false : _ref6$debug;

              _classCallCheck(this, RSocketEventsClient);

              this._receivers = new Set();
              this._eventsClient =
                eventClient ||
                new EventsClient$2({
                  confirmConnectionOpenCallback: this.confirmConnectionOpenCallback.bind(this),
                  eventType: 'RsocketEvents',
                  debug: debug,
                });
              this._address = address;
              this._statusSubscribers = new Set();
              this._status = build_1$3.NOT_CONNECTED;
              this.debug = debug;
            }

            _createClass(RSocketEventsClient, [
              {
                key: 'confirmConnectionOpenCallback',
                value: function confirmConnectionOpenCallback() {
                  this._setConnectionStatus(build_1$3.CONNECTED);
                },
                /**
                 * Send a single frame on the connection.
                 */
              },
              {
                key: 'sendOne',
                value: function sendOne(frame) {
                  if (!this.connection) {
                    return;
                  }

                  this.connection.send(frame);
                },
                /**
                 * Send all the `input` frames on this connection.
                 *
                 * Notes:
                 * - Implementations must not cancel the subscription.
                 * - Implementations must signal any errors by calling `onError` on the
                 *   `receive()` Publisher.
                 */
              },
              {
                key: 'send',
                value: function send(input) {
                  var _this2 = this;

                  if (!this.connection) {
                    return;
                  }

                  input.subscribe(function(frame) {
                    if (_this2.debug) {
                      console.log('RSocketEventsClient send frame: ', frame);
                    }

                    _this2.connection.send(frame);
                  });
                },
                /**
                 * Returns a stream of all `Frame`s received on this connection.
                 *
                 * Notes:
                 * - Implementations must call `onComplete` if the underlying connection is
                 *   closed by the peer or by calling `close()`.
                 * - Implementations must call `onError` if there are any errors
                 *   sending/receiving frames.
                 * - Implemenations may optionally support multi-cast receivers. Those that do
                 *   not should throw if `receive` is called more than once.
                 */
              },
              {
                key: 'receive',
                value: function receive() {
                  var _this3 = this;

                  return new build_4$1(function(subject) {
                    subject.onSubscribe({
                      cancel: function cancel() {
                        _this3._receivers['delete'](subject);
                      },
                      request: function request() {
                        _this3._receivers.add(subject);
                      },
                    });
                  });
                },
                /**
                 * Close the underlying connection, emitting `onComplete` on the receive()
                 * Publisher.
                 */
              },
              {
                key: 'close',
                value: function close(error) {
                  if (this._status.kind === 'CLOSED' || this._status.kind === 'ERROR') {
                    // already closed
                    return;
                  }

                  var status = error
                    ? {
                        error: error,
                        kind: 'ERROR',
                      }
                    : build_1$3.CLOSED;

                  this._setConnectionStatus(status);

                  this._receivers.forEach(function(subscriber) {
                    if (error) {
                      subscriber.onError(error);
                    } else {
                      subscriber.onComplete();
                    }
                  });

                  this._receivers.clear();

                  this.connection && typeof this.connection.disconnect === 'function' && this.connection.disconnect();
                  this._eventsClient = null;
                },
                /**
                 * Open the underlying connection. Throws if the connection is already in
                 * the CLOSED or ERROR state.
                 */
              },
              {
                key: 'connect',
                value: function connect() {
                  var _this4 = this;

                  invariant_1$4(
                    this._status.kind === 'NOT_CONNECTED',
                    'RSocketEventsClient: Cannot connect(), a connection is already ' + 'established.'
                  );

                  this._setConnectionStatus(build_1$3.CONNECTING);

                  if (this._eventsClient) {
                    var _eventsClient = this._eventsClient;

                    this._setConnectionStatus(build_1$3.CONNECTING);

                    this.connection = _eventsClient.connect(this._address);
                    this.connection.receive(function(frame) {
                      if (_this4.debug) {
                        console.log('RSocketEventsClient received frame: ', frame);
                      }

                      frame &&
                        _this4._receivers.forEach(function(subscriber) {
                          return subscriber.onNext(frame);
                        });
                    });
                  } else {
                    console.log('connection is closed');
                  }
                },
                /**
                 * Returns a Flowable that immediately publishes the current connection
                 * status and thereafter updates as it changes. Once a connection is in
                 * the CLOSED or ERROR state, it may not be connected again.
                 * Implementations must publish values per the comments on ConnectionStatus.
                 */
              },
              {
                key: 'connectionStatus',
                value: function connectionStatus() {
                  var _this5 = this;

                  return new build_4$1(function(subscriber) {
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        _this5._statusSubscribers['delete'](subscriber);
                      },
                      request: function request() {
                        _this5._statusSubscribers.add(subscriber);

                        subscriber.onNext(_this5._status);
                      },
                    });
                  });
                },
              },
              {
                key: '_setConnectionStatus',
                value: function _setConnectionStatus(status) {
                  this._status = status;

                  this._statusSubscribers.forEach(function(subscriber) {
                    return subscriber.onNext(status);
                  });
                },
              },
            ]);

            return RSocketEventsClient;
          })();

        var clientFactory$1 = function clientFactory(options) {
          var address = options.address,
            factoryOptions = options.factoryOptions;
          validateAddress$1(address);
          var protocol = address.protocol;

          switch (protocol.toLowerCase()) {
            case 'pm':
              return new RSocketEventsClient$2({
                address: getFullAddress$1(address),
              });

            default:
              throw Error(NOT_VALID_PROTOCOL$1);
          }
        };
        /**
         *
         *
         */

        var newMessage$3 = function newMessage(_ref) {
          var type = _ref.type,
            payload = _ref.payload;
          return {
            cid: Date.now() + '-' + Math.random(),
            payload: payload,
            type: type,
          };
        }; // $FlowFixMe

        var getMessageData$3 = function getMessageData(_ref2) {
          var data = _ref2.data;
          return data || null;
        };

        var updateListeners$3 = function updateListeners(_ref3) {
          var _ref3$listeners = _ref3.listeners,
            listeners = _ref3$listeners === void 0 ? [] : _ref3$listeners,
            type = _ref3.type,
            func = _ref3.func,
            scope = _ref3.scope;
          return type && func
            ? [].concat(_toConsumableArray(listeners), [
                {
                  func: func,
                  type: type,
                  scope: scope,
                },
              ])
            : _toConsumableArray(listeners);
        };

        var localAddress$4 = [];

        var genericPostMessage$4 = function genericPostMessage(data, transfer) {
          try {
            // $FlowFixMe
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              if (localAddress$4.indexOf(data.detail.address) > -1) {
                var event = new MessageEvent('message', {
                  data: data,
                  ports: transfer ? transfer : undefined,
                });
                dispatchEvent(event);
              } else {
                // $FlowFixMe
                postMessage(data, transfer ? transfer : undefined);
              }
            } else {
              // $FlowFixMe
              postMessage(data, '*', transfer ? transfer : undefined);
            }
          } catch (e) {
            console.error('Unable to post message ', e);
          }
        };
        /**
         *
         */

        /**
         * EventsClient implements IChannelClient
         *
         * initiate connection with a server.
         *
         */

        var listeners$3 = [];

        var EventsClient$3 =
          /*#__PURE__*/
          (function() {
            function EventsClient(option) {
              _classCallCheck(this, EventsClient);

              this.eventType = option.eventType || 'RsocketEvents';
              this.confirmConnectionOpenCallback = option.confirmConnectionOpenCallback;
              this.debug = option.debug || false;
            }

            _createClass(EventsClient, [
              {
                key: 'connect',
                value: function connect(address) {
                  var _this = this;

                  var channel = new MessageChannel();

                  if (!channel) {
                    throw new Error('MessageChannel not supported');
                  } // send open message to the server with a port message

                  pingServer$3(this.eventType, channel, address);
                  listeners$3 = updateListeners$3({
                    func: initConnection$3,
                    type: 'message',
                    scope: 'port',
                  }); // start to listen to the port

                  startListen$3(channel, this.confirmConnectionOpenCallback);

                  if (channel && channel.port1) {
                    var port1 = channel.port1;
                    return Object.freeze({
                      disconnect: function disconnect() {
                        port1.postMessage(
                          newMessage$3({
                            payload: null,
                            type: 'close',
                          })
                        );
                        Array.isArray(listeners$3) &&
                          listeners$3.forEach(function(_ref4) {
                            var type = _ref4.type,
                              func = _ref4.func,
                              scope = _ref4.scope;
                            return scope === 'port'
                              ? port1 && port1.removeEventListener(type, func) // $FlowFixMe
                              : removeEventListener(type, func);
                          });
                      },
                      receive: function receive(cb) {
                        listeners$3 = updateListeners$3({
                          func: responseMessage$3,
                          listeners: listeners$3,
                          type: 'message',
                          scope: 'port',
                        });
                        port1.addEventListener('message', function(eventMsg) {
                          return responseMessage$3(eventMsg, _this.debug, cb);
                        });
                      },
                      send: function send(msg) {
                        if (_this.debug) {
                          console.log('Client send request with payload: '.concat(JSON.stringify(msg)));
                        }

                        port1.postMessage(
                          newMessage$3({
                            payload: msg,
                            type: 'request',
                          })
                        );
                      },
                    });
                  } else {
                    throw new Error('Unable to use port message');
                  }
                },
              },
            ]);

            return EventsClient;
          })();

        var pingServer$3 = function pingServer(type, channel, address) {
          genericPostMessage$4(
            {
              detail: {
                address: address,
                type: 'rsocket-events-open-connection',
              },
              type: type,
            },
            [channel.port2]
          );
        };

        var startListen$3 = function startListen(channel, confirmConnectionOpenCallback) {
          if (channel && channel.port1) {
            var port1 = channel.port1;
            port1.addEventListener('message', function(eventMsg) {
              return initConnection$3(eventMsg, channel, confirmConnectionOpenCallback, port1);
            });
            port1.start();
          }
        };

        var initConnection$3 = function initConnection(eventMsg, channel, confirmConnectionOpenCallback, port1) {
          var _getMessageData = getMessageData$3(eventMsg),
            type = _getMessageData.type;

          switch (type) {
            case 'connect': {
              typeof confirmConnectionOpenCallback === 'function' && confirmConnectionOpenCallback();
              break;
            }

            case 'disconnect': {
              if (channel) {
                port1 && port1.close();
                Array.isArray(listeners$3) &&
                  listeners$3.forEach(function(_ref5) {
                    var type = _ref5.type,
                      func = _ref5.func,
                      scope = _ref5.scope;
                    return scope === 'port' && port1 && port1.removeEventListener(type, func);
                  });
                port1 = null;
                channel = null;
              }

              break;
            }
          }
        };

        var responseMessage$3 = function responseMessage(eventMsg, debug, cb) {
          var _getMessageData2 = getMessageData$3(eventMsg),
            type = _getMessageData2.type,
            payload = _getMessageData2.payload;

          if (type === 'response') {
            if (debug) {
              console.log('Client receive response with payload: '.concat(payload));
            }

            cb(payload);
          }
        };
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         *
         */

        /**
         * Use invariant() to assert state which your program assumes to be true.
         *
         * Provide sprintf-style format (only %s is supported) and arguments
         * to provide information about what broke and what you were
         * expecting.
         *
         * The invariant message will be stripped in production, but the invariant
         * will remain to ensure logic does not differ in production.
         */

        var validateFormat$5 = function validateFormat(format) {};

        if ('development' !== 'production') {
          validateFormat$5 = function validateFormat(format) {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          };
        }

        function invariant$5(condition, format, a, b, c, d, e, f) {
          validateFormat$5(format);

          if (!condition) {
            var error;

            if (format === undefined) {
              error = new Error(
                'Minified exception occurred; use the non-minified dev environment ' +
                  'for the full error message and additional helpful warnings.'
              );
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                })
              );
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame

            throw error;
          }
        }

        var invariant_1$5 = invariant$5;
        /**
         * written with <3 by scaleCube-js maintainers
         *
         * RSocketEventsClient Transport provider for event base messages
         * browser <--> browser
         *
         *
         */

        /**
         * A WebSocket transport client for use in browser environments.
         */

        var RSocketEventsClient$3 =
          /*#__PURE__*/
          (function() {
            function RSocketEventsClient(_ref6) {
              var eventClient = _ref6.eventClient,
                address = _ref6.address,
                _ref6$debug = _ref6.debug,
                debug = _ref6$debug === void 0 ? false : _ref6$debug;

              _classCallCheck(this, RSocketEventsClient);

              this._receivers = new Set();
              this._eventsClient =
                eventClient ||
                new EventsClient$3({
                  confirmConnectionOpenCallback: this.confirmConnectionOpenCallback.bind(this),
                  eventType: 'RsocketEvents',
                  debug: debug,
                });
              this._address = address;
              this._statusSubscribers = new Set();
              this._status = build_1$3.NOT_CONNECTED;
              this.debug = debug;
            }

            _createClass(RSocketEventsClient, [
              {
                key: 'confirmConnectionOpenCallback',
                value: function confirmConnectionOpenCallback() {
                  this._setConnectionStatus(build_1$3.CONNECTED);
                },
                /**
                 * Send a single frame on the connection.
                 */
              },
              {
                key: 'sendOne',
                value: function sendOne(frame) {
                  if (!this.connection) {
                    return;
                  }

                  this.connection.send(frame);
                },
                /**
                 * Send all the `input` frames on this connection.
                 *
                 * Notes:
                 * - Implementations must not cancel the subscription.
                 * - Implementations must signal any errors by calling `onError` on the
                 *   `receive()` Publisher.
                 */
              },
              {
                key: 'send',
                value: function send(input) {
                  var _this2 = this;

                  if (!this.connection) {
                    return;
                  }

                  input.subscribe(function(frame) {
                    if (_this2.debug) {
                      console.log('RSocketEventsClient send frame: ', frame);
                    }

                    _this2.connection.send(frame);
                  });
                },
                /**
                 * Returns a stream of all `Frame`s received on this connection.
                 *
                 * Notes:
                 * - Implementations must call `onComplete` if the underlying connection is
                 *   closed by the peer or by calling `close()`.
                 * - Implementations must call `onError` if there are any errors
                 *   sending/receiving frames.
                 * - Implemenations may optionally support multi-cast receivers. Those that do
                 *   not should throw if `receive` is called more than once.
                 */
              },
              {
                key: 'receive',
                value: function receive() {
                  var _this3 = this;

                  return new build_4$1(function(subject) {
                    subject.onSubscribe({
                      cancel: function cancel() {
                        _this3._receivers['delete'](subject);
                      },
                      request: function request() {
                        _this3._receivers.add(subject);
                      },
                    });
                  });
                },
                /**
                 * Close the underlying connection, emitting `onComplete` on the receive()
                 * Publisher.
                 */
              },
              {
                key: 'close',
                value: function close(error) {
                  if (this._status.kind === 'CLOSED' || this._status.kind === 'ERROR') {
                    // already closed
                    return;
                  }

                  var status = error
                    ? {
                        error: error,
                        kind: 'ERROR',
                      }
                    : build_1$3.CLOSED;

                  this._setConnectionStatus(status);

                  this._receivers.forEach(function(subscriber) {
                    if (error) {
                      subscriber.onError(error);
                    } else {
                      subscriber.onComplete();
                    }
                  });

                  this._receivers.clear();

                  this.connection && typeof this.connection.disconnect === 'function' && this.connection.disconnect();
                  this._eventsClient = null;
                },
                /**
                 * Open the underlying connection. Throws if the connection is already in
                 * the CLOSED or ERROR state.
                 */
              },
              {
                key: 'connect',
                value: function connect() {
                  var _this4 = this;

                  invariant_1$5(
                    this._status.kind === 'NOT_CONNECTED',
                    'RSocketEventsClient: Cannot connect(), a connection is already ' + 'established.'
                  );

                  this._setConnectionStatus(build_1$3.CONNECTING);

                  if (this._eventsClient) {
                    var _eventsClient = this._eventsClient;

                    this._setConnectionStatus(build_1$3.CONNECTING);

                    this.connection = _eventsClient.connect(this._address);
                    this.connection.receive(function(frame) {
                      if (_this4.debug) {
                        console.log('RSocketEventsClient received frame: ', frame);
                      }

                      frame &&
                        _this4._receivers.forEach(function(subscriber) {
                          return subscriber.onNext(frame);
                        });
                    });
                  } else {
                    console.log('connection is closed');
                  }
                },
                /**
                 * Returns a Flowable that immediately publishes the current connection
                 * status and thereafter updates as it changes. Once a connection is in
                 * the CLOSED or ERROR state, it may not be connected again.
                 * Implementations must publish values per the comments on ConnectionStatus.
                 */
              },
              {
                key: 'connectionStatus',
                value: function connectionStatus() {
                  var _this5 = this;

                  return new build_4$1(function(subscriber) {
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        _this5._statusSubscribers['delete'](subscriber);
                      },
                      request: function request() {
                        _this5._statusSubscribers.add(subscriber);

                        subscriber.onNext(_this5._status);
                      },
                    });
                  });
                },
              },
              {
                key: '_setConnectionStatus',
                value: function _setConnectionStatus(status) {
                  this._status = status;

                  this._statusSubscribers.forEach(function(subscriber) {
                    return subscriber.onNext(status);
                  });
                },
              },
            ]);

            return RSocketEventsClient;
          })();
        /**
         *
         *
         */

        var newMessage$1$2 = function newMessage$1(_ref7) {
          var type = _ref7.type,
            payload = _ref7.payload;
          return {
            cid: Date.now() + '-' + Math.random(),
            payload: payload,
            type: type,
          };
        }; // $FlowFixMe

        var getMessageData$1$2 = function getMessageData$1(_ref8) {
          var data = _ref8.data;
          return data || null;
        };

        var updateListeners$1$2 = function updateListeners$1(_ref9) {
          var _ref9$listeners = _ref9.listeners,
            listeners = _ref9$listeners === void 0 ? [] : _ref9$listeners,
            type = _ref9.type,
            func = _ref9.func,
            scope = _ref9.scope;
          return type && func
            ? [].concat(_toConsumableArray(listeners), [
                {
                  func: func,
                  type: type,
                  scope: scope,
                },
              ])
            : _toConsumableArray(listeners);
        };

        var localAddress$1$2 = [];

        var setLocalAddress$2 = function setLocalAddress(address) {
          localAddress$1$2 = [].concat(_toConsumableArray(localAddress$1$2), [address]);
          return localAddress$1$2;
        };
        /**
         *
         */

        var listeners$1$2 = [];
        /**
         * EventsServer
         * Waiting for client to initiate connection.
         *
         * successful connection message contain a port message.
         * server will use the port message to return confirmation for the connection.
         */

        var EventsServer$1 =
          /*#__PURE__*/
          (function() {
            function EventsServer(option) {
              var _this6 = this;

              _classCallCheck(this, EventsServer);

              this.eventType = option.eventType || 'RsocketEvents';
              this.address = option.address;
              this.debug = option.debug || false;

              this._getEventData =
                option.processEvent ||
                function(data) {
                  return data.type === _this6.eventType ? data.detail : null;
                };

              setLocalAddress$2(this.address);
              listeners$1$2 = updateListeners$1$2({
                func: this._handler,
                listeners: listeners$1$2,
                type: this.eventType,
                scope: 'global',
              }); // $FlowFixMe

              typeof addEventListener === 'function' && addEventListener('message', this._handler.bind(this)); // eslint-disable-line
            }

            _createClass(EventsServer, [
              {
                key: '_handler',
                value: function _handler(ev) {
                  var _this7 = this;

                  var event = this._getEventData(ev.data);

                  if (!event || event.address !== this.address || event.type !== 'rsocket-events-open-connection') {
                    return;
                  }

                  if (ev && Array.isArray(ev.ports)) {
                    this._clientChannelPort = ev.ports[0];

                    this._clientChannelPort.postMessage({
                      type: 'connect',
                    });

                    listeners$1$2 = updateListeners$1$2({
                      func: connectionHandler$1,
                      listeners: listeners$1$2,
                      type: 'message',
                      scope: 'port',
                    });
                    this._clientChannelPort &&
                      this._clientChannelPort.addEventListener('message', function(ev) {
                        return connectionHandler$1(ev, _this7.onStop.bind(_this7));
                      });
                    this._clientChannelPort && this._clientChannelPort.start();

                    this._onConnection(
                      new ServerChannel$1({
                        clientChannelPort: this._clientChannelPort || new MessagePort(),
                        debug: this.debug,
                      })
                    );
                  }
                },
              },
              {
                key: 'onConnect',
                value: function onConnect(cb) {
                  this._onConnection = cb;
                },
              },
              {
                key: 'onStop',
                value: function onStop() {
                  this._clientChannelPort &&
                    this._clientChannelPort.postMessage({
                      type: 'disconnect',
                    });
                  this._clientChannelPort && this._clientChannelPort.close();
                },
              },
            ]);

            return EventsServer;
          })();
        /**
         * ServerChannel implements IChannelServer
         *
         * server connection implementation
         */

        var ServerChannel$1 =
          /*#__PURE__*/
          (function() {
            function ServerChannel(_ref10) {
              var clientChannelPort = _ref10.clientChannelPort,
                debug = _ref10.debug;

              _classCallCheck(this, ServerChannel);

              this.clientChannelPort = clientChannelPort;
              this.debug = debug || false;
            }

            _createClass(ServerChannel, [
              {
                key: 'connect',
                value: function connect() {
                  var _this8 = this;

                  return {
                    disconnect: function disconnect() {
                      _this8.clientChannelPort.postMessage(
                        newMessage$1$2({
                          payload: null,
                          type: 'disconnect',
                        })
                      );

                      listeners$1$2.forEach(function(_ref11) {
                        var func = _ref11.func,
                          type = _ref11.type,
                          scope = _ref11.scope;
                        return scope === 'port'
                          ? _this8.clientChannelPort.removeEventListener(type, func) // $FlowFixMe
                          : removeEventListener(type, func);
                      });
                    },
                    receive: function receive(cb) {
                      listeners$1$2 = updateListeners$1$2({
                        func: requestMessage$1,
                        listeners: listeners$1$2,
                        type: 'message',
                        scope: 'port',
                      });

                      _this8.clientChannelPort.addEventListener('message', function(eventMsg) {
                        return requestMessage$1(eventMsg, cb, _this8.debug);
                      });
                    },
                    send: function send(msg) {
                      if (_this8.debug) {
                        console.log('Server responses with payload: '.concat(JSON.stringify(msg)));
                      }

                      _this8.clientChannelPort.postMessage(
                        newMessage$1$2({
                          payload: msg,
                          type: 'response',
                        })
                      );
                    },
                  };
                },
              },
            ]);

            return ServerChannel;
          })();

        var requestMessage$1 = function requestMessage(eventMsg, cb, debug) {
          var _getMessageData$ = getMessageData$1$2(eventMsg),
            payload = _getMessageData$.payload,
            type = _getMessageData$.type;

          if (type === 'request') {
            if (debug) {
              console.log('Server receive request with payload: '.concat(payload));
            }

            cb(payload);
          }
        };

        var connectionHandler$1 = function connectionHandler(ev, onStop) {
          var event = getMessageData$1$2(ev);

          switch (event.type) {
            case 'close': {
              onStop();
            }
          }
        };
        /**
         * written with <3 by scaleCube-js maintainers
         *
         * RSocketEventsServer Transport provider for event base messages
         * browser <--> browser
         *
         *
         */

        /**
         * A Events transport server.
         */

        var RSocketEventsServer$1 =
          /*#__PURE__*/
          (function() {
            function RSocketEventsServer(options) {
              _classCallCheck(this, RSocketEventsServer);

              this._subscribers = new Set();
              this.address = options.address;
              this._server = new EventsServer$1(options);
            }

            _createClass(RSocketEventsServer, [
              {
                key: 'start',
                value: function start() {
                  var _this9 = this;

                  return new build_4$1(function(subscriber) {
                    subscriber.onSubscribe({
                      cancel: function cancel() {
                        if (!_this9._server) {
                          return;
                        }

                        _this9._server.onStop();
                      },
                      request: function request() {
                        _this9._server.onConnect(function(eventClient) {
                          var eventClientConnection = new RSocketEventsClient$3({
                            address: _this9.address,
                            eventClient: eventClient,
                          });

                          if (eventClientConnection) {
                            _this9._subscribers.add(eventClientConnection);

                            eventClientConnection.connect();
                            subscriber.onNext(eventClientConnection);
                          } else {
                            subscriber.onError(
                              new Error('unable to create connection - address: '.concat(_this9.address))
                            );
                          }
                        });
                      },
                    });
                  });
                },
              },
              {
                key: 'stop',
                value: function stop() {
                  if (!this._subscribers) {
                    return;
                  }

                  this._subscribers.forEach(function(subscriber) {
                    return subscriber.close();
                  });

                  this._subscribers.clear();
                },
              },
            ]);

            return RSocketEventsServer;
          })();

        var serverFactory$1 = function serverFactory(options) {
          var address = options.address,
            factoryOptions = options.factoryOptions;
          validateAddress$1(address);
          var protocol = address.protocol;

          switch (protocol.toLowerCase()) {
            case 'pm':
              return new RSocketEventsServer$1({
                address: getFullAddress$1(address),
              });

            default:
              throw Error(NOT_VALID_PROTOCOL$1);
          }
        };

        var serializers$1 = {
          data: {
            deserialize: function deserialize(data) {
              return data;
            },
            serialize: function serialize(data) {
              return data;
            },
          },
          metadata: {
            deserialize: function deserialize(data) {
              return data;
            },
            serialize: function serialize(data) {
              return data;
            },
          },
        };
        var TransportBrowser$1 = {
          clientProvider: {
            providerFactory: clientFactory$1,
            serializers: serializers$1,
            factoryOptions: null,
          },
          serverProvider: {
            providerFactory: serverFactory$1,
            serializers: serializers$1,
            factoryOptions: null,
          },
        };
        var MEMBERSHIP_EVENT$1 = 'membershipEvent';
        var MEMBERSHIP_EVENT_INIT_SERVER$1 = 'membershipEventInitServer';
        var MEMBERSHIP_EVENT_INIT_CLIENT$1 = 'membershipEventInitClient';
        var MESSAGE$1 = 'message';
        var ADDED$1 = 'ADDED';
        var REMOVED$1 = 'REMOVED';
        var INIT$1 = 'INIT';

        var getMultiInitClientFromServer$1 = function getMultiInitClientFromServer(whoAmI, from) {
          return (
            'PLEASE PAY ATTENTION:\n            ' +
            whoAmI +
            ' received multiple ' +
            MEMBERSHIP_EVENT_INIT_CLIENT$1 +
            ' from ' +
            from +
            ',        \n            it might happen if the addresses are not unique. and might result with incorrect behavior\n            '
          );
        };

        var getKeysAsArray$1 = function getKeysAsArray(obj) {
          return (obj && Object.keys(obj)) || [];
        };

        var localAddress$5 = [];

        var setLocalAddress$3 = function setLocalAddress(address) {
          localAddress$5 = localAddress$5.concat([address]);
          return localAddress$5;
        };

        var genericPostMessage$5 = function genericPostMessage(data, transfer) {
          try {
            // @ts-ignore
            if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
              if (data.detail && data.detail.to && localAddress$5.indexOf(data.detail.to) > -1) {
                var event_1 = new MessageEvent('message', {
                  data: data,
                  ports: transfer ? transfer : undefined,
                });
                dispatchEvent(event_1);
              } else {
                // @ts-ignore
                postMessage(data, transfer ? transfer : undefined);
              }
            } else {
              if (data.type === 'ConnectWorkerEvent') {
                return;
              }

              postMessage(data, '*', transfer ? transfer : undefined);
            }
          } catch (e) {
            console.error('Unable to post message ', e);
          }
        };

        var __assign$1 =
          (undefined && undefined.__assign) ||
          function() {
            __assign$1 =
              Object.assign ||
              function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];

                  for (var p in s) {
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                  }
                }

                return t;
              };

            return __assign$1.apply(this, arguments);
          };

        var server$1 = function server(options) {
          var _a;

          var whoAmI = options.whoAmI,
            itemsToPublish = options.itemsToPublish,
            rSubjectMembers = options.rSubjectMembers,
            membersStatus = options.membersStatus,
            updateConnectedMember = options.updateConnectedMember,
            getMembershipEvent = options.getMembershipEvent,
            port1 = options.port1,
            seed = options.seed,
            debug = options.debug;
          var eventHandlers =
            ((_a = {}),
            (_a['globalEventsHandler' + whoAmI] = function(ev) {
              var _a, _b;

              var _c = ev.data,
                evType = _c.type,
                membershipEvent = _c.detail;

              if (evType === MEMBERSHIP_EVENT$1) {
                var metadata = membershipEvent.metadata,
                  type = membershipEvent.type,
                  to = membershipEvent.to,
                  from = membershipEvent.from,
                  origin_1 = membershipEvent.origin;

                if (origin_1 === whoAmI || from === whoAmI || from === to || to !== whoAmI) {
                  return;
                }

                if (membersStatus.membersState[origin_1]) {
                  saveToLogs$1(whoAmI, getMultiInitClientFromServer$1(whoAmI, origin_1), {}, debug, 'warn');
                  return;
                } // console.log('Server listen to global', { ...membersStatus.membersState },metadata, whoAmI)

                var mPort = ev && ev.ports && ev.ports[0];

                if (!mPort) {
                  console.error(whoAmI + ' unable to receive port from ' + from);
                }

                mPort.addEventListener(MESSAGE$1, eventHandlers['portEventsHandler' + whoAmI]);
                mPort.start(); // 1. update seed with the new metadata

                seed &&
                  port1.postMessage(
                    getMembershipEvent({
                      from: whoAmI,
                      to: seed,
                      origin: origin_1,
                      metadata: metadata,
                      type: ADDED$1,
                    })
                  ); // 2. response to initiator of the contact with all members data

                mPort.postMessage(
                  getMembershipEvent({
                    from: whoAmI,
                    to: from,
                    origin: whoAmI,
                    metadata: __assign$1(
                      {},
                      membersStatus.membersState,
                      ((_a = {}), (_a[whoAmI] = itemsToPublish), _a)
                    ),
                    type: INIT$1,
                  })
                ); // 3. update membersState

                membersStatus.membersState = __assign$1({}, membersStatus.membersState, metadata);
                updateConnectedMember({
                  metadata: metadata,
                  type: ADDED$1,
                  from: from,
                  to: to,
                  origin: origin_1,
                }); // 4. update ports

                membersStatus.membersPort = __assign$1(
                  {},
                  membersStatus.membersPort,
                  ((_b = {}), (_b[from] = mPort), _b)
                );
                rSubjectMembers &&
                  rSubjectMembers.next({
                    type: type,
                    items: metadata[origin_1],
                    from: origin_1,
                  });
                saveToLogs$1(
                  whoAmI,
                  whoAmI + ' server received ' + type + ' request from ' + from,
                  __assign$1({}, membersStatus.membersState),
                  debug
                );
              }

              if (evType === MEMBERSHIP_EVENT_INIT_SERVER$1) {
                var to = membershipEvent.to,
                  origin_2 = membershipEvent.origin;

                if (to === whoAmI && to !== origin_2) {
                  genericPostMessage$5({
                    detail: {
                      from: whoAmI,
                      to: origin_2,
                      origin: origin_2,
                    },
                    type: MEMBERSHIP_EVENT_INIT_CLIENT$1,
                  });
                }
              }
            }),
            (_a['portEventsHandler' + whoAmI] = function(ev) {
              var _a = ev.data,
                evType = _a.type,
                membershipEvent = _a.detail;
              var metadata = membershipEvent.metadata,
                type = membershipEvent.type,
                from = membershipEvent.from,
                to = membershipEvent.to,
                origin = membershipEvent.origin;

              if (origin === whoAmI || from === whoAmI || to !== whoAmI) {
                return;
              } // update seed with the change in members

              seed &&
                port1.postMessage(
                  getMembershipEvent({
                    from: whoAmI,
                    to: seed,
                    origin: origin,
                    metadata: metadata,
                    type: type,
                  })
                );

              switch (type) {
                case INIT$1:
                  break;

                case ADDED$1:
                  membersStatus.membersState = __assign$1({}, membersStatus.membersState, metadata);
                  break;

                case REMOVED$1:
                  if (membersStatus.membersState[origin]) {
                    delete membersStatus.membersState[origin];
                  }

                  var mPort = membersStatus.membersPort[origin];

                  if (mPort) {
                    mPort.postMessage(
                      getMembershipEvent({
                        type: REMOVED$1,
                        metadata: {},
                        to: from,
                        from: to,
                        origin: whoAmI,
                      })
                    );
                    membersStatus.membersPort[origin].close();
                  }

                  break;

                default:
                  saveToLogs$1(whoAmI, 'Not supported membership event type', {}, debug, 'warn');
                  return;
              }

              rSubjectMembers &&
                rSubjectMembers.next({
                  type: type,
                  items: metadata[origin],
                  from: origin,
                });
              updateConnectedMember({
                metadata: metadata,
                type: type === INIT$1 ? ADDED$1 : type,
                from: from,
                to: to,
                origin: origin,
              });
              saveToLogs$1(
                whoAmI,
                whoAmI + ' server received ' + type + ' request from ' + from,
                {
                  membersState: __assign$1({}, membersStatus.membersState),
                  membersPort: getKeysAsArray$1(__assign$1({}, membersStatus.membersPort)),
                },
                debug
              );
            }),
            _a);
          return {
            start: function start() {
              addEventListener(MESSAGE$1, eventHandlers['globalEventsHandler' + whoAmI]);
              genericPostMessage$5({
                detail: {
                  whoAmI: whoAmI,
                },
                type: 'ConnectWorkerEvent',
              });
            },
            stop: function stop() {
              removeEventListener(MESSAGE$1, eventHandlers['globalEventsHandler' + whoAmI]);
              var membersList = getKeysAsArray$1(__assign$1({}, membersStatus.membersPort));
              membersList.forEach(function(to) {
                var _a;

                var mPort = membersStatus.membersPort[to];
                mPort &&
                  mPort.postMessage(
                    getMembershipEvent({
                      to: to,
                      from: whoAmI,
                      origin: whoAmI,
                      metadata: ((_a = {}), (_a[whoAmI] = itemsToPublish), _a),
                      type: REMOVED$1,
                    })
                  );
                mPort.removeEventListener(MESSAGE$1, eventHandlers['portEventsHandler' + whoAmI]);
                mPort.close();
              });
              return Promise.resolve('');
            },
          };
        };

        var __assign$5 =
          (undefined && undefined.__assign) ||
          function() {
            __assign$5 =
              Object.assign ||
              function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];

                  for (var p in s) {
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                  }
                }

                return t;
              };

            return __assign$5.apply(this, arguments);
          };

        var client$1 = function client(options) {
          var _a;

          var whoAmI = options.whoAmI,
            membersStatus = options.membersStatus,
            updateConnectedMember = options.updateConnectedMember,
            getMembershipEvent = options.getMembershipEvent,
            itemsToPublish = options.itemsToPublish,
            rSubjectMembers = options.rSubjectMembers,
            port1 = options.port1,
            port2 = options.port2,
            debug = options.debug,
            retry = options.retry,
            seedAddress = options.seedAddress;
          var seed = '';
          var retryTimer = null;
          var countServers = 0;
          var eventHandlers =
            ((_a = {}), // tslint:disable-next-line
            (_a['globalEventsHandler' + whoAmI] = function(ev) {
              var _a;

              var _b = ev.data,
                evType = _b.type,
                membershipEvent = _b.detail;

              if (evType === MEMBERSHIP_EVENT_INIT_CLIENT$1) {
                var from = membershipEvent.from,
                  origin_1 = membershipEvent.origin;

                if (from === seed && origin_1 && origin_1 === whoAmI) {
                  countServers++;

                  if (countServers > 1) {
                    saveToLogs$1(whoAmI, getMultiInitClientFromServer$1(whoAmI, from), {}, debug, 'warn');
                    return;
                  } // @ts-ignore

                  port1.addEventListener(MESSAGE$1, eventHandlers['portEventsHandler' + whoAmI].bind(this));
                  port1.start();
                  clearInterval(retryTimer);
                  removeEventListener(MESSAGE$1, eventHandlers['globalEventsHandler' + whoAmI]);
                  retryTimer = null;
                  genericPostMessage$5(
                    getMembershipEvent({
                      metadata: ((_a = {}), (_a[whoAmI] = itemsToPublish), _a),
                      type: INIT$1,
                      to: seed,
                      from: whoAmI,
                      origin: whoAmI,
                    }),
                    [port2]
                  );
                }
              }
            }), // tslint:disable-next-line
            (_a['portEventsHandler' + whoAmI] = function(ev) {
              var _a = ev.data,
                evType = _a.type,
                membershipEvent = _a.detail;

              if (evType === MEMBERSHIP_EVENT$1) {
                var metadata_1 = membershipEvent.metadata,
                  type_1 = membershipEvent.type,
                  from = membershipEvent.from,
                  to = membershipEvent.to,
                  origin_2 = membershipEvent.origin;

                if (origin_2 === whoAmI || from === whoAmI || from === to) {
                  return;
                }

                switch (type_1) {
                  case INIT$1:
                    clearInterval(retryTimer);
                    removeEventListener(MESSAGE$1, eventHandlers['globalEventsHandler' + whoAmI]);
                    retryTimer = null;
                    membersStatus.membersState = __assign$5({}, membersStatus.membersState, metadata_1); // @ts-ignore

                    this.resolveClusterStart
                      ? this.resolveClusterStart()
                      : console.error('unable to resolve cluster client.');
                    break;

                  case ADDED$1:
                    membersStatus.membersState = __assign$5({}, membersStatus.membersState, metadata_1);
                    break;

                  case REMOVED$1:
                    if (membersStatus.membersState[from]) {
                      delete membersStatus.membersState[from];
                    }

                    break;
                }

                updateConnectedMember({
                  metadata: metadata_1,
                  type: type_1 === INIT$1 ? ADDED$1 : type_1,
                  from: from,
                  to: to,
                  origin: origin_2,
                });
                saveToLogs$1(
                  whoAmI,
                  whoAmI + ' client received ' + type_1 + ' request from ' + from,
                  __assign$5({}, membersStatus.membersState),
                  debug
                );
                Object.keys(metadata_1).forEach(function(member) {
                  return (
                    rSubjectMembers &&
                    rSubjectMembers.next({
                      type: type_1,
                      items: metadata_1[member],
                      from: member,
                    })
                  );
                });
              }
            }),
            _a);
          return Object.freeze({
            start: function start() {
              return new Promise(function(resolve, reject) {
                if (!seedAddress) {
                  resolve();
                } else {
                  seed = getFullAddress$1(seedAddress);

                  var ClusterStart = function ClusterStart() {
                    return {
                      resolveClusterStart: resolve,
                    };
                  };

                  addEventListener(MESSAGE$1, eventHandlers['globalEventsHandler' + whoAmI].bind(ClusterStart()));
                  retryTimer = setInterval(function() {
                    genericPostMessage$5({
                      detail: {
                        origin: whoAmI,
                        to: seed,
                      },
                      type: MEMBERSHIP_EVENT_INIT_SERVER$1,
                    });
                  }, retry.timeout);
                }
              });
            },
            stop: function stop() {
              var _a, _b;

              updateConnectedMember({
                metadata: ((_a = {}), (_a[whoAmI] = itemsToPublish), _a),
                type: REMOVED$1,
                from: whoAmI,
                to: null,
                origin: whoAmI,
              });
              port1.postMessage(
                getMembershipEvent({
                  metadata: ((_b = {}), (_b[whoAmI] = itemsToPublish), _b),
                  type: REMOVED$1,
                  from: whoAmI,
                  to: seed,
                  origin: whoAmI,
                })
              );
              removeEventListener(MESSAGE$1, eventHandlers['globalEventsHandler' + whoAmI]);
              port1.removeEventListener(MESSAGE$1, eventHandlers['portEventsHandler' + whoAmI]);
              port1.close();
              port2.close();
              saveToLogs$1(whoAmI, whoAmI + ' close client', __assign$5({}, membersStatus.membersState), debug);
            },
          });
        };

        var createMember$1 = function createMember(address, membersStatus) {
          var whoAmI = getFullAddress$1(address);
          setLocalAddress$3(whoAmI);
          /**
           * membership event format
           * @param from
           * @param to
           * @param metadata
           * @param origin
           * @param type
           */

          var getMembershipEvent = function getMembershipEvent(_a) {
            var from = _a.from,
              to = _a.to,
              metadata = _a.metadata,
              origin = _a.origin,
              type = _a.type;
            return {
              detail: {
                metadata: metadata,
                type: type,
                from: from,
                origin: origin,
                to: to,
              },
              type: MEMBERSHIP_EVENT$1,
            };
          };
          /**
           * loop on all connected members and update them on the change
           * @param type
           * @param metadata
           * @param from
           * @param to
           * @param origin
           */

          var updateConnectedMember = function updateConnectedMember(_a) {
            var type = _a.type,
              metadata = _a.metadata,
              from = _a.from,
              to = _a.to,
              origin = _a.origin;
            var membersPort = membersStatus.membersPort;
            Object.keys(membersPort).forEach(function(nextMember) {
              if (from !== nextMember && whoAmI !== nextMember && origin !== nextMember) {
                var mPort = membersPort[nextMember];
                mPort.postMessage(
                  getMembershipEvent({
                    from: whoAmI,
                    to: nextMember,
                    origin: from,
                    metadata: metadata,
                    type: type,
                  })
                );
              }
            });
          };

          return {
            getMembershipEvent: getMembershipEvent,
            updateConnectedMember: updateConnectedMember,
            whoAmI: whoAmI,
          };
        };

        var __assign$6 =
          (undefined && undefined.__assign) ||
          function() {
            __assign$6 =
              Object.assign ||
              function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];

                  for (var p in s) {
                    if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                  }
                }

                return t;
              };

            return __assign$6.apply(this, arguments);
          };

        var __awaiter$1 =
          (undefined && undefined.__awaiter) ||
          function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))(function(resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e) {
                  reject(e);
                }
              }

              function rejected(value) {
                try {
                  step(generator['throw'](value));
                } catch (e) {
                  reject(e);
                }
              }

              function step(result) {
                result.done
                  ? resolve(result.value)
                  : new P(function(resolve) {
                      resolve(result.value);
                    }).then(fulfilled, rejected);
              }

              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };

        var __generator$1 =
          (undefined && undefined.__generator) ||
          function(thisArg, body) {
            var _ = {
                label: 0,
                sent: function sent() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: [],
              },
              f,
              y,
              t,
              g;
            return (
              (g = {
                next: verb(0),
                throw: verb(1),
                return: verb(2),
              }),
              typeof Symbol === 'function' &&
                (g[Symbol.iterator] = function() {
                  return this;
                }),
              g
            );

            function verb(n) {
              return function(v) {
                return step([n, v]);
              };
            }

            function step(op) {
              if (f) throw new TypeError('Generator is already executing.');

              while (_) {
                try {
                  if (
                    ((f = 1),
                    y &&
                      (t =
                        op[0] & 2 ? y['return'] : op[0] ? y['throw'] || ((t = y['return']) && t.call(y), 0) : y.next) &&
                      !(t = t.call(y, op[1])).done)
                  )
                    return t;
                  if (((y = 0), t)) op = [op[0] & 2, t.value];

                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op;
                      break;

                    case 4:
                      _.label++;
                      return {
                        value: op[1],
                        done: false,
                      };

                    case 5:
                      _.label++;
                      y = op[1];
                      op = [0];
                      continue;

                    case 7:
                      op = _.ops.pop();

                      _.trys.pop();

                      continue;

                    default:
                      if (!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                      }

                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                        _.label = op[1];
                        break;
                      }

                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                      }

                      if (t && _.label < t[2]) {
                        _.label = t[2];

                        _.ops.push(op);

                        break;
                      }

                      if (t[2]) _.ops.pop();

                      _.trys.pop();

                      continue;
                  }

                  op = body.call(thisArg, _);
                } catch (e) {
                  op = [6, e];
                  y = 0;
                } finally {
                  f = t = 0;
                }
              }

              if (op[0] & 5) throw op[1];
              return {
                value: op[0] ? op[1] : void 0,
                done: true,
              };
            }
          };

        var _this$1 = undefined;

        var joinCluster$1 = function joinCluster(options) {
          var address = options.address,
            seedAddress = options.seedAddress,
            itemsToPublish = options.itemsToPublish,
            retry = options.retry,
            debug = options.debug;

          var _a = new MessageChannel(),
            port1 = _a.port1,
            port2 = _a.port2;

          var membersStatus = {
            membersPort: {},
            membersState: {},
          };
          var delayedActions = [];
          var isConnected = !seedAddress;
          var rSubjectMembers = new _rxjs.Subject();
          var clientPort;

          var _b = createMember$1(address, membersStatus),
            updateConnectedMember = _b.updateConnectedMember,
            getMembershipEvent = _b.getMembershipEvent,
            whoAmI = _b.whoAmI;

          var serverPort = server$1({
            whoAmI: whoAmI,
            membersStatus: membersStatus,
            rSubjectMembers: rSubjectMembers,
            itemsToPublish: itemsToPublish,
            updateConnectedMember: updateConnectedMember,
            getMembershipEvent: getMembershipEvent,
            port1: port1,
            seed: seedAddress ? getFullAddress$1(seedAddress) : undefined,
            debug: debug,
          });
          serverPort.start();
          clientPort = client$1({
            whoAmI: whoAmI,
            updateConnectedMember: updateConnectedMember,
            getMembershipEvent: getMembershipEvent,
            membersStatus: membersStatus,
            itemsToPublish: itemsToPublish,
            rSubjectMembers: rSubjectMembers,
            port1: port1,
            port2: port2,
            retry: retry || {
              timeout: 10,
            },
            debug: debug,
            seedAddress: seedAddress,
          });
          clientPort.start().then(function() {
            isConnected = true;

            if (delayedActions.length > 0) {
              delayedActions.forEach(function(action) {
                return action && action();
              });
            }
          });
          return Object.freeze({
            listen$: function listen$() {
              return rSubjectMembers.asObservable();
            },
            getCurrentMembersData: function getCurrentMembersData() {
              return new Promise(function(resolve, reject) {
                var getMemberStateCluster = function getMemberStateCluster() {
                  resolve(__assign$6({}, membersStatus.membersState));
                };

                if (!isConnected) {
                  delayedActions.push(getMemberStateCluster);
                } else {
                  getMemberStateCluster();
                }
              });
            },
            destroy: function destroy() {
              return new Promise(function(resolve, reject) {
                var destroyCluster = function destroyCluster() {
                  return __awaiter$1(_this$1, void 0, void 0, function() {
                    var _a, e_1;

                    return __generator$1(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          _b.trys.push([0, 4, , 5]);

                          return [
                            4,
                            /*yield*/
                            serverPort.stop(),
                          ];

                        case 1:
                          _b.sent();

                          _a = clientPort;
                          if (!_a)
                            return [
                              3,
                              /*break*/
                              3,
                            ];
                          return [
                            4,
                            /*yield*/
                            clientPort.stop(),
                          ];

                        case 2:
                          _a = _b.sent();
                          _b.label = 3;

                        case 3:
                          return [
                            3,
                            /*break*/
                            5,
                          ];

                        case 4:
                          e_1 = _b.sent();
                          saveToLogs$1(whoAmI, 'unable to destroy ' + whoAmI + ': ' + e_1, {}, debug, 'warn');
                          return [
                            3,
                            /*break*/
                            5,
                          ];

                        case 5:
                          rSubjectMembers.complete();
                          membersStatus.membersPort = {};
                          membersStatus.membersState = {};
                          resolve('');
                          return [
                            2,
                            /*return*/
                          ];
                      }
                    });
                  });
                };

                if (!isConnected) {
                  delayedActions.push(destroyCluster);
                } else {
                  return destroyCluster();
                }
              });
            },
          });
        };

        var retryRouter = function retryRouter(_a) {
          var period = _a.period,
            maxRetry = _a.maxRetry;
          return function(options) {
            var message = options.message,
              lookUp = options.lookUp;
            var qualifier = message.qualifier;
            var retry = 0;
            return new Promise(function(resolve, reject) {
              var checkRegistry = function checkRegistry() {
                var endpoints = lookUp({
                  qualifier: qualifier,
                });

                if (!(endpoints && Array.isArray(endpoints) && endpoints.length > 0)) {
                  if (maxRetry && maxRetry >= retry) {
                    retry++;
                  }

                  if (!maxRetry || maxRetry >= retry) {
                    setTimeout(function() {
                      checkRegistry();
                    }, period);
                  } else {
                    reject(null);
                  }
                } else {
                  resolve(endpoints[0]);
                }
              };

              checkRegistry();
            });
          };
        };

        var createMicroservice$1 = function(config) {
          return createMicroservice(
            _assign(
              {
                // @ts-ignore
                transport: TransportBrowser$1,
                cluster: joinCluster$1,
                defaultRouter: retryRouter({
                  period: 10,
                  maxRetry: 500,
                }),
              },
              config
            )
          );
        };

        exports.createMicroservice = createMicroservice$1;
      },
      {
        'core-js/modules/es.symbol': '../../../node_modules/core-js/modules/es.symbol.js',
        'core-js/modules/es.symbol.description': '../../../node_modules/core-js/modules/es.symbol.description.js',
        'core-js/modules/es.symbol.async-iterator': '../../../node_modules/core-js/modules/es.symbol.async-iterator.js',
        'core-js/modules/es.symbol.iterator': '../../../node_modules/core-js/modules/es.symbol.iterator.js',
        'core-js/modules/es.array.concat': '../../../node_modules/core-js/modules/es.array.concat.js',
        'core-js/modules/es.array.iterator': '../../../node_modules/core-js/modules/es.array.iterator.js',
        'core-js/modules/es.object.assign': '../../../node_modules/core-js/modules/es.object.assign.js',
        'core-js/modules/es.object.get-own-property-descriptor':
          '../../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js',
        'core-js/modules/es.object.to-string': '../../../node_modules/core-js/modules/es.object.to-string.js',
        'core-js/modules/es.promise': '../../../node_modules/core-js/modules/es.promise.js',
        'core-js/modules/es.string.iterator': '../../../node_modules/core-js/modules/es.string.iterator.js',
        'core-js/modules/web.dom-collections.iterator':
          '../../../node_modules/core-js/modules/web.dom-collections.iterator.js',
        'core-js/modules/es.array.copy-within': '../../../node_modules/core-js/modules/es.array.copy-within.js',
        'core-js/modules/es.array.filter': '../../../node_modules/core-js/modules/es.array.filter.js',
        'core-js/modules/es.array.includes': '../../../node_modules/core-js/modules/es.array.includes.js',
        'core-js/modules/es.array.join': '../../../node_modules/core-js/modules/es.array.join.js',
        'core-js/modules/es.array.map': '../../../node_modules/core-js/modules/es.array.map.js',
        'core-js/modules/es.array.slice': '../../../node_modules/core-js/modules/es.array.slice.js',
        'core-js/modules/es.array.splice': '../../../node_modules/core-js/modules/es.array.splice.js',
        'core-js/modules/es.array-buffer.constructor':
          '../../../node_modules/core-js/modules/es.array-buffer.constructor.js',
        'core-js/modules/es.function.name': '../../../node_modules/core-js/modules/es.function.name.js',
        'core-js/modules/es.map': '../../../node_modules/core-js/modules/es.map.js',
        'core-js/modules/es.number.constructor': '../../../node_modules/core-js/modules/es.number.constructor.js',
        'core-js/modules/es.number.is-integer': '../../../node_modules/core-js/modules/es.number.is-integer.js',
        'core-js/modules/es.number.max-safe-integer':
          '../../../node_modules/core-js/modules/es.number.max-safe-integer.js',
        'core-js/modules/es.object.freeze': '../../../node_modules/core-js/modules/es.object.freeze.js',
        'core-js/modules/es.object.keys': '../../../node_modules/core-js/modules/es.object.keys.js',
        'core-js/modules/es.object.values': '../../../node_modules/core-js/modules/es.object.values.js',
        'core-js/modules/es.regexp.flags': '../../../node_modules/core-js/modules/es.regexp.flags.js',
        'core-js/modules/es.regexp.to-string': '../../../node_modules/core-js/modules/es.regexp.to-string.js',
        'core-js/modules/es.set': '../../../node_modules/core-js/modules/es.set.js',
        'core-js/modules/es.string.includes': '../../../node_modules/core-js/modules/es.string.includes.js',
        'core-js/modules/es.string.replace': '../../../node_modules/core-js/modules/es.string.replace.js',
        'core-js/modules/es.string.split': '../../../node_modules/core-js/modules/es.string.split.js',
        'core-js/modules/es.typed-array.uint8-array':
          '../../../node_modules/core-js/modules/es.typed-array.uint8-array.js',
        'core-js/modules/es.typed-array.copy-within':
          '../../../node_modules/core-js/modules/es.typed-array.copy-within.js',
        'core-js/modules/es.typed-array.every': '../../../node_modules/core-js/modules/es.typed-array.every.js',
        'core-js/modules/es.typed-array.fill': '../../../node_modules/core-js/modules/es.typed-array.fill.js',
        'core-js/modules/es.typed-array.filter': '../../../node_modules/core-js/modules/es.typed-array.filter.js',
        'core-js/modules/es.typed-array.find': '../../../node_modules/core-js/modules/es.typed-array.find.js',
        'core-js/modules/es.typed-array.find-index':
          '../../../node_modules/core-js/modules/es.typed-array.find-index.js',
        'core-js/modules/es.typed-array.for-each': '../../../node_modules/core-js/modules/es.typed-array.for-each.js',
        'core-js/modules/es.typed-array.includes': '../../../node_modules/core-js/modules/es.typed-array.includes.js',
        'core-js/modules/es.typed-array.index-of': '../../../node_modules/core-js/modules/es.typed-array.index-of.js',
        'core-js/modules/es.typed-array.iterator': '../../../node_modules/core-js/modules/es.typed-array.iterator.js',
        'core-js/modules/es.typed-array.join': '../../../node_modules/core-js/modules/es.typed-array.join.js',
        'core-js/modules/es.typed-array.last-index-of':
          '../../../node_modules/core-js/modules/es.typed-array.last-index-of.js',
        'core-js/modules/es.typed-array.map': '../../../node_modules/core-js/modules/es.typed-array.map.js',
        'core-js/modules/es.typed-array.reduce': '../../../node_modules/core-js/modules/es.typed-array.reduce.js',
        'core-js/modules/es.typed-array.reduce-right':
          '../../../node_modules/core-js/modules/es.typed-array.reduce-right.js',
        'core-js/modules/es.typed-array.reverse': '../../../node_modules/core-js/modules/es.typed-array.reverse.js',
        'core-js/modules/es.typed-array.set': '../../../node_modules/core-js/modules/es.typed-array.set.js',
        'core-js/modules/es.typed-array.slice': '../../../node_modules/core-js/modules/es.typed-array.slice.js',
        'core-js/modules/es.typed-array.some': '../../../node_modules/core-js/modules/es.typed-array.some.js',
        'core-js/modules/es.typed-array.sort': '../../../node_modules/core-js/modules/es.typed-array.sort.js',
        'core-js/modules/es.typed-array.subarray': '../../../node_modules/core-js/modules/es.typed-array.subarray.js',
        'core-js/modules/es.typed-array.to-locale-string':
          '../../../node_modules/core-js/modules/es.typed-array.to-locale-string.js',
        'core-js/modules/es.typed-array.to-string': '../../../node_modules/core-js/modules/es.typed-array.to-string.js',
        'core-js/modules/web.dom-collections.for-each':
          '../../../node_modules/core-js/modules/web.dom-collections.for-each.js',
        rxjs: '../../../node_modules/rxjs/_esm5/index.js',
        'core-js/modules/es.array.find-index': '../../../node_modules/core-js/modules/es.array.find-index.js',
        buffer: '../../../../../../.config/yarn/global/node_modules/buffer/index.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/audit.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.audit = audit;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function audit(durationSelector) {
          return function auditOperatorFunction(source) {
            return source.lift(new AuditOperator(durationSelector));
          };
        }

        var AuditOperator =
          /*@__PURE__*/
          (function() {
            function AuditOperator(durationSelector) {
              this.durationSelector = durationSelector;
            }

            AuditOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
            };

            return AuditOperator;
          })();

        var AuditSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(AuditSubscriber, _super);

            function AuditSubscriber(destination, durationSelector) {
              var _this = _super.call(this, destination) || this;

              _this.durationSelector = durationSelector;
              _this.hasValue = false;
              return _this;
            }

            AuditSubscriber.prototype._next = function(value) {
              this.value = value;
              this.hasValue = true;

              if (!this.throttled) {
                var duration = void 0;

                try {
                  var durationSelector = this.durationSelector;
                  duration = durationSelector(value);
                } catch (err) {
                  return this.destination.error(err);
                }

                var innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, duration);

                if (!innerSubscription || innerSubscription.closed) {
                  this.clearThrottle();
                } else {
                  this.add((this.throttled = innerSubscription));
                }
              }
            };

            AuditSubscriber.prototype.clearThrottle = function() {
              var _a = this,
                value = _a.value,
                hasValue = _a.hasValue,
                throttled = _a.throttled;

              if (throttled) {
                this.remove(throttled);
                this.throttled = null;
                throttled.unsubscribe();
              }

              if (hasValue) {
                this.value = null;
                this.hasValue = false;
                this.destination.next(value);
              }
            };

            AuditSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex) {
              this.clearThrottle();
            };

            AuditSubscriber.prototype.notifyComplete = function() {
              this.clearThrottle();
            };

            return AuditSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/auditTime.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.auditTime = auditTime;

        var _async = require('../scheduler/async');

        var _audit = require('./audit');

        var _timer = require('../observable/timer');

        /** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
        function auditTime(duration, scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return (0, _audit.audit)(function() {
            return (0, _timer.timer)(duration, scheduler);
          });
        }
      },
      {
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        './audit': '../../../node_modules/rxjs/_esm5/internal/operators/audit.js',
        '../observable/timer': '../../../node_modules/rxjs/_esm5/internal/observable/timer.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/buffer.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.buffer = buffer;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function buffer(closingNotifier) {
          return function bufferOperatorFunction(source) {
            return source.lift(new BufferOperator(closingNotifier));
          };
        }

        var BufferOperator =
          /*@__PURE__*/
          (function() {
            function BufferOperator(closingNotifier) {
              this.closingNotifier = closingNotifier;
            }

            BufferOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
            };

            return BufferOperator;
          })();

        var BufferSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BufferSubscriber, _super);

            function BufferSubscriber(destination, closingNotifier) {
              var _this = _super.call(this, destination) || this;

              _this.buffer = [];

              _this.add((0, _subscribeToResult.subscribeToResult)(_this, closingNotifier));

              return _this;
            }

            BufferSubscriber.prototype._next = function(value) {
              this.buffer.push(value);
            };

            BufferSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              var buffer = this.buffer;
              this.buffer = [];
              this.destination.next(buffer);
            };

            return BufferSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/bufferCount.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.bufferCount = bufferCount;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function bufferCount(bufferSize, startBufferEvery) {
          if (startBufferEvery === void 0) {
            startBufferEvery = null;
          }

          return function bufferCountOperatorFunction(source) {
            return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
          };
        }

        var BufferCountOperator =
          /*@__PURE__*/
          (function() {
            function BufferCountOperator(bufferSize, startBufferEvery) {
              this.bufferSize = bufferSize;
              this.startBufferEvery = startBufferEvery;

              if (!startBufferEvery || bufferSize === startBufferEvery) {
                this.subscriberClass = BufferCountSubscriber;
              } else {
                this.subscriberClass = BufferSkipCountSubscriber;
              }
            }

            BufferCountOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
            };

            return BufferCountOperator;
          })();

        var BufferCountSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BufferCountSubscriber, _super);

            function BufferCountSubscriber(destination, bufferSize) {
              var _this = _super.call(this, destination) || this;

              _this.bufferSize = bufferSize;
              _this.buffer = [];
              return _this;
            }

            BufferCountSubscriber.prototype._next = function(value) {
              var buffer = this.buffer;
              buffer.push(value);

              if (buffer.length == this.bufferSize) {
                this.destination.next(buffer);
                this.buffer = [];
              }
            };

            BufferCountSubscriber.prototype._complete = function() {
              var buffer = this.buffer;

              if (buffer.length > 0) {
                this.destination.next(buffer);
              }

              _super.prototype._complete.call(this);
            };

            return BufferCountSubscriber;
          })(_Subscriber.Subscriber);

        var BufferSkipCountSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BufferSkipCountSubscriber, _super);

            function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
              var _this = _super.call(this, destination) || this;

              _this.bufferSize = bufferSize;
              _this.startBufferEvery = startBufferEvery;
              _this.buffers = [];
              _this.count = 0;
              return _this;
            }

            BufferSkipCountSubscriber.prototype._next = function(value) {
              var _a = this,
                bufferSize = _a.bufferSize,
                startBufferEvery = _a.startBufferEvery,
                buffers = _a.buffers,
                count = _a.count;

              this.count++;

              if (count % startBufferEvery === 0) {
                buffers.push([]);
              }

              for (var i = buffers.length; i--; ) {
                var buffer = buffers[i];
                buffer.push(value);

                if (buffer.length === bufferSize) {
                  buffers.splice(i, 1);
                  this.destination.next(buffer);
                }
              }
            };

            BufferSkipCountSubscriber.prototype._complete = function() {
              var _a = this,
                buffers = _a.buffers,
                destination = _a.destination;

              while (buffers.length > 0) {
                var buffer = buffers.shift();

                if (buffer.length > 0) {
                  destination.next(buffer);
                }
              }

              _super.prototype._complete.call(this);
            };

            return BufferSkipCountSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/bufferTime.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.bufferTime = bufferTime;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _async = require('../scheduler/async');

        var _Subscriber = require('../Subscriber');

        var _isScheduler = require('../util/isScheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
        function bufferTime(bufferTimeSpan) {
          var length = arguments.length;
          var scheduler = _async.async;

          if ((0, _isScheduler.isScheduler)(arguments[arguments.length - 1])) {
            scheduler = arguments[arguments.length - 1];
            length--;
          }

          var bufferCreationInterval = null;

          if (length >= 2) {
            bufferCreationInterval = arguments[1];
          }

          var maxBufferSize = Number.POSITIVE_INFINITY;

          if (length >= 3) {
            maxBufferSize = arguments[2];
          }

          return function bufferTimeOperatorFunction(source) {
            return source.lift(
              new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)
            );
          };
        }

        var BufferTimeOperator =
          /*@__PURE__*/
          (function() {
            function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
              this.bufferTimeSpan = bufferTimeSpan;
              this.bufferCreationInterval = bufferCreationInterval;
              this.maxBufferSize = maxBufferSize;
              this.scheduler = scheduler;
            }

            BufferTimeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new BufferTimeSubscriber(
                  subscriber,
                  this.bufferTimeSpan,
                  this.bufferCreationInterval,
                  this.maxBufferSize,
                  this.scheduler
                )
              );
            };

            return BufferTimeOperator;
          })();

        var Context =
          /*@__PURE__*/
          (function() {
            function Context() {
              this.buffer = [];
            }

            return Context;
          })();

        var BufferTimeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BufferTimeSubscriber, _super);

            function BufferTimeSubscriber(
              destination,
              bufferTimeSpan,
              bufferCreationInterval,
              maxBufferSize,
              scheduler
            ) {
              var _this = _super.call(this, destination) || this;

              _this.bufferTimeSpan = bufferTimeSpan;
              _this.bufferCreationInterval = bufferCreationInterval;
              _this.maxBufferSize = maxBufferSize;
              _this.scheduler = scheduler;
              _this.contexts = [];

              var context = _this.openContext();

              _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

              if (_this.timespanOnly) {
                var timeSpanOnlyState = {
                  subscriber: _this,
                  context: context,
                  bufferTimeSpan: bufferTimeSpan,
                };

                _this.add(
                  (context.closeAction = scheduler.schedule(
                    dispatchBufferTimeSpanOnly,
                    bufferTimeSpan,
                    timeSpanOnlyState
                  ))
                );
              } else {
                var closeState = {
                  subscriber: _this,
                  context: context,
                };
                var creationState = {
                  bufferTimeSpan: bufferTimeSpan,
                  bufferCreationInterval: bufferCreationInterval,
                  subscriber: _this,
                  scheduler: scheduler,
                };

                _this.add((context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState)));

                _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
              }

              return _this;
            }

            BufferTimeSubscriber.prototype._next = function(value) {
              var contexts = this.contexts;
              var len = contexts.length;
              var filledBufferContext;

              for (var i = 0; i < len; i++) {
                var context_1 = contexts[i];
                var buffer = context_1.buffer;
                buffer.push(value);

                if (buffer.length == this.maxBufferSize) {
                  filledBufferContext = context_1;
                }
              }

              if (filledBufferContext) {
                this.onBufferFull(filledBufferContext);
              }
            };

            BufferTimeSubscriber.prototype._error = function(err) {
              this.contexts.length = 0;

              _super.prototype._error.call(this, err);
            };

            BufferTimeSubscriber.prototype._complete = function() {
              var _a = this,
                contexts = _a.contexts,
                destination = _a.destination;

              while (contexts.length > 0) {
                var context_2 = contexts.shift();
                destination.next(context_2.buffer);
              }

              _super.prototype._complete.call(this);
            };

            BufferTimeSubscriber.prototype._unsubscribe = function() {
              this.contexts = null;
            };

            BufferTimeSubscriber.prototype.onBufferFull = function(context) {
              this.closeContext(context);
              var closeAction = context.closeAction;
              closeAction.unsubscribe();
              this.remove(closeAction);

              if (!this.closed && this.timespanOnly) {
                context = this.openContext();
                var bufferTimeSpan = this.bufferTimeSpan;
                var timeSpanOnlyState = {
                  subscriber: this,
                  context: context,
                  bufferTimeSpan: bufferTimeSpan,
                };
                this.add(
                  (context.closeAction = this.scheduler.schedule(
                    dispatchBufferTimeSpanOnly,
                    bufferTimeSpan,
                    timeSpanOnlyState
                  ))
                );
              }
            };

            BufferTimeSubscriber.prototype.openContext = function() {
              var context = new Context();
              this.contexts.push(context);
              return context;
            };

            BufferTimeSubscriber.prototype.closeContext = function(context) {
              this.destination.next(context.buffer);
              var contexts = this.contexts;
              var spliceIndex = contexts ? contexts.indexOf(context) : -1;

              if (spliceIndex >= 0) {
                contexts.splice(contexts.indexOf(context), 1);
              }
            };

            return BufferTimeSubscriber;
          })(_Subscriber.Subscriber);

        function dispatchBufferTimeSpanOnly(state) {
          var subscriber = state.subscriber;
          var prevContext = state.context;

          if (prevContext) {
            subscriber.closeContext(prevContext);
          }

          if (!subscriber.closed) {
            state.context = subscriber.openContext();
            state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
          }
        }

        function dispatchBufferCreation(state) {
          var bufferCreationInterval = state.bufferCreationInterval,
            bufferTimeSpan = state.bufferTimeSpan,
            subscriber = state.subscriber,
            scheduler = state.scheduler;
          var context = subscriber.openContext();
          var action = this;

          if (!subscriber.closed) {
            subscriber.add(
              (context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
                subscriber: subscriber,
                context: context,
              }))
            );
            action.schedule(state, bufferCreationInterval);
          }
        }

        function dispatchBufferClose(arg) {
          var subscriber = arg.subscriber,
            context = arg.context;
          subscriber.closeContext(context);
        }
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.bufferToggle = bufferToggle;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscription = require('../Subscription');

        var _subscribeToResult = require('../util/subscribeToResult');

        var _OuterSubscriber = require('../OuterSubscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
        function bufferToggle(openings, closingSelector) {
          return function bufferToggleOperatorFunction(source) {
            return source.lift(new BufferToggleOperator(openings, closingSelector));
          };
        }

        var BufferToggleOperator =
          /*@__PURE__*/
          (function() {
            function BufferToggleOperator(openings, closingSelector) {
              this.openings = openings;
              this.closingSelector = closingSelector;
            }

            BufferToggleOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
            };

            return BufferToggleOperator;
          })();

        var BufferToggleSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BufferToggleSubscriber, _super);

            function BufferToggleSubscriber(destination, openings, closingSelector) {
              var _this = _super.call(this, destination) || this;

              _this.openings = openings;
              _this.closingSelector = closingSelector;
              _this.contexts = [];

              _this.add((0, _subscribeToResult.subscribeToResult)(_this, openings));

              return _this;
            }

            BufferToggleSubscriber.prototype._next = function(value) {
              var contexts = this.contexts;
              var len = contexts.length;

              for (var i = 0; i < len; i++) {
                contexts[i].buffer.push(value);
              }
            };

            BufferToggleSubscriber.prototype._error = function(err) {
              var contexts = this.contexts;

              while (contexts.length > 0) {
                var context_1 = contexts.shift();
                context_1.subscription.unsubscribe();
                context_1.buffer = null;
                context_1.subscription = null;
              }

              this.contexts = null;

              _super.prototype._error.call(this, err);
            };

            BufferToggleSubscriber.prototype._complete = function() {
              var contexts = this.contexts;

              while (contexts.length > 0) {
                var context_2 = contexts.shift();
                this.destination.next(context_2.buffer);
                context_2.subscription.unsubscribe();
                context_2.buffer = null;
                context_2.subscription = null;
              }

              this.contexts = null;

              _super.prototype._complete.call(this);
            };

            BufferToggleSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
            };

            BufferToggleSubscriber.prototype.notifyComplete = function(innerSub) {
              this.closeBuffer(innerSub.context);
            };

            BufferToggleSubscriber.prototype.openBuffer = function(value) {
              try {
                var closingSelector = this.closingSelector;
                var closingNotifier = closingSelector.call(this, value);

                if (closingNotifier) {
                  this.trySubscribe(closingNotifier);
                }
              } catch (err) {
                this._error(err);
              }
            };

            BufferToggleSubscriber.prototype.closeBuffer = function(context) {
              var contexts = this.contexts;

              if (contexts && context) {
                var buffer = context.buffer,
                  subscription = context.subscription;
                this.destination.next(buffer);
                contexts.splice(contexts.indexOf(context), 1);
                this.remove(subscription);
                subscription.unsubscribe();
              }
            };

            BufferToggleSubscriber.prototype.trySubscribe = function(closingNotifier) {
              var contexts = this.contexts;
              var buffer = [];
              var subscription = new _Subscription.Subscription();
              var context = {
                buffer: buffer,
                subscription: subscription,
              };
              contexts.push(context);
              var innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, closingNotifier, context);

              if (!innerSubscription || innerSubscription.closed) {
                this.closeBuffer(context);
              } else {
                innerSubscription.context = context;
                this.add(innerSubscription);
                subscription.add(innerSubscription);
              }
            };

            return BufferToggleSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.bufferWhen = bufferWhen;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscription = require('../Subscription');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function bufferWhen(closingSelector) {
          return function(source) {
            return source.lift(new BufferWhenOperator(closingSelector));
          };
        }

        var BufferWhenOperator =
          /*@__PURE__*/
          (function() {
            function BufferWhenOperator(closingSelector) {
              this.closingSelector = closingSelector;
            }

            BufferWhenOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
            };

            return BufferWhenOperator;
          })();

        var BufferWhenSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(BufferWhenSubscriber, _super);

            function BufferWhenSubscriber(destination, closingSelector) {
              var _this = _super.call(this, destination) || this;

              _this.closingSelector = closingSelector;
              _this.subscribing = false;

              _this.openBuffer();

              return _this;
            }

            BufferWhenSubscriber.prototype._next = function(value) {
              this.buffer.push(value);
            };

            BufferWhenSubscriber.prototype._complete = function() {
              var buffer = this.buffer;

              if (buffer) {
                this.destination.next(buffer);
              }

              _super.prototype._complete.call(this);
            };

            BufferWhenSubscriber.prototype._unsubscribe = function() {
              this.buffer = null;
              this.subscribing = false;
            };

            BufferWhenSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.openBuffer();
            };

            BufferWhenSubscriber.prototype.notifyComplete = function() {
              if (this.subscribing) {
                this.complete();
              } else {
                this.openBuffer();
              }
            };

            BufferWhenSubscriber.prototype.openBuffer = function() {
              var closingSubscription = this.closingSubscription;

              if (closingSubscription) {
                this.remove(closingSubscription);
                closingSubscription.unsubscribe();
              }

              var buffer = this.buffer;

              if (this.buffer) {
                this.destination.next(buffer);
              }

              this.buffer = [];
              var closingNotifier;

              try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector();
              } catch (err) {
                return this.error(err);
              }

              closingSubscription = new _Subscription.Subscription();
              this.closingSubscription = closingSubscription;
              this.add(closingSubscription);
              this.subscribing = true;
              closingSubscription.add((0, _subscribeToResult.subscribeToResult)(this, closingNotifier));
              this.subscribing = false;
            };

            return BufferWhenSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/catchError.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.catchError = catchError;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function catchError(selector) {
          return function catchErrorOperatorFunction(source) {
            var operator = new CatchOperator(selector);
            var caught = source.lift(operator);
            return (operator.caught = caught);
          };
        }

        var CatchOperator =
          /*@__PURE__*/
          (function() {
            function CatchOperator(selector) {
              this.selector = selector;
            }

            CatchOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
            };

            return CatchOperator;
          })();

        var CatchSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(CatchSubscriber, _super);

            function CatchSubscriber(destination, selector, caught) {
              var _this = _super.call(this, destination) || this;

              _this.selector = selector;
              _this.caught = caught;
              return _this;
            }

            CatchSubscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                var result = void 0;

                try {
                  result = this.selector(err, this.caught);
                } catch (err2) {
                  _super.prototype.error.call(this, err2);

                  return;
                }

                this._unsubscribeAndRecycle();

                var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
                this.add(innerSubscriber);
                var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                  this,
                  result,
                  undefined,
                  undefined,
                  innerSubscriber
                );

                if (innerSubscription !== innerSubscriber) {
                  this.add(innerSubscription);
                }
              }
            };

            return CatchSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/combineAll.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.combineAll = combineAll;

        var _combineLatest = require('../observable/combineLatest');

        /** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */
        function combineAll(project) {
          return function(source) {
            return source.lift(new _combineLatest.CombineLatestOperator(project));
          };
        }
      },
      { '../observable/combineLatest': '../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/combineLatest.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.combineLatest = combineLatest;

        var _isArray = require('../util/isArray');

        var _combineLatest = require('../observable/combineLatest');

        var _from = require('../observable/from');

        /** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */
        var none = {};

        function combineLatest() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          var project = null;

          if (typeof observables[observables.length - 1] === 'function') {
            project = observables.pop();
          }

          if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
            observables = observables[0].slice();
          }

          return function(source) {
            return source.lift.call(
              (0, _from.from)([source].concat(observables)),
              new _combineLatest.CombineLatestOperator(project)
            );
          };
        }
      },
      {
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../observable/combineLatest': '../../../node_modules/rxjs/_esm5/internal/observable/combineLatest.js',
        '../observable/from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/concat.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.concat = concat;

        var _concat = require('../observable/concat');

        /** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */
        function concat() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          return function(source) {
            return source.lift.call(_concat.concat.apply(void 0, [source].concat(observables)));
          };
        }
      },
      { '../observable/concat': '../../../node_modules/rxjs/_esm5/internal/observable/concat.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/concatMap.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.concatMap = concatMap;

        var _mergeMap = require('./mergeMap');

        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
        function concatMap(project, resultSelector) {
          return (0, _mergeMap.mergeMap)(project, resultSelector, 1);
        }
      },
      { './mergeMap': '../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.concatMapTo = concatMapTo;

        var _concatMap = require('./concatMap');

        /** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
        function concatMapTo(innerObservable, resultSelector) {
          return (0, _concatMap.concatMap)(function() {
            return innerObservable;
          }, resultSelector);
        }
      },
      { './concatMap': '../../../node_modules/rxjs/_esm5/internal/operators/concatMap.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/count.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.count = count;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function count(predicate) {
          return function(source) {
            return source.lift(new CountOperator(predicate, source));
          };
        }

        var CountOperator =
          /*@__PURE__*/
          (function() {
            function CountOperator(predicate, source) {
              this.predicate = predicate;
              this.source = source;
            }

            CountOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
            };

            return CountOperator;
          })();

        var CountSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(CountSubscriber, _super);

            function CountSubscriber(destination, predicate, source) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.source = source;
              _this.count = 0;
              _this.index = 0;
              return _this;
            }

            CountSubscriber.prototype._next = function(value) {
              if (this.predicate) {
                this._tryPredicate(value);
              } else {
                this.count++;
              }
            };

            CountSubscriber.prototype._tryPredicate = function(value) {
              var result;

              try {
                result = this.predicate(value, this.index++, this.source);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              if (result) {
                this.count++;
              }
            };

            CountSubscriber.prototype._complete = function() {
              this.destination.next(this.count);
              this.destination.complete();
            };

            return CountSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/debounce.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.debounce = debounce;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function debounce(durationSelector) {
          return function(source) {
            return source.lift(new DebounceOperator(durationSelector));
          };
        }

        var DebounceOperator =
          /*@__PURE__*/
          (function() {
            function DebounceOperator(durationSelector) {
              this.durationSelector = durationSelector;
            }

            DebounceOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
            };

            return DebounceOperator;
          })();

        var DebounceSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DebounceSubscriber, _super);

            function DebounceSubscriber(destination, durationSelector) {
              var _this = _super.call(this, destination) || this;

              _this.durationSelector = durationSelector;
              _this.hasValue = false;
              _this.durationSubscription = null;
              return _this;
            }

            DebounceSubscriber.prototype._next = function(value) {
              try {
                var result = this.durationSelector.call(this, value);

                if (result) {
                  this._tryNext(value, result);
                }
              } catch (err) {
                this.destination.error(err);
              }
            };

            DebounceSubscriber.prototype._complete = function() {
              this.emitValue();
              this.destination.complete();
            };

            DebounceSubscriber.prototype._tryNext = function(value, duration) {
              var subscription = this.durationSubscription;
              this.value = value;
              this.hasValue = true;

              if (subscription) {
                subscription.unsubscribe();
                this.remove(subscription);
              }

              subscription = (0, _subscribeToResult.subscribeToResult)(this, duration);

              if (subscription && !subscription.closed) {
                this.add((this.durationSubscription = subscription));
              }
            };

            DebounceSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.emitValue();
            };

            DebounceSubscriber.prototype.notifyComplete = function() {
              this.emitValue();
            };

            DebounceSubscriber.prototype.emitValue = function() {
              if (this.hasValue) {
                var value = this.value;
                var subscription = this.durationSubscription;

                if (subscription) {
                  this.durationSubscription = null;
                  subscription.unsubscribe();
                  this.remove(subscription);
                }

                this.value = null;
                this.hasValue = false;

                _super.prototype._next.call(this, value);
              }
            };

            return DebounceSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/debounceTime.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.debounceTime = debounceTime;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _async = require('../scheduler/async');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
        function debounceTime(dueTime, scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return function(source) {
            return source.lift(new DebounceTimeOperator(dueTime, scheduler));
          };
        }

        var DebounceTimeOperator =
          /*@__PURE__*/
          (function() {
            function DebounceTimeOperator(dueTime, scheduler) {
              this.dueTime = dueTime;
              this.scheduler = scheduler;
            }

            DebounceTimeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
            };

            return DebounceTimeOperator;
          })();

        var DebounceTimeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DebounceTimeSubscriber, _super);

            function DebounceTimeSubscriber(destination, dueTime, scheduler) {
              var _this = _super.call(this, destination) || this;

              _this.dueTime = dueTime;
              _this.scheduler = scheduler;
              _this.debouncedSubscription = null;
              _this.lastValue = null;
              _this.hasValue = false;
              return _this;
            }

            DebounceTimeSubscriber.prototype._next = function(value) {
              this.clearDebounce();
              this.lastValue = value;
              this.hasValue = true;
              this.add((this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this)));
            };

            DebounceTimeSubscriber.prototype._complete = function() {
              this.debouncedNext();
              this.destination.complete();
            };

            DebounceTimeSubscriber.prototype.debouncedNext = function() {
              this.clearDebounce();

              if (this.hasValue) {
                var lastValue = this.lastValue;
                this.lastValue = null;
                this.hasValue = false;
                this.destination.next(lastValue);
              }
            };

            DebounceTimeSubscriber.prototype.clearDebounce = function() {
              var debouncedSubscription = this.debouncedSubscription;

              if (debouncedSubscription !== null) {
                this.remove(debouncedSubscription);
                debouncedSubscription.unsubscribe();
                this.debouncedSubscription = null;
              }
            };

            return DebounceTimeSubscriber;
          })(_Subscriber.Subscriber);

        function dispatchNext(subscriber) {
          subscriber.debouncedNext();
        }
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.defaultIfEmpty = defaultIfEmpty;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function defaultIfEmpty(defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = null;
          }

          return function(source) {
            return source.lift(new DefaultIfEmptyOperator(defaultValue));
          };
        }

        var DefaultIfEmptyOperator =
          /*@__PURE__*/
          (function() {
            function DefaultIfEmptyOperator(defaultValue) {
              this.defaultValue = defaultValue;
            }

            DefaultIfEmptyOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
            };

            return DefaultIfEmptyOperator;
          })();

        var DefaultIfEmptySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DefaultIfEmptySubscriber, _super);

            function DefaultIfEmptySubscriber(destination, defaultValue) {
              var _this = _super.call(this, destination) || this;

              _this.defaultValue = defaultValue;
              _this.isEmpty = true;
              return _this;
            }

            DefaultIfEmptySubscriber.prototype._next = function(value) {
              this.isEmpty = false;
              this.destination.next(value);
            };

            DefaultIfEmptySubscriber.prototype._complete = function() {
              if (this.isEmpty) {
                this.destination.next(this.defaultValue);
              }

              this.destination.complete();
            };

            return DefaultIfEmptySubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/util/isDate.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isDate = isDate;

        /** PURE_IMPORTS_START  PURE_IMPORTS_END */
        function isDate(value) {
          return value instanceof Date && !isNaN(+value);
        }
      },
      {},
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/delay.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.delay = delay;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _async = require('../scheduler/async');

        var _isDate = require('../util/isDate');

        var _Subscriber = require('../Subscriber');

        var _Notification = require('../Notification');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
        function delay(delay, scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          var absoluteDelay = (0, _isDate.isDate)(delay);
          var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
          return function(source) {
            return source.lift(new DelayOperator(delayFor, scheduler));
          };
        }

        var DelayOperator =
          /*@__PURE__*/
          (function() {
            function DelayOperator(delay, scheduler) {
              this.delay = delay;
              this.scheduler = scheduler;
            }

            DelayOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
            };

            return DelayOperator;
          })();

        var DelaySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DelaySubscriber, _super);

            function DelaySubscriber(destination, delay, scheduler) {
              var _this = _super.call(this, destination) || this;

              _this.delay = delay;
              _this.scheduler = scheduler;
              _this.queue = [];
              _this.active = false;
              _this.errored = false;
              return _this;
            }

            DelaySubscriber.dispatch = function(state) {
              var source = state.source;
              var queue = source.queue;
              var scheduler = state.scheduler;
              var destination = state.destination;

              while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
                queue.shift().notification.observe(destination);
              }

              if (queue.length > 0) {
                var delay_1 = Math.max(0, queue[0].time - scheduler.now());
                this.schedule(state, delay_1);
              } else {
                this.unsubscribe();
                source.active = false;
              }
            };

            DelaySubscriber.prototype._schedule = function(scheduler) {
              this.active = true;
              var destination = this.destination;
              destination.add(
                scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
                  source: this,
                  destination: this.destination,
                  scheduler: scheduler,
                })
              );
            };

            DelaySubscriber.prototype.scheduleNotification = function(notification) {
              if (this.errored === true) {
                return;
              }

              var scheduler = this.scheduler;
              var message = new DelayMessage(scheduler.now() + this.delay, notification);
              this.queue.push(message);

              if (this.active === false) {
                this._schedule(scheduler);
              }
            };

            DelaySubscriber.prototype._next = function(value) {
              this.scheduleNotification(_Notification.Notification.createNext(value));
            };

            DelaySubscriber.prototype._error = function(err) {
              this.errored = true;
              this.queue = [];
              this.destination.error(err);
              this.unsubscribe();
            };

            DelaySubscriber.prototype._complete = function() {
              this.scheduleNotification(_Notification.Notification.createComplete());
              this.unsubscribe();
            };

            return DelaySubscriber;
          })(_Subscriber.Subscriber);

        var DelayMessage =
          /*@__PURE__*/
          (function() {
            function DelayMessage(time, notification) {
              this.time = time;
              this.notification = notification;
            }

            return DelayMessage;
          })();
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../util/isDate': '../../../node_modules/rxjs/_esm5/internal/util/isDate.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Notification': '../../../node_modules/rxjs/_esm5/internal/Notification.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/delayWhen.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.delayWhen = delayWhen;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _Observable = require('../Observable');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function delayWhen(delayDurationSelector, subscriptionDelay) {
          if (subscriptionDelay) {
            return function(source) {
              return new SubscriptionDelayObservable(source, subscriptionDelay).lift(
                new DelayWhenOperator(delayDurationSelector)
              );
            };
          }

          return function(source) {
            return source.lift(new DelayWhenOperator(delayDurationSelector));
          };
        }

        var DelayWhenOperator =
          /*@__PURE__*/
          (function() {
            function DelayWhenOperator(delayDurationSelector) {
              this.delayDurationSelector = delayDurationSelector;
            }

            DelayWhenOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
            };

            return DelayWhenOperator;
          })();

        var DelayWhenSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DelayWhenSubscriber, _super);

            function DelayWhenSubscriber(destination, delayDurationSelector) {
              var _this = _super.call(this, destination) || this;

              _this.delayDurationSelector = delayDurationSelector;
              _this.completed = false;
              _this.delayNotifierSubscriptions = [];
              _this.index = 0;
              return _this;
            }

            DelayWhenSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.destination.next(outerValue);
              this.removeSubscription(innerSub);
              this.tryComplete();
            };

            DelayWhenSubscriber.prototype.notifyError = function(error, innerSub) {
              this._error(error);
            };

            DelayWhenSubscriber.prototype.notifyComplete = function(innerSub) {
              var value = this.removeSubscription(innerSub);

              if (value) {
                this.destination.next(value);
              }

              this.tryComplete();
            };

            DelayWhenSubscriber.prototype._next = function(value) {
              var index = this.index++;

              try {
                var delayNotifier = this.delayDurationSelector(value, index);

                if (delayNotifier) {
                  this.tryDelay(delayNotifier, value);
                }
              } catch (err) {
                this.destination.error(err);
              }
            };

            DelayWhenSubscriber.prototype._complete = function() {
              this.completed = true;
              this.tryComplete();
              this.unsubscribe();
            };

            DelayWhenSubscriber.prototype.removeSubscription = function(subscription) {
              subscription.unsubscribe();
              var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);

              if (subscriptionIdx !== -1) {
                this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
              }

              return subscription.outerValue;
            };

            DelayWhenSubscriber.prototype.tryDelay = function(delayNotifier, value) {
              var notifierSubscription = (0, _subscribeToResult.subscribeToResult)(this, delayNotifier, value);

              if (notifierSubscription && !notifierSubscription.closed) {
                var destination = this.destination;
                destination.add(notifierSubscription);
                this.delayNotifierSubscriptions.push(notifierSubscription);
              }
            };

            DelayWhenSubscriber.prototype.tryComplete = function() {
              if (this.completed && this.delayNotifierSubscriptions.length === 0) {
                this.destination.complete();
              }
            };

            return DelayWhenSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        var SubscriptionDelayObservable =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SubscriptionDelayObservable, _super);

            function SubscriptionDelayObservable(source, subscriptionDelay) {
              var _this = _super.call(this) || this;

              _this.source = source;
              _this.subscriptionDelay = subscriptionDelay;
              return _this;
            }

            SubscriptionDelayObservable.prototype._subscribe = function(subscriber) {
              this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
            };

            return SubscriptionDelayObservable;
          })(_Observable.Observable);

        var SubscriptionDelaySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SubscriptionDelaySubscriber, _super);

            function SubscriptionDelaySubscriber(parent, source) {
              var _this = _super.call(this) || this;

              _this.parent = parent;
              _this.source = source;
              _this.sourceSubscribed = false;
              return _this;
            }

            SubscriptionDelaySubscriber.prototype._next = function(unused) {
              this.subscribeToSource();
            };

            SubscriptionDelaySubscriber.prototype._error = function(err) {
              this.unsubscribe();
              this.parent.error(err);
            };

            SubscriptionDelaySubscriber.prototype._complete = function() {
              this.unsubscribe();
              this.subscribeToSource();
            };

            SubscriptionDelaySubscriber.prototype.subscribeToSource = function() {
              if (!this.sourceSubscribed) {
                this.sourceSubscribed = true;
                this.unsubscribe();
                this.source.subscribe(this.parent);
              }
            };

            return SubscriptionDelaySubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/dematerialize.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.dematerialize = dematerialize;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function dematerialize() {
          return function dematerializeOperatorFunction(source) {
            return source.lift(new DeMaterializeOperator());
          };
        }

        var DeMaterializeOperator =
          /*@__PURE__*/
          (function() {
            function DeMaterializeOperator() {}

            DeMaterializeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DeMaterializeSubscriber(subscriber));
            };

            return DeMaterializeOperator;
          })();

        var DeMaterializeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DeMaterializeSubscriber, _super);

            function DeMaterializeSubscriber(destination) {
              return _super.call(this, destination) || this;
            }

            DeMaterializeSubscriber.prototype._next = function(value) {
              value.observe(this.destination);
            };

            return DeMaterializeSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/distinct.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.distinct = distinct;
        exports.DistinctSubscriber = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function distinct(keySelector, flushes) {
          return function(source) {
            return source.lift(new DistinctOperator(keySelector, flushes));
          };
        }

        var DistinctOperator =
          /*@__PURE__*/
          (function() {
            function DistinctOperator(keySelector, flushes) {
              this.keySelector = keySelector;
              this.flushes = flushes;
            }

            DistinctOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
            };

            return DistinctOperator;
          })();

        var DistinctSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DistinctSubscriber, _super);

            function DistinctSubscriber(destination, keySelector, flushes) {
              var _this = _super.call(this, destination) || this;

              _this.keySelector = keySelector;
              _this.values = new Set();

              if (flushes) {
                _this.add((0, _subscribeToResult.subscribeToResult)(_this, flushes));
              }

              return _this;
            }

            DistinctSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.values.clear();
            };

            DistinctSubscriber.prototype.notifyError = function(error, innerSub) {
              this._error(error);
            };

            DistinctSubscriber.prototype._next = function(value) {
              if (this.keySelector) {
                this._useKeySelector(value);
              } else {
                this._finalizeNext(value, value);
              }
            };

            DistinctSubscriber.prototype._useKeySelector = function(value) {
              var key;
              var destination = this.destination;

              try {
                key = this.keySelector(value);
              } catch (err) {
                destination.error(err);
                return;
              }

              this._finalizeNext(key, value);
            };

            DistinctSubscriber.prototype._finalizeNext = function(key, value) {
              var values = this.values;

              if (!values.has(key)) {
                values.add(key);
                this.destination.next(value);
              }
            };

            return DistinctSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        exports.DistinctSubscriber = DistinctSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.distinctUntilChanged = distinctUntilChanged;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function distinctUntilChanged(compare, keySelector) {
          return function(source) {
            return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
          };
        }

        var DistinctUntilChangedOperator =
          /*@__PURE__*/
          (function() {
            function DistinctUntilChangedOperator(compare, keySelector) {
              this.compare = compare;
              this.keySelector = keySelector;
            }

            DistinctUntilChangedOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
            };

            return DistinctUntilChangedOperator;
          })();

        var DistinctUntilChangedSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(DistinctUntilChangedSubscriber, _super);

            function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
              var _this = _super.call(this, destination) || this;

              _this.keySelector = keySelector;
              _this.hasKey = false;

              if (typeof compare === 'function') {
                _this.compare = compare;
              }

              return _this;
            }

            DistinctUntilChangedSubscriber.prototype.compare = function(x, y) {
              return x === y;
            };

            DistinctUntilChangedSubscriber.prototype._next = function(value) {
              var key;

              try {
                var keySelector = this.keySelector;
                key = keySelector ? keySelector(value) : value;
              } catch (err) {
                return this.destination.error(err);
              }

              var result = false;

              if (this.hasKey) {
                try {
                  var compare = this.compare;
                  result = compare(this.key, key);
                } catch (err) {
                  return this.destination.error(err);
                }
              } else {
                this.hasKey = true;
              }

              if (!result) {
                this.key = key;
                this.destination.next(value);
              }
            };

            return DistinctUntilChangedSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

        var _distinctUntilChanged = require('./distinctUntilChanged');

        /** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
        function distinctUntilKeyChanged(key, compare) {
          return (0, _distinctUntilChanged.distinctUntilChanged)(function(x, y) {
            return compare ? compare(x[key], y[key]) : x[key] === y[key];
          });
        }
      },
      { './distinctUntilChanged': '../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.throwIfEmpty = throwIfEmpty;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _EmptyError = require('../util/EmptyError');

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */
        function throwIfEmpty(errorFactory) {
          if (errorFactory === void 0) {
            errorFactory = defaultErrorFactory;
          }

          return function(source) {
            return source.lift(new ThrowIfEmptyOperator(errorFactory));
          };
        }

        var ThrowIfEmptyOperator =
          /*@__PURE__*/
          (function() {
            function ThrowIfEmptyOperator(errorFactory) {
              this.errorFactory = errorFactory;
            }

            ThrowIfEmptyOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
            };

            return ThrowIfEmptyOperator;
          })();

        var ThrowIfEmptySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ThrowIfEmptySubscriber, _super);

            function ThrowIfEmptySubscriber(destination, errorFactory) {
              var _this = _super.call(this, destination) || this;

              _this.errorFactory = errorFactory;
              _this.hasValue = false;
              return _this;
            }

            ThrowIfEmptySubscriber.prototype._next = function(value) {
              this.hasValue = true;
              this.destination.next(value);
            };

            ThrowIfEmptySubscriber.prototype._complete = function() {
              if (!this.hasValue) {
                var err = void 0;

                try {
                  err = this.errorFactory();
                } catch (e) {
                  err = e;
                }

                this.destination.error(err);
              } else {
                return this.destination.complete();
              }
            };

            return ThrowIfEmptySubscriber;
          })(_Subscriber.Subscriber);

        function defaultErrorFactory() {
          return new _EmptyError.EmptyError();
        }
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../util/EmptyError': '../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/take.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.take = take;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

        var _empty = require('../observable/empty');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function take(count) {
          return function(source) {
            if (count === 0) {
              return (0, _empty.empty)();
            } else {
              return source.lift(new TakeOperator(count));
            }
          };
        }

        var TakeOperator =
          /*@__PURE__*/
          (function() {
            function TakeOperator(total) {
              this.total = total;

              if (this.total < 0) {
                throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
              }
            }

            TakeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new TakeSubscriber(subscriber, this.total));
            };

            return TakeOperator;
          })();

        var TakeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(TakeSubscriber, _super);

            function TakeSubscriber(destination, total) {
              var _this = _super.call(this, destination) || this;

              _this.total = total;
              _this.count = 0;
              return _this;
            }

            TakeSubscriber.prototype._next = function(value) {
              var total = this.total;
              var count = ++this.count;

              if (count <= total) {
                this.destination.next(value);

                if (count === total) {
                  this.destination.complete();
                  this.unsubscribe();
                }
              }
            };

            return TakeSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/ArgumentOutOfRangeError': '../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
        '../observable/empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/elementAt.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.elementAt = elementAt;

        var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

        var _filter = require('./filter');

        var _throwIfEmpty = require('./throwIfEmpty');

        var _defaultIfEmpty = require('./defaultIfEmpty');

        var _take = require('./take');

        /** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */
        function elementAt(index, defaultValue) {
          if (index < 0) {
            throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
          }

          var hasDefaultValue = arguments.length >= 2;
          return function(source) {
            return source.pipe(
              (0, _filter.filter)(function(v, i) {
                return i === index;
              }),
              (0, _take.take)(1),
              hasDefaultValue
                ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue)
                : (0, _throwIfEmpty.throwIfEmpty)(function() {
                    return new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
                  })
            );
          };
        }
      },
      {
        '../util/ArgumentOutOfRangeError': '../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
        './filter': '../../../node_modules/rxjs/_esm5/internal/operators/filter.js',
        './throwIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
        './defaultIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
        './take': '../../../node_modules/rxjs/_esm5/internal/operators/take.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/endWith.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.endWith = endWith;

        var _concat = require('../observable/concat');

        var _of = require('../observable/of');

        /** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */
        function endWith() {
          var array = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
          }

          return function(source) {
            return (0, _concat.concat)(source, _of.of.apply(void 0, array));
          };
        }
      },
      {
        '../observable/concat': '../../../node_modules/rxjs/_esm5/internal/observable/concat.js',
        '../observable/of': '../../../node_modules/rxjs/_esm5/internal/observable/of.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/every.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.every = every;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function every(predicate, thisArg) {
          return function(source) {
            return source.lift(new EveryOperator(predicate, thisArg, source));
          };
        }

        var EveryOperator =
          /*@__PURE__*/
          (function() {
            function EveryOperator(predicate, thisArg, source) {
              this.predicate = predicate;
              this.thisArg = thisArg;
              this.source = source;
            }

            EveryOperator.prototype.call = function(observer, source) {
              return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
            };

            return EveryOperator;
          })();

        var EverySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(EverySubscriber, _super);

            function EverySubscriber(destination, predicate, thisArg, source) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.thisArg = thisArg;
              _this.source = source;
              _this.index = 0;
              _this.thisArg = thisArg || _this;
              return _this;
            }

            EverySubscriber.prototype.notifyComplete = function(everyValueMatch) {
              this.destination.next(everyValueMatch);
              this.destination.complete();
            };

            EverySubscriber.prototype._next = function(value) {
              var result = false;

              try {
                result = this.predicate.call(this.thisArg, value, this.index++, this.source);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              if (!result) {
                this.notifyComplete(false);
              }
            };

            EverySubscriber.prototype._complete = function() {
              this.notifyComplete(true);
            };

            return EverySubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/exhaust.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.exhaust = exhaust;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function exhaust() {
          return function(source) {
            return source.lift(new SwitchFirstOperator());
          };
        }

        var SwitchFirstOperator =
          /*@__PURE__*/
          (function() {
            function SwitchFirstOperator() {}

            SwitchFirstOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SwitchFirstSubscriber(subscriber));
            };

            return SwitchFirstOperator;
          })();

        var SwitchFirstSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SwitchFirstSubscriber, _super);

            function SwitchFirstSubscriber(destination) {
              var _this = _super.call(this, destination) || this;

              _this.hasCompleted = false;
              _this.hasSubscription = false;
              return _this;
            }

            SwitchFirstSubscriber.prototype._next = function(value) {
              if (!this.hasSubscription) {
                this.hasSubscription = true;
                this.add((0, _subscribeToResult.subscribeToResult)(this, value));
              }
            };

            SwitchFirstSubscriber.prototype._complete = function() {
              this.hasCompleted = true;

              if (!this.hasSubscription) {
                this.destination.complete();
              }
            };

            SwitchFirstSubscriber.prototype.notifyComplete = function(innerSub) {
              this.remove(innerSub);
              this.hasSubscription = false;

              if (this.hasCompleted) {
                this.destination.complete();
              }
            };

            return SwitchFirstSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.exhaustMap = exhaustMap;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        var _map = require('./map');

        var _from = require('../observable/from');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function exhaustMap(project, resultSelector) {
          if (resultSelector) {
            return function(source) {
              return source.pipe(
                exhaustMap(function(a, i) {
                  return (0, _from.from)(project(a, i)).pipe(
                    (0, _map.map)(function(b, ii) {
                      return resultSelector(a, b, i, ii);
                    })
                  );
                })
              );
            };
          }

          return function(source) {
            return source.lift(new ExhaustMapOperator(project));
          };
        }

        var ExhaustMapOperator =
          /*@__PURE__*/
          (function() {
            function ExhaustMapOperator(project) {
              this.project = project;
            }

            ExhaustMapOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
            };

            return ExhaustMapOperator;
          })();

        var ExhaustMapSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ExhaustMapSubscriber, _super);

            function ExhaustMapSubscriber(destination, project) {
              var _this = _super.call(this, destination) || this;

              _this.project = project;
              _this.hasSubscription = false;
              _this.hasCompleted = false;
              _this.index = 0;
              return _this;
            }

            ExhaustMapSubscriber.prototype._next = function(value) {
              if (!this.hasSubscription) {
                this.tryNext(value);
              }
            };

            ExhaustMapSubscriber.prototype.tryNext = function(value) {
              var result;
              var index = this.index++;

              try {
                result = this.project(value, index);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.hasSubscription = true;

              this._innerSub(result, value, index);
            };

            ExhaustMapSubscriber.prototype._innerSub = function(result, value, index) {
              var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, value, index);
              var destination = this.destination;
              destination.add(innerSubscriber);
              var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                this,
                result,
                undefined,
                undefined,
                innerSubscriber
              );

              if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
              }
            };

            ExhaustMapSubscriber.prototype._complete = function() {
              this.hasCompleted = true;

              if (!this.hasSubscription) {
                this.destination.complete();
              }

              this.unsubscribe();
            };

            ExhaustMapSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.destination.next(innerValue);
            };

            ExhaustMapSubscriber.prototype.notifyError = function(err) {
              this.destination.error(err);
            };

            ExhaustMapSubscriber.prototype.notifyComplete = function(innerSub) {
              var destination = this.destination;
              destination.remove(innerSub);
              this.hasSubscription = false;

              if (this.hasCompleted) {
                this.destination.complete();
              }
            };

            return ExhaustMapSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        './map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../observable/from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/expand.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.expand = expand;
        exports.ExpandSubscriber = exports.ExpandOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function expand(project, concurrent, scheduler) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }

          if (scheduler === void 0) {
            scheduler = undefined;
          }

          concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
          return function(source) {
            return source.lift(new ExpandOperator(project, concurrent, scheduler));
          };
        }

        var ExpandOperator =
          /*@__PURE__*/
          (function() {
            function ExpandOperator(project, concurrent, scheduler) {
              this.project = project;
              this.concurrent = concurrent;
              this.scheduler = scheduler;
            }

            ExpandOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
            };

            return ExpandOperator;
          })();

        exports.ExpandOperator = ExpandOperator;

        var ExpandSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ExpandSubscriber, _super);

            function ExpandSubscriber(destination, project, concurrent, scheduler) {
              var _this = _super.call(this, destination) || this;

              _this.project = project;
              _this.concurrent = concurrent;
              _this.scheduler = scheduler;
              _this.index = 0;
              _this.active = 0;
              _this.hasCompleted = false;

              if (concurrent < Number.POSITIVE_INFINITY) {
                _this.buffer = [];
              }

              return _this;
            }

            ExpandSubscriber.dispatch = function(arg) {
              var subscriber = arg.subscriber,
                result = arg.result,
                value = arg.value,
                index = arg.index;
              subscriber.subscribeToProjection(result, value, index);
            };

            ExpandSubscriber.prototype._next = function(value) {
              var destination = this.destination;

              if (destination.closed) {
                this._complete();

                return;
              }

              var index = this.index++;

              if (this.active < this.concurrent) {
                destination.next(value);

                try {
                  var project = this.project;
                  var result = project(value, index);

                  if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                  } else {
                    var state = {
                      subscriber: this,
                      result: result,
                      value: value,
                      index: index,
                    };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                  }
                } catch (e) {
                  destination.error(e);
                }
              } else {
                this.buffer.push(value);
              }
            };

            ExpandSubscriber.prototype.subscribeToProjection = function(result, value, index) {
              this.active++;
              var destination = this.destination;
              destination.add((0, _subscribeToResult.subscribeToResult)(this, result, value, index));
            };

            ExpandSubscriber.prototype._complete = function() {
              this.hasCompleted = true;

              if (this.hasCompleted && this.active === 0) {
                this.destination.complete();
              }

              this.unsubscribe();
            };

            ExpandSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              this._next(innerValue);
            };

            ExpandSubscriber.prototype.notifyComplete = function(innerSub) {
              var buffer = this.buffer;
              var destination = this.destination;
              destination.remove(innerSub);
              this.active--;

              if (buffer && buffer.length > 0) {
                this._next(buffer.shift());
              }

              if (this.hasCompleted && this.active === 0) {
                this.destination.complete();
              }
            };

            return ExpandSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        exports.ExpandSubscriber = ExpandSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/finalize.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.finalize = finalize;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _Subscription = require('../Subscription');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
        function finalize(callback) {
          return function(source) {
            return source.lift(new FinallyOperator(callback));
          };
        }

        var FinallyOperator =
          /*@__PURE__*/
          (function() {
            function FinallyOperator(callback) {
              this.callback = callback;
            }

            FinallyOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new FinallySubscriber(subscriber, this.callback));
            };

            return FinallyOperator;
          })();

        var FinallySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(FinallySubscriber, _super);

            function FinallySubscriber(destination, callback) {
              var _this = _super.call(this, destination) || this;

              _this.add(new _Subscription.Subscription(callback));

              return _this;
            }

            return FinallySubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/find.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.find = find;
        exports.FindValueSubscriber = exports.FindValueOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function find(predicate, thisArg) {
          if (typeof predicate !== 'function') {
            throw new TypeError('predicate is not a function');
          }

          return function(source) {
            return source.lift(new FindValueOperator(predicate, source, false, thisArg));
          };
        }

        var FindValueOperator =
          /*@__PURE__*/
          (function() {
            function FindValueOperator(predicate, source, yieldIndex, thisArg) {
              this.predicate = predicate;
              this.source = source;
              this.yieldIndex = yieldIndex;
              this.thisArg = thisArg;
            }

            FindValueOperator.prototype.call = function(observer, source) {
              return source.subscribe(
                new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg)
              );
            };

            return FindValueOperator;
          })();

        exports.FindValueOperator = FindValueOperator;

        var FindValueSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(FindValueSubscriber, _super);

            function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.source = source;
              _this.yieldIndex = yieldIndex;
              _this.thisArg = thisArg;
              _this.index = 0;
              return _this;
            }

            FindValueSubscriber.prototype.notifyComplete = function(value) {
              var destination = this.destination;
              destination.next(value);
              destination.complete();
              this.unsubscribe();
            };

            FindValueSubscriber.prototype._next = function(value) {
              var _a = this,
                predicate = _a.predicate,
                thisArg = _a.thisArg;

              var index = this.index++;

              try {
                var result = predicate.call(thisArg || this, value, index, this.source);

                if (result) {
                  this.notifyComplete(this.yieldIndex ? index : value);
                }
              } catch (err) {
                this.destination.error(err);
              }
            };

            FindValueSubscriber.prototype._complete = function() {
              this.notifyComplete(this.yieldIndex ? -1 : undefined);
            };

            return FindValueSubscriber;
          })(_Subscriber.Subscriber);

        exports.FindValueSubscriber = FindValueSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/findIndex.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.findIndex = findIndex;

        var _find = require('../operators/find');

        /** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */
        function findIndex(predicate, thisArg) {
          return function(source) {
            return source.lift(new _find.FindValueOperator(predicate, source, true, thisArg));
          };
        }
      },
      { '../operators/find': '../../../node_modules/rxjs/_esm5/internal/operators/find.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/first.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.first = first;

        var _EmptyError = require('../util/EmptyError');

        var _filter = require('./filter');

        var _take = require('./take');

        var _defaultIfEmpty = require('./defaultIfEmpty');

        var _throwIfEmpty = require('./throwIfEmpty');

        var _identity = require('../util/identity');

        /** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
        function first(predicate, defaultValue) {
          var hasDefaultValue = arguments.length >= 2;
          return function(source) {
            return source.pipe(
              predicate
                ? (0, _filter.filter)(function(v, i) {
                    return predicate(v, i, source);
                  })
                : _identity.identity,
              (0, _take.take)(1),
              hasDefaultValue
                ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue)
                : (0, _throwIfEmpty.throwIfEmpty)(function() {
                    return new _EmptyError.EmptyError();
                  })
            );
          };
        }
      },
      {
        '../util/EmptyError': '../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
        './filter': '../../../node_modules/rxjs/_esm5/internal/operators/filter.js',
        './take': '../../../node_modules/rxjs/_esm5/internal/operators/take.js',
        './defaultIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
        './throwIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
        '../util/identity': '../../../node_modules/rxjs/_esm5/internal/util/identity.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.ignoreElements = ignoreElements;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function ignoreElements() {
          return function ignoreElementsOperatorFunction(source) {
            return source.lift(new IgnoreElementsOperator());
          };
        }

        var IgnoreElementsOperator =
          /*@__PURE__*/
          (function() {
            function IgnoreElementsOperator() {}

            IgnoreElementsOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new IgnoreElementsSubscriber(subscriber));
            };

            return IgnoreElementsOperator;
          })();

        var IgnoreElementsSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(IgnoreElementsSubscriber, _super);

            function IgnoreElementsSubscriber() {
              return (_super !== null && _super.apply(this, arguments)) || this;
            }

            IgnoreElementsSubscriber.prototype._next = function(unused) {};

            return IgnoreElementsSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/isEmpty.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.isEmpty = isEmpty;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function isEmpty() {
          return function(source) {
            return source.lift(new IsEmptyOperator());
          };
        }

        var IsEmptyOperator =
          /*@__PURE__*/
          (function() {
            function IsEmptyOperator() {}

            IsEmptyOperator.prototype.call = function(observer, source) {
              return source.subscribe(new IsEmptySubscriber(observer));
            };

            return IsEmptyOperator;
          })();

        var IsEmptySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(IsEmptySubscriber, _super);

            function IsEmptySubscriber(destination) {
              return _super.call(this, destination) || this;
            }

            IsEmptySubscriber.prototype.notifyComplete = function(isEmpty) {
              var destination = this.destination;
              destination.next(isEmpty);
              destination.complete();
            };

            IsEmptySubscriber.prototype._next = function(value) {
              this.notifyComplete(false);
            };

            IsEmptySubscriber.prototype._complete = function() {
              this.notifyComplete(true);
            };

            return IsEmptySubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.takeLast = takeLast;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

        var _empty = require('../observable/empty');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
        function takeLast(count) {
          return function takeLastOperatorFunction(source) {
            if (count === 0) {
              return (0, _empty.empty)();
            } else {
              return source.lift(new TakeLastOperator(count));
            }
          };
        }

        var TakeLastOperator =
          /*@__PURE__*/
          (function() {
            function TakeLastOperator(total) {
              this.total = total;

              if (this.total < 0) {
                throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
              }
            }

            TakeLastOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
            };

            return TakeLastOperator;
          })();

        var TakeLastSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(TakeLastSubscriber, _super);

            function TakeLastSubscriber(destination, total) {
              var _this = _super.call(this, destination) || this;

              _this.total = total;
              _this.ring = new Array();
              _this.count = 0;
              return _this;
            }

            TakeLastSubscriber.prototype._next = function(value) {
              var ring = this.ring;
              var total = this.total;
              var count = this.count++;

              if (ring.length < total) {
                ring.push(value);
              } else {
                var index = count % total;
                ring[index] = value;
              }
            };

            TakeLastSubscriber.prototype._complete = function() {
              var destination = this.destination;
              var count = this.count;

              if (count > 0) {
                var total = this.count >= this.total ? this.total : this.count;
                var ring = this.ring;

                for (var i = 0; i < total; i++) {
                  var idx = count++ % total;
                  destination.next(ring[idx]);
                }
              }

              destination.complete();
            };

            return TakeLastSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/ArgumentOutOfRangeError': '../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
        '../observable/empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/last.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.last = last;

        var _EmptyError = require('../util/EmptyError');

        var _filter = require('./filter');

        var _takeLast = require('./takeLast');

        var _throwIfEmpty = require('./throwIfEmpty');

        var _defaultIfEmpty = require('./defaultIfEmpty');

        var _identity = require('../util/identity');

        /** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
        function last(predicate, defaultValue) {
          var hasDefaultValue = arguments.length >= 2;
          return function(source) {
            return source.pipe(
              predicate
                ? (0, _filter.filter)(function(v, i) {
                    return predicate(v, i, source);
                  })
                : _identity.identity,
              (0, _takeLast.takeLast)(1),
              hasDefaultValue
                ? (0, _defaultIfEmpty.defaultIfEmpty)(defaultValue)
                : (0, _throwIfEmpty.throwIfEmpty)(function() {
                    return new _EmptyError.EmptyError();
                  })
            );
          };
        }
      },
      {
        '../util/EmptyError': '../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
        './filter': '../../../node_modules/rxjs/_esm5/internal/operators/filter.js',
        './takeLast': '../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js',
        './throwIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
        './defaultIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
        '../util/identity': '../../../node_modules/rxjs/_esm5/internal/util/identity.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/mapTo.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.mapTo = mapTo;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function mapTo(value) {
          return function(source) {
            return source.lift(new MapToOperator(value));
          };
        }

        var MapToOperator =
          /*@__PURE__*/
          (function() {
            function MapToOperator(value) {
              this.value = value;
            }

            MapToOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new MapToSubscriber(subscriber, this.value));
            };

            return MapToOperator;
          })();

        var MapToSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(MapToSubscriber, _super);

            function MapToSubscriber(destination, value) {
              var _this = _super.call(this, destination) || this;

              _this.value = value;
              return _this;
            }

            MapToSubscriber.prototype._next = function(x) {
              this.destination.next(this.value);
            };

            return MapToSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/materialize.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.materialize = materialize;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _Notification = require('../Notification');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
        function materialize() {
          return function materializeOperatorFunction(source) {
            return source.lift(new MaterializeOperator());
          };
        }

        var MaterializeOperator =
          /*@__PURE__*/
          (function() {
            function MaterializeOperator() {}

            MaterializeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new MaterializeSubscriber(subscriber));
            };

            return MaterializeOperator;
          })();

        var MaterializeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(MaterializeSubscriber, _super);

            function MaterializeSubscriber(destination) {
              return _super.call(this, destination) || this;
            }

            MaterializeSubscriber.prototype._next = function(value) {
              this.destination.next(_Notification.Notification.createNext(value));
            };

            MaterializeSubscriber.prototype._error = function(err) {
              var destination = this.destination;
              destination.next(_Notification.Notification.createError(err));
              destination.complete();
            };

            MaterializeSubscriber.prototype._complete = function() {
              var destination = this.destination;
              destination.next(_Notification.Notification.createComplete());
              destination.complete();
            };

            return MaterializeSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Notification': '../../../node_modules/rxjs/_esm5/internal/Notification.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/scan.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.scan = scan;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function scan(accumulator, seed) {
          var hasSeed = false;

          if (arguments.length >= 2) {
            hasSeed = true;
          }

          return function scanOperatorFunction(source) {
            return source.lift(new ScanOperator(accumulator, seed, hasSeed));
          };
        }

        var ScanOperator =
          /*@__PURE__*/
          (function() {
            function ScanOperator(accumulator, seed, hasSeed) {
              if (hasSeed === void 0) {
                hasSeed = false;
              }

              this.accumulator = accumulator;
              this.seed = seed;
              this.hasSeed = hasSeed;
            }

            ScanOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
            };

            return ScanOperator;
          })();

        var ScanSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ScanSubscriber, _super);

            function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
              var _this = _super.call(this, destination) || this;

              _this.accumulator = accumulator;
              _this._seed = _seed;
              _this.hasSeed = hasSeed;
              _this.index = 0;
              return _this;
            }

            Object.defineProperty(ScanSubscriber.prototype, 'seed', {
              get: function() {
                return this._seed;
              },
              set: function(value) {
                this.hasSeed = true;
                this._seed = value;
              },
              enumerable: true,
              configurable: true,
            });

            ScanSubscriber.prototype._next = function(value) {
              if (!this.hasSeed) {
                this.seed = value;
                this.destination.next(value);
              } else {
                return this._tryNext(value);
              }
            };

            ScanSubscriber.prototype._tryNext = function(value) {
              var index = this.index++;
              var result;

              try {
                result = this.accumulator(this.seed, value, index);
              } catch (err) {
                this.destination.error(err);
              }

              this.seed = result;
              this.destination.next(result);
            };

            return ScanSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/reduce.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.reduce = reduce;

        var _scan = require('./scan');

        var _takeLast = require('./takeLast');

        var _defaultIfEmpty = require('./defaultIfEmpty');

        var _pipe = require('../util/pipe');

        /** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
        function reduce(accumulator, seed) {
          if (arguments.length >= 2) {
            return function reduceOperatorFunctionWithSeed(source) {
              return (0, _pipe.pipe)(
                (0, _scan.scan)(accumulator, seed),
                (0, _takeLast.takeLast)(1),
                (0, _defaultIfEmpty.defaultIfEmpty)(seed)
              )(source);
            };
          }

          return function reduceOperatorFunction(source) {
            return (0, _pipe.pipe)(
              (0, _scan.scan)(function(acc, value, index) {
                return accumulator(acc, value, index + 1);
              }),
              (0, _takeLast.takeLast)(1)
            )(source);
          };
        }
      },
      {
        './scan': '../../../node_modules/rxjs/_esm5/internal/operators/scan.js',
        './takeLast': '../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js',
        './defaultIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
        '../util/pipe': '../../../node_modules/rxjs/_esm5/internal/util/pipe.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/max.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.max = max;

        var _reduce = require('./reduce');

        /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
        function max(comparer) {
          var max =
            typeof comparer === 'function'
              ? function(x, y) {
                  return comparer(x, y) > 0 ? x : y;
                }
              : function(x, y) {
                  return x > y ? x : y;
                };
          return (0, _reduce.reduce)(max);
        }
      },
      { './reduce': '../../../node_modules/rxjs/_esm5/internal/operators/reduce.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/merge.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.merge = merge;

        var _merge = require('../observable/merge');

        /** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */
        function merge() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          return function(source) {
            return source.lift.call(_merge.merge.apply(void 0, [source].concat(observables)));
          };
        }
      },
      { '../observable/merge': '../../../node_modules/rxjs/_esm5/internal/observable/merge.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.mergeMapTo = mergeMapTo;

        var _mergeMap = require('./mergeMap');

        /** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
        function mergeMapTo(innerObservable, resultSelector, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }

          if (typeof resultSelector === 'function') {
            return (0, _mergeMap.mergeMap)(
              function() {
                return innerObservable;
              },
              resultSelector,
              concurrent
            );
          }

          if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
          }

          return (0, _mergeMap.mergeMap)(function() {
            return innerObservable;
          }, concurrent);
        }
      },
      { './mergeMap': '../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/mergeScan.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.mergeScan = mergeScan;
        exports.MergeScanSubscriber = exports.MergeScanOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _subscribeToResult = require('../util/subscribeToResult');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */
        function mergeScan(accumulator, seed, concurrent) {
          if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
          }

          return function(source) {
            return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
          };
        }

        var MergeScanOperator =
          /*@__PURE__*/
          (function() {
            function MergeScanOperator(accumulator, seed, concurrent) {
              this.accumulator = accumulator;
              this.seed = seed;
              this.concurrent = concurrent;
            }

            MergeScanOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent)
              );
            };

            return MergeScanOperator;
          })();

        exports.MergeScanOperator = MergeScanOperator;

        var MergeScanSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(MergeScanSubscriber, _super);

            function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
              var _this = _super.call(this, destination) || this;

              _this.accumulator = accumulator;
              _this.acc = acc;
              _this.concurrent = concurrent;
              _this.hasValue = false;
              _this.hasCompleted = false;
              _this.buffer = [];
              _this.active = 0;
              _this.index = 0;
              return _this;
            }

            MergeScanSubscriber.prototype._next = function(value) {
              if (this.active < this.concurrent) {
                var index = this.index++;
                var destination = this.destination;
                var ish = void 0;

                try {
                  var accumulator = this.accumulator;
                  ish = accumulator(this.acc, value, index);
                } catch (e) {
                  return destination.error(e);
                }

                this.active++;

                this._innerSub(ish, value, index);
              } else {
                this.buffer.push(value);
              }
            };

            MergeScanSubscriber.prototype._innerSub = function(ish, value, index) {
              var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, value, index);
              var destination = this.destination;
              destination.add(innerSubscriber);
              var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                this,
                ish,
                undefined,
                undefined,
                innerSubscriber
              );

              if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
              }
            };

            MergeScanSubscriber.prototype._complete = function() {
              this.hasCompleted = true;

              if (this.active === 0 && this.buffer.length === 0) {
                if (this.hasValue === false) {
                  this.destination.next(this.acc);
                }

                this.destination.complete();
              }

              this.unsubscribe();
            };

            MergeScanSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              var destination = this.destination;
              this.acc = innerValue;
              this.hasValue = true;
              destination.next(innerValue);
            };

            MergeScanSubscriber.prototype.notifyComplete = function(innerSub) {
              var buffer = this.buffer;
              var destination = this.destination;
              destination.remove(innerSub);
              this.active--;

              if (buffer.length > 0) {
                this._next(buffer.shift());
              } else if (this.active === 0 && this.hasCompleted) {
                if (this.hasValue === false) {
                  this.destination.next(this.acc);
                }

                this.destination.complete();
              }
            };

            return MergeScanSubscriber;
          })(_OuterSubscriber.OuterSubscriber);

        exports.MergeScanSubscriber = MergeScanSubscriber;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/min.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.min = min;

        var _reduce = require('./reduce');

        /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
        function min(comparer) {
          var min =
            typeof comparer === 'function'
              ? function(x, y) {
                  return comparer(x, y) < 0 ? x : y;
                }
              : function(x, y) {
                  return x < y ? x : y;
                };
          return (0, _reduce.reduce)(min);
        }
      },
      { './reduce': '../../../node_modules/rxjs/_esm5/internal/operators/reduce.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.multicast = multicast;
        exports.MulticastOperator = void 0;

        var _ConnectableObservable = require('../observable/ConnectableObservable');

        /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
        function multicast(subjectOrSubjectFactory, selector) {
          return function multicastOperatorFunction(source) {
            var subjectFactory;

            if (typeof subjectOrSubjectFactory === 'function') {
              subjectFactory = subjectOrSubjectFactory;
            } else {
              subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
              };
            }

            if (typeof selector === 'function') {
              return source.lift(new MulticastOperator(subjectFactory, selector));
            }

            var connectable = Object.create(source, _ConnectableObservable.connectableObservableDescriptor);
            connectable.source = source;
            connectable.subjectFactory = subjectFactory;
            return connectable;
          };
        }

        var MulticastOperator =
          /*@__PURE__*/
          (function() {
            function MulticastOperator(subjectFactory, selector) {
              this.subjectFactory = subjectFactory;
              this.selector = selector;
            }

            MulticastOperator.prototype.call = function(subscriber, source) {
              var selector = this.selector;
              var subject = this.subjectFactory();
              var subscription = selector(subject).subscribe(subscriber);
              subscription.add(source.subscribe(subject));
              return subscription;
            };

            return MulticastOperator;
          })();

        exports.MulticastOperator = MulticastOperator;
      },
      {
        '../observable/ConnectableObservable':
          '../../../node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.onErrorResumeNext = onErrorResumeNext;
        exports.onErrorResumeNextStatic = onErrorResumeNextStatic;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _from = require('../observable/from');

        var _isArray = require('../util/isArray');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function onErrorResumeNext() {
          var nextSources = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i] = arguments[_i];
          }

          if (nextSources.length === 1 && (0, _isArray.isArray)(nextSources[0])) {
            nextSources = nextSources[0];
          }

          return function(source) {
            return source.lift(new OnErrorResumeNextOperator(nextSources));
          };
        }

        function onErrorResumeNextStatic() {
          var nextSources = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            nextSources[_i] = arguments[_i];
          }

          var source = null;

          if (nextSources.length === 1 && (0, _isArray.isArray)(nextSources[0])) {
            nextSources = nextSources[0];
          }

          source = nextSources.shift();
          return (0, _from.from)(source, null).lift(new OnErrorResumeNextOperator(nextSources));
        }

        var OnErrorResumeNextOperator =
          /*@__PURE__*/
          (function() {
            function OnErrorResumeNextOperator(nextSources) {
              this.nextSources = nextSources;
            }

            OnErrorResumeNextOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
            };

            return OnErrorResumeNextOperator;
          })();

        var OnErrorResumeNextSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(OnErrorResumeNextSubscriber, _super);

            function OnErrorResumeNextSubscriber(destination, nextSources) {
              var _this = _super.call(this, destination) || this;

              _this.destination = destination;
              _this.nextSources = nextSources;
              return _this;
            }

            OnErrorResumeNextSubscriber.prototype.notifyError = function(error, innerSub) {
              this.subscribeToNextSource();
            };

            OnErrorResumeNextSubscriber.prototype.notifyComplete = function(innerSub) {
              this.subscribeToNextSource();
            };

            OnErrorResumeNextSubscriber.prototype._error = function(err) {
              this.subscribeToNextSource();
              this.unsubscribe();
            };

            OnErrorResumeNextSubscriber.prototype._complete = function() {
              this.subscribeToNextSource();
              this.unsubscribe();
            };

            OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function() {
              var next = this.nextSources.shift();

              if (!!next) {
                var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, undefined, undefined);
                var destination = this.destination;
                destination.add(innerSubscriber);
                var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                  this,
                  next,
                  undefined,
                  undefined,
                  innerSubscriber
                );

                if (innerSubscription !== innerSubscriber) {
                  destination.add(innerSubscription);
                }
              } else {
                this.destination.complete();
              }
            };

            return OnErrorResumeNextSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../observable/from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/pairwise.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.pairwise = pairwise;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function pairwise() {
          return function(source) {
            return source.lift(new PairwiseOperator());
          };
        }

        var PairwiseOperator =
          /*@__PURE__*/
          (function() {
            function PairwiseOperator() {}

            PairwiseOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new PairwiseSubscriber(subscriber));
            };

            return PairwiseOperator;
          })();

        var PairwiseSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(PairwiseSubscriber, _super);

            function PairwiseSubscriber(destination) {
              var _this = _super.call(this, destination) || this;

              _this.hasPrev = false;
              return _this;
            }

            PairwiseSubscriber.prototype._next = function(value) {
              var pair;

              if (this.hasPrev) {
                pair = [this.prev, value];
              } else {
                this.hasPrev = true;
              }

              this.prev = value;

              if (pair) {
                this.destination.next(pair);
              }
            };

            return PairwiseSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/partition.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.partition = partition;

        var _not = require('../util/not');

        var _filter = require('./filter');

        /** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */
        function partition(predicate, thisArg) {
          return function(source) {
            return [
              (0, _filter.filter)(predicate, thisArg)(source),
              (0, _filter.filter)((0, _not.not)(predicate, thisArg))(source),
            ];
          };
        }
      },
      {
        '../util/not': '../../../node_modules/rxjs/_esm5/internal/util/not.js',
        './filter': '../../../node_modules/rxjs/_esm5/internal/operators/filter.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/pluck.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.pluck = pluck;

        var _map = require('./map');

        /** PURE_IMPORTS_START _map PURE_IMPORTS_END */
        function pluck() {
          var properties = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            properties[_i] = arguments[_i];
          }

          var length = properties.length;

          if (length === 0) {
            throw new Error('list of properties cannot be empty.');
          }

          return function(source) {
            return (0, _map.map)(plucker(properties, length))(source);
          };
        }

        function plucker(props, length) {
          var mapper = function(x) {
            var currentProp = x;

            for (var i = 0; i < length; i++) {
              var p = currentProp[props[i]];

              if (typeof p !== 'undefined') {
                currentProp = p;
              } else {
                return undefined;
              }
            }

            return currentProp;
          };

          return mapper;
        }
      },
      { './map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/publish.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.publish = publish;

        var _Subject = require('../Subject');

        var _multicast = require('./multicast');

        /** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
        function publish(selector) {
          return selector
            ? (0, _multicast.multicast)(function() {
                return new _Subject.Subject();
              }, selector)
            : (0, _multicast.multicast)(new _Subject.Subject());
        }
      },
      {
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        './multicast': '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.publishBehavior = publishBehavior;

        var _BehaviorSubject = require('../BehaviorSubject');

        var _multicast = require('./multicast');

        /** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */
        function publishBehavior(value) {
          return function(source) {
            return (0, _multicast.multicast)(new _BehaviorSubject.BehaviorSubject(value))(source);
          };
        }
      },
      {
        '../BehaviorSubject': '../../../node_modules/rxjs/_esm5/internal/BehaviorSubject.js',
        './multicast': '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/publishLast.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.publishLast = publishLast;

        var _AsyncSubject = require('../AsyncSubject');

        var _multicast = require('./multicast');

        /** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */
        function publishLast() {
          return function(source) {
            return (0, _multicast.multicast)(new _AsyncSubject.AsyncSubject())(source);
          };
        }
      },
      {
        '../AsyncSubject': '../../../node_modules/rxjs/_esm5/internal/AsyncSubject.js',
        './multicast': '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/publishReplay.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.publishReplay = publishReplay;

        var _ReplaySubject = require('../ReplaySubject');

        var _multicast = require('./multicast');

        /** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
        function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
          if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
            scheduler = selectorOrScheduler;
          }

          var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
          var subject = new _ReplaySubject.ReplaySubject(bufferSize, windowTime, scheduler);
          return function(source) {
            return (0, _multicast.multicast)(function() {
              return subject;
            }, selector)(source);
          };
        }
      },
      {
        '../ReplaySubject': '../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js',
        './multicast': '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/race.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.race = race;

        var _isArray = require('../util/isArray');

        var _race = require('../observable/race');

        /** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */
        function race() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          return function raceOperatorFunction(source) {
            if (observables.length === 1 && (0, _isArray.isArray)(observables[0])) {
              observables = observables[0];
            }

            return source.lift.call(_race.race.apply(void 0, [source].concat(observables)));
          };
        }
      },
      {
        '../util/isArray': '../../../node_modules/rxjs/_esm5/internal/util/isArray.js',
        '../observable/race': '../../../node_modules/rxjs/_esm5/internal/observable/race.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/repeat.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.repeat = repeat;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _empty = require('../observable/empty');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
        function repeat(count) {
          if (count === void 0) {
            count = -1;
          }

          return function(source) {
            if (count === 0) {
              return (0, _empty.empty)();
            } else if (count < 0) {
              return source.lift(new RepeatOperator(-1, source));
            } else {
              return source.lift(new RepeatOperator(count - 1, source));
            }
          };
        }

        var RepeatOperator =
          /*@__PURE__*/
          (function() {
            function RepeatOperator(count, source) {
              this.count = count;
              this.source = source;
            }

            RepeatOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
            };

            return RepeatOperator;
          })();

        var RepeatSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RepeatSubscriber, _super);

            function RepeatSubscriber(destination, count, source) {
              var _this = _super.call(this, destination) || this;

              _this.count = count;
              _this.source = source;
              return _this;
            }

            RepeatSubscriber.prototype.complete = function() {
              if (!this.isStopped) {
                var _a = this,
                  source = _a.source,
                  count = _a.count;

                if (count === 0) {
                  return _super.prototype.complete.call(this);
                } else if (count > -1) {
                  this.count = count - 1;
                }

                source.subscribe(this._unsubscribeAndRecycle());
              }
            };

            return RepeatSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../observable/empty': '../../../node_modules/rxjs/_esm5/internal/observable/empty.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.repeatWhen = repeatWhen;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function repeatWhen(notifier) {
          return function(source) {
            return source.lift(new RepeatWhenOperator(notifier));
          };
        }

        var RepeatWhenOperator =
          /*@__PURE__*/
          (function() {
            function RepeatWhenOperator(notifier) {
              this.notifier = notifier;
            }

            RepeatWhenOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
            };

            return RepeatWhenOperator;
          })();

        var RepeatWhenSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RepeatWhenSubscriber, _super);

            function RepeatWhenSubscriber(destination, notifier, source) {
              var _this = _super.call(this, destination) || this;

              _this.notifier = notifier;
              _this.source = source;
              _this.sourceIsBeingSubscribedTo = true;
              return _this;
            }

            RepeatWhenSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.sourceIsBeingSubscribedTo = true;
              this.source.subscribe(this);
            };

            RepeatWhenSubscriber.prototype.notifyComplete = function(innerSub) {
              if (this.sourceIsBeingSubscribedTo === false) {
                return _super.prototype.complete.call(this);
              }
            };

            RepeatWhenSubscriber.prototype.complete = function() {
              this.sourceIsBeingSubscribedTo = false;

              if (!this.isStopped) {
                if (!this.retries) {
                  this.subscribeToRetries();
                }

                if (!this.retriesSubscription || this.retriesSubscription.closed) {
                  return _super.prototype.complete.call(this);
                }

                this._unsubscribeAndRecycle();

                this.notifications.next();
              }
            };

            RepeatWhenSubscriber.prototype._unsubscribe = function() {
              var _a = this,
                notifications = _a.notifications,
                retriesSubscription = _a.retriesSubscription;

              if (notifications) {
                notifications.unsubscribe();
                this.notifications = null;
              }

              if (retriesSubscription) {
                retriesSubscription.unsubscribe();
                this.retriesSubscription = null;
              }

              this.retries = null;
            };

            RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function() {
              var _unsubscribe = this._unsubscribe;
              this._unsubscribe = null;

              _super.prototype._unsubscribeAndRecycle.call(this);

              this._unsubscribe = _unsubscribe;
              return this;
            };

            RepeatWhenSubscriber.prototype.subscribeToRetries = function() {
              this.notifications = new _Subject.Subject();
              var retries;

              try {
                var notifier = this.notifier;
                retries = notifier(this.notifications);
              } catch (e) {
                return _super.prototype.complete.call(this);
              }

              this.retries = retries;
              this.retriesSubscription = (0, _subscribeToResult.subscribeToResult)(this, retries);
            };

            return RepeatWhenSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/retry.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.retry = retry;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function retry(count) {
          if (count === void 0) {
            count = -1;
          }

          return function(source) {
            return source.lift(new RetryOperator(count, source));
          };
        }

        var RetryOperator =
          /*@__PURE__*/
          (function() {
            function RetryOperator(count, source) {
              this.count = count;
              this.source = source;
            }

            RetryOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
            };

            return RetryOperator;
          })();

        var RetrySubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RetrySubscriber, _super);

            function RetrySubscriber(destination, count, source) {
              var _this = _super.call(this, destination) || this;

              _this.count = count;
              _this.source = source;
              return _this;
            }

            RetrySubscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                var _a = this,
                  source = _a.source,
                  count = _a.count;

                if (count === 0) {
                  return _super.prototype.error.call(this, err);
                } else if (count > -1) {
                  this.count = count - 1;
                }

                source.subscribe(this._unsubscribeAndRecycle());
              }
            };

            return RetrySubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/retryWhen.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.retryWhen = retryWhen;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function retryWhen(notifier) {
          return function(source) {
            return source.lift(new RetryWhenOperator(notifier, source));
          };
        }

        var RetryWhenOperator =
          /*@__PURE__*/
          (function() {
            function RetryWhenOperator(notifier, source) {
              this.notifier = notifier;
              this.source = source;
            }

            RetryWhenOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
            };

            return RetryWhenOperator;
          })();

        var RetryWhenSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(RetryWhenSubscriber, _super);

            function RetryWhenSubscriber(destination, notifier, source) {
              var _this = _super.call(this, destination) || this;

              _this.notifier = notifier;
              _this.source = source;
              return _this;
            }

            RetryWhenSubscriber.prototype.error = function(err) {
              if (!this.isStopped) {
                var errors = this.errors;
                var retries = this.retries;
                var retriesSubscription = this.retriesSubscription;

                if (!retries) {
                  errors = new _Subject.Subject();

                  try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                  } catch (e) {
                    return _super.prototype.error.call(this, e);
                  }

                  retriesSubscription = (0, _subscribeToResult.subscribeToResult)(this, retries);
                } else {
                  this.errors = null;
                  this.retriesSubscription = null;
                }

                this._unsubscribeAndRecycle();

                this.errors = errors;
                this.retries = retries;
                this.retriesSubscription = retriesSubscription;
                errors.next(err);
              }
            };

            RetryWhenSubscriber.prototype._unsubscribe = function() {
              var _a = this,
                errors = _a.errors,
                retriesSubscription = _a.retriesSubscription;

              if (errors) {
                errors.unsubscribe();
                this.errors = null;
              }

              if (retriesSubscription) {
                retriesSubscription.unsubscribe();
                this.retriesSubscription = null;
              }

              this.retries = null;
            };

            RetryWhenSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              var _unsubscribe = this._unsubscribe;
              this._unsubscribe = null;

              this._unsubscribeAndRecycle();

              this._unsubscribe = _unsubscribe;
              this.source.subscribe(this);
            };

            return RetryWhenSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/sample.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.sample = sample;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function sample(notifier) {
          return function(source) {
            return source.lift(new SampleOperator(notifier));
          };
        }

        var SampleOperator =
          /*@__PURE__*/
          (function() {
            function SampleOperator(notifier) {
              this.notifier = notifier;
            }

            SampleOperator.prototype.call = function(subscriber, source) {
              var sampleSubscriber = new SampleSubscriber(subscriber);
              var subscription = source.subscribe(sampleSubscriber);
              subscription.add((0, _subscribeToResult.subscribeToResult)(sampleSubscriber, this.notifier));
              return subscription;
            };

            return SampleOperator;
          })();

        var SampleSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SampleSubscriber, _super);

            function SampleSubscriber() {
              var _this = (_super !== null && _super.apply(this, arguments)) || this;

              _this.hasValue = false;
              return _this;
            }

            SampleSubscriber.prototype._next = function(value) {
              this.value = value;
              this.hasValue = true;
            };

            SampleSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              this.emitValue();
            };

            SampleSubscriber.prototype.notifyComplete = function() {
              this.emitValue();
            };

            SampleSubscriber.prototype.emitValue = function() {
              if (this.hasValue) {
                this.hasValue = false;
                this.destination.next(this.value);
              }
            };

            return SampleSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/sampleTime.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.sampleTime = sampleTime;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _async = require('../scheduler/async');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
        function sampleTime(period, scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return function(source) {
            return source.lift(new SampleTimeOperator(period, scheduler));
          };
        }

        var SampleTimeOperator =
          /*@__PURE__*/
          (function() {
            function SampleTimeOperator(period, scheduler) {
              this.period = period;
              this.scheduler = scheduler;
            }

            SampleTimeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
            };

            return SampleTimeOperator;
          })();

        var SampleTimeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SampleTimeSubscriber, _super);

            function SampleTimeSubscriber(destination, period, scheduler) {
              var _this = _super.call(this, destination) || this;

              _this.period = period;
              _this.scheduler = scheduler;
              _this.hasValue = false;

              _this.add(
                scheduler.schedule(dispatchNotification, period, {
                  subscriber: _this,
                  period: period,
                })
              );

              return _this;
            }

            SampleTimeSubscriber.prototype._next = function(value) {
              this.lastValue = value;
              this.hasValue = true;
            };

            SampleTimeSubscriber.prototype.notifyNext = function() {
              if (this.hasValue) {
                this.hasValue = false;
                this.destination.next(this.lastValue);
              }
            };

            return SampleTimeSubscriber;
          })(_Subscriber.Subscriber);

        function dispatchNotification(state) {
          var subscriber = state.subscriber,
            period = state.period;
          subscriber.notifyNext();
          this.schedule(state, period);
        }
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.sequenceEqual = sequenceEqual;
        exports.SequenceEqualSubscriber = exports.SequenceEqualOperator = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function sequenceEqual(compareTo, comparator) {
          return function(source) {
            return source.lift(new SequenceEqualOperator(compareTo, comparator));
          };
        }

        var SequenceEqualOperator =
          /*@__PURE__*/
          (function() {
            function SequenceEqualOperator(compareTo, comparator) {
              this.compareTo = compareTo;
              this.comparator = comparator;
            }

            SequenceEqualOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
            };

            return SequenceEqualOperator;
          })();

        exports.SequenceEqualOperator = SequenceEqualOperator;

        var SequenceEqualSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SequenceEqualSubscriber, _super);

            function SequenceEqualSubscriber(destination, compareTo, comparator) {
              var _this = _super.call(this, destination) || this;

              _this.compareTo = compareTo;
              _this.comparator = comparator;
              _this._a = [];
              _this._b = [];
              _this._oneComplete = false;

              _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));

              return _this;
            }

            SequenceEqualSubscriber.prototype._next = function(value) {
              if (this._oneComplete && this._b.length === 0) {
                this.emit(false);
              } else {
                this._a.push(value);

                this.checkValues();
              }
            };

            SequenceEqualSubscriber.prototype._complete = function() {
              if (this._oneComplete) {
                this.emit(this._a.length === 0 && this._b.length === 0);
              } else {
                this._oneComplete = true;
              }

              this.unsubscribe();
            };

            SequenceEqualSubscriber.prototype.checkValues = function() {
              var _c = this,
                _a = _c._a,
                _b = _c._b,
                comparator = _c.comparator;

              while (_a.length > 0 && _b.length > 0) {
                var a = _a.shift();

                var b = _b.shift();

                var areEqual = false;

                try {
                  areEqual = comparator ? comparator(a, b) : a === b;
                } catch (e) {
                  this.destination.error(e);
                }

                if (!areEqual) {
                  this.emit(false);
                }
              }
            };

            SequenceEqualSubscriber.prototype.emit = function(value) {
              var destination = this.destination;
              destination.next(value);
              destination.complete();
            };

            SequenceEqualSubscriber.prototype.nextB = function(value) {
              if (this._oneComplete && this._a.length === 0) {
                this.emit(false);
              } else {
                this._b.push(value);

                this.checkValues();
              }
            };

            SequenceEqualSubscriber.prototype.completeB = function() {
              if (this._oneComplete) {
                this.emit(this._a.length === 0 && this._b.length === 0);
              } else {
                this._oneComplete = true;
              }
            };

            return SequenceEqualSubscriber;
          })(_Subscriber.Subscriber);

        exports.SequenceEqualSubscriber = SequenceEqualSubscriber;

        var SequenceEqualCompareToSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SequenceEqualCompareToSubscriber, _super);

            function SequenceEqualCompareToSubscriber(destination, parent) {
              var _this = _super.call(this, destination) || this;

              _this.parent = parent;
              return _this;
            }

            SequenceEqualCompareToSubscriber.prototype._next = function(value) {
              this.parent.nextB(value);
            };

            SequenceEqualCompareToSubscriber.prototype._error = function(err) {
              this.parent.error(err);
              this.unsubscribe();
            };

            SequenceEqualCompareToSubscriber.prototype._complete = function() {
              this.parent.completeB();
              this.unsubscribe();
            };

            return SequenceEqualCompareToSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/share.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.share = share;

        var _multicast = require('./multicast');

        var _refCount = require('./refCount');

        var _Subject = require('../Subject');

        /** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
        function shareSubjectFactory() {
          return new _Subject.Subject();
        }

        function share() {
          return function(source) {
            return (0, _refCount.refCount)()((0, _multicast.multicast)(shareSubjectFactory)(source));
          };
        }
      },
      {
        './multicast': '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js',
        './refCount': '../../../node_modules/rxjs/_esm5/internal/operators/refCount.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/shareReplay.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shareReplay = shareReplay;

        var _ReplaySubject = require('../ReplaySubject');

        /** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */
        function shareReplay(configOrBufferSize, windowTime, scheduler) {
          var config;

          if (configOrBufferSize && typeof configOrBufferSize === 'object') {
            config = configOrBufferSize;
          } else {
            config = {
              bufferSize: configOrBufferSize,
              windowTime: windowTime,
              refCount: false,
              scheduler: scheduler,
            };
          }

          return function(source) {
            return source.lift(shareReplayOperator(config));
          };
        }

        function shareReplayOperator(_a) {
          var _b = _a.bufferSize,
            bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b,
            _c = _a.windowTime,
            windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c,
            useRefCount = _a.refCount,
            scheduler = _a.scheduler;
          var subject;
          var refCount = 0;
          var subscription;
          var hasError = false;
          var isComplete = false;
          return function shareReplayOperation(source) {
            refCount++;

            if (!subject || hasError) {
              hasError = false;
              subject = new _ReplaySubject.ReplaySubject(bufferSize, windowTime, scheduler);
              subscription = source.subscribe({
                next: function(value) {
                  subject.next(value);
                },
                error: function(err) {
                  hasError = true;
                  subject.error(err);
                },
                complete: function() {
                  isComplete = true;
                  subscription = undefined;
                  subject.complete();
                },
              });
            }

            var innerSub = subject.subscribe(this);
            this.add(function() {
              refCount--;
              innerSub.unsubscribe();

              if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
              }
            });
          };
        }
      },
      { '../ReplaySubject': '../../../node_modules/rxjs/_esm5/internal/ReplaySubject.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/single.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.single = single;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _EmptyError = require('../util/EmptyError');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
        function single(predicate) {
          return function(source) {
            return source.lift(new SingleOperator(predicate, source));
          };
        }

        var SingleOperator =
          /*@__PURE__*/
          (function() {
            function SingleOperator(predicate, source) {
              this.predicate = predicate;
              this.source = source;
            }

            SingleOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
            };

            return SingleOperator;
          })();

        var SingleSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SingleSubscriber, _super);

            function SingleSubscriber(destination, predicate, source) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.source = source;
              _this.seenValue = false;
              _this.index = 0;
              return _this;
            }

            SingleSubscriber.prototype.applySingleValue = function(value) {
              if (this.seenValue) {
                this.destination.error('Sequence contains more than one element');
              } else {
                this.seenValue = true;
                this.singleValue = value;
              }
            };

            SingleSubscriber.prototype._next = function(value) {
              var index = this.index++;

              if (this.predicate) {
                this.tryNext(value, index);
              } else {
                this.applySingleValue(value);
              }
            };

            SingleSubscriber.prototype.tryNext = function(value, index) {
              try {
                if (this.predicate(value, index, this.source)) {
                  this.applySingleValue(value);
                }
              } catch (err) {
                this.destination.error(err);
              }
            };

            SingleSubscriber.prototype._complete = function() {
              var destination = this.destination;

              if (this.index > 0) {
                destination.next(this.seenValue ? this.singleValue : undefined);
                destination.complete();
              } else {
                destination.error(new _EmptyError.EmptyError());
              }
            };

            return SingleSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/EmptyError': '../../../node_modules/rxjs/_esm5/internal/util/EmptyError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/skip.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.skip = skip;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function skip(count) {
          return function(source) {
            return source.lift(new SkipOperator(count));
          };
        }

        var SkipOperator =
          /*@__PURE__*/
          (function() {
            function SkipOperator(total) {
              this.total = total;
            }

            SkipOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SkipSubscriber(subscriber, this.total));
            };

            return SkipOperator;
          })();

        var SkipSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SkipSubscriber, _super);

            function SkipSubscriber(destination, total) {
              var _this = _super.call(this, destination) || this;

              _this.total = total;
              _this.count = 0;
              return _this;
            }

            SkipSubscriber.prototype._next = function(x) {
              if (++this.count > this.total) {
                this.destination.next(x);
              }
            };

            return SkipSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/skipLast.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.skipLast = skipLast;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _ArgumentOutOfRangeError = require('../util/ArgumentOutOfRangeError');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
        function skipLast(count) {
          return function(source) {
            return source.lift(new SkipLastOperator(count));
          };
        }

        var SkipLastOperator =
          /*@__PURE__*/
          (function() {
            function SkipLastOperator(_skipCount) {
              this._skipCount = _skipCount;

              if (this._skipCount < 0) {
                throw new _ArgumentOutOfRangeError.ArgumentOutOfRangeError();
              }
            }

            SkipLastOperator.prototype.call = function(subscriber, source) {
              if (this._skipCount === 0) {
                return source.subscribe(new _Subscriber.Subscriber(subscriber));
              } else {
                return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
              }
            };

            return SkipLastOperator;
          })();

        var SkipLastSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SkipLastSubscriber, _super);

            function SkipLastSubscriber(destination, _skipCount) {
              var _this = _super.call(this, destination) || this;

              _this._skipCount = _skipCount;
              _this._count = 0;
              _this._ring = new Array(_skipCount);
              return _this;
            }

            SkipLastSubscriber.prototype._next = function(value) {
              var skipCount = this._skipCount;
              var count = this._count++;

              if (count < skipCount) {
                this._ring[count] = value;
              } else {
                var currentIndex = count % skipCount;
                var ring = this._ring;
                var oldValue = ring[currentIndex];
                ring[currentIndex] = value;
                this.destination.next(oldValue);
              }
            };

            return SkipLastSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/ArgumentOutOfRangeError': '../../../node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/skipUntil.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.skipUntil = skipUntil;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function skipUntil(notifier) {
          return function(source) {
            return source.lift(new SkipUntilOperator(notifier));
          };
        }

        var SkipUntilOperator =
          /*@__PURE__*/
          (function() {
            function SkipUntilOperator(notifier) {
              this.notifier = notifier;
            }

            SkipUntilOperator.prototype.call = function(destination, source) {
              return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
            };

            return SkipUntilOperator;
          })();

        var SkipUntilSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SkipUntilSubscriber, _super);

            function SkipUntilSubscriber(destination, notifier) {
              var _this = _super.call(this, destination) || this;

              _this.hasValue = false;
              var innerSubscriber = new _InnerSubscriber.InnerSubscriber(_this, undefined, undefined);

              _this.add(innerSubscriber);

              _this.innerSubscription = innerSubscriber;
              var innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                _this,
                notifier,
                undefined,
                undefined,
                innerSubscriber
              );

              if (innerSubscription !== innerSubscriber) {
                _this.add(innerSubscription);

                _this.innerSubscription = innerSubscription;
              }

              return _this;
            }

            SkipUntilSubscriber.prototype._next = function(value) {
              if (this.hasValue) {
                _super.prototype._next.call(this, value);
              }
            };

            SkipUntilSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.hasValue = true;

              if (this.innerSubscription) {
                this.innerSubscription.unsubscribe();
              }
            };

            SkipUntilSubscriber.prototype.notifyComplete = function() {};

            return SkipUntilSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/skipWhile.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.skipWhile = skipWhile;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function skipWhile(predicate) {
          return function(source) {
            return source.lift(new SkipWhileOperator(predicate));
          };
        }

        var SkipWhileOperator =
          /*@__PURE__*/
          (function() {
            function SkipWhileOperator(predicate) {
              this.predicate = predicate;
            }

            SkipWhileOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
            };

            return SkipWhileOperator;
          })();

        var SkipWhileSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SkipWhileSubscriber, _super);

            function SkipWhileSubscriber(destination, predicate) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.skipping = true;
              _this.index = 0;
              return _this;
            }

            SkipWhileSubscriber.prototype._next = function(value) {
              var destination = this.destination;

              if (this.skipping) {
                this.tryCallPredicate(value);
              }

              if (!this.skipping) {
                destination.next(value);
              }
            };

            SkipWhileSubscriber.prototype.tryCallPredicate = function(value) {
              try {
                var result = this.predicate(value, this.index++);
                this.skipping = Boolean(result);
              } catch (err) {
                this.destination.error(err);
              }
            };

            return SkipWhileSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/startWith.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.startWith = startWith;

        var _concat = require('../observable/concat');

        var _isScheduler = require('../util/isScheduler');

        /** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
        function startWith() {
          var array = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            array[_i] = arguments[_i];
          }

          var scheduler = array[array.length - 1];

          if ((0, _isScheduler.isScheduler)(scheduler)) {
            array.pop();
            return function(source) {
              return (0, _concat.concat)(array, source, scheduler);
            };
          } else {
            return function(source) {
              return (0, _concat.concat)(array, source);
            };
          }
        }
      },
      {
        '../observable/concat': '../../../node_modules/rxjs/_esm5/internal/observable/concat.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.SubscribeOnObservable = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Observable = require('../Observable');

        var _asap = require('../scheduler/asap');

        var _isNumeric = require('../util/isNumeric');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
        var SubscribeOnObservable =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SubscribeOnObservable, _super);

            function SubscribeOnObservable(source, delayTime, scheduler) {
              if (delayTime === void 0) {
                delayTime = 0;
              }

              if (scheduler === void 0) {
                scheduler = _asap.asap;
              }

              var _this = _super.call(this) || this;

              _this.source = source;
              _this.delayTime = delayTime;
              _this.scheduler = scheduler;

              if (!(0, _isNumeric.isNumeric)(delayTime) || delayTime < 0) {
                _this.delayTime = 0;
              }

              if (!scheduler || typeof scheduler.schedule !== 'function') {
                _this.scheduler = _asap.asap;
              }

              return _this;
            }

            SubscribeOnObservable.create = function(source, delay, scheduler) {
              if (delay === void 0) {
                delay = 0;
              }

              if (scheduler === void 0) {
                scheduler = _asap.asap;
              }

              return new SubscribeOnObservable(source, delay, scheduler);
            };

            SubscribeOnObservable.dispatch = function(arg) {
              var source = arg.source,
                subscriber = arg.subscriber;
              return this.add(source.subscribe(subscriber));
            };

            SubscribeOnObservable.prototype._subscribe = function(subscriber) {
              var delay = this.delayTime;
              var source = this.source;
              var scheduler = this.scheduler;
              return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
                source: source,
                subscriber: subscriber,
              });
            };

            return SubscribeOnObservable;
          })(_Observable.Observable);

        exports.SubscribeOnObservable = SubscribeOnObservable;
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Observable': '../../../node_modules/rxjs/_esm5/internal/Observable.js',
        '../scheduler/asap': '../../../node_modules/rxjs/_esm5/internal/scheduler/asap.js',
        '../util/isNumeric': '../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.subscribeOn = subscribeOn;

        var _SubscribeOnObservable = require('../observable/SubscribeOnObservable');

        /** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
        function subscribeOn(scheduler, delay) {
          if (delay === void 0) {
            delay = 0;
          }

          return function subscribeOnOperatorFunction(source) {
            return source.lift(new SubscribeOnOperator(scheduler, delay));
          };
        }

        var SubscribeOnOperator =
          /*@__PURE__*/
          (function() {
            function SubscribeOnOperator(scheduler, delay) {
              this.scheduler = scheduler;
              this.delay = delay;
            }

            SubscribeOnOperator.prototype.call = function(subscriber, source) {
              return new _SubscribeOnObservable.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(
                subscriber
              );
            };

            return SubscribeOnOperator;
          })();
      },
      {
        '../observable/SubscribeOnObservable':
          '../../../node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.switchMap = switchMap;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _InnerSubscriber = require('../InnerSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        var _map = require('./map');

        var _from = require('../observable/from');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
        function switchMap(project, resultSelector) {
          if (typeof resultSelector === 'function') {
            return function(source) {
              return source.pipe(
                switchMap(function(a, i) {
                  return (0, _from.from)(project(a, i)).pipe(
                    (0, _map.map)(function(b, ii) {
                      return resultSelector(a, b, i, ii);
                    })
                  );
                })
              );
            };
          }

          return function(source) {
            return source.lift(new SwitchMapOperator(project));
          };
        }

        var SwitchMapOperator =
          /*@__PURE__*/
          (function() {
            function SwitchMapOperator(project) {
              this.project = project;
            }

            SwitchMapOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
            };

            return SwitchMapOperator;
          })();

        var SwitchMapSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(SwitchMapSubscriber, _super);

            function SwitchMapSubscriber(destination, project) {
              var _this = _super.call(this, destination) || this;

              _this.project = project;
              _this.index = 0;
              return _this;
            }

            SwitchMapSubscriber.prototype._next = function(value) {
              var result;
              var index = this.index++;

              try {
                result = this.project(value, index);
              } catch (error) {
                this.destination.error(error);
                return;
              }

              this._innerSub(result, value, index);
            };

            SwitchMapSubscriber.prototype._innerSub = function(result, value, index) {
              var innerSubscription = this.innerSubscription;

              if (innerSubscription) {
                innerSubscription.unsubscribe();
              }

              var innerSubscriber = new _InnerSubscriber.InnerSubscriber(this, value, index);
              var destination = this.destination;
              destination.add(innerSubscriber);
              this.innerSubscription = (0, _subscribeToResult.subscribeToResult)(
                this,
                result,
                undefined,
                undefined,
                innerSubscriber
              );

              if (this.innerSubscription !== innerSubscriber) {
                destination.add(this.innerSubscription);
              }
            };

            SwitchMapSubscriber.prototype._complete = function() {
              var innerSubscription = this.innerSubscription;

              if (!innerSubscription || innerSubscription.closed) {
                _super.prototype._complete.call(this);
              }

              this.unsubscribe();
            };

            SwitchMapSubscriber.prototype._unsubscribe = function() {
              this.innerSubscription = null;
            };

            SwitchMapSubscriber.prototype.notifyComplete = function(innerSub) {
              var destination = this.destination;
              destination.remove(innerSub);
              this.innerSubscription = null;

              if (this.isStopped) {
                _super.prototype._complete.call(this);
              }
            };

            SwitchMapSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.destination.next(innerValue);
            };

            return SwitchMapSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../InnerSubscriber': '../../../node_modules/rxjs/_esm5/internal/InnerSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
        './map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../observable/from': '../../../node_modules/rxjs/_esm5/internal/observable/from.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/switchAll.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.switchAll = switchAll;

        var _switchMap = require('./switchMap');

        var _identity = require('../util/identity');

        /** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */
        function switchAll() {
          return (0, _switchMap.switchMap)(_identity.identity);
        }
      },
      {
        './switchMap': '../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js',
        '../util/identity': '../../../node_modules/rxjs/_esm5/internal/util/identity.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.switchMapTo = switchMapTo;

        var _switchMap = require('./switchMap');

        /** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
        function switchMapTo(innerObservable, resultSelector) {
          return resultSelector
            ? (0, _switchMap.switchMap)(function() {
                return innerObservable;
              }, resultSelector)
            : (0, _switchMap.switchMap)(function() {
                return innerObservable;
              });
        }
      },
      { './switchMap': '../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/takeUntil.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.takeUntil = takeUntil;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function takeUntil(notifier) {
          return function(source) {
            return source.lift(new TakeUntilOperator(notifier));
          };
        }

        var TakeUntilOperator =
          /*@__PURE__*/
          (function() {
            function TakeUntilOperator(notifier) {
              this.notifier = notifier;
            }

            TakeUntilOperator.prototype.call = function(subscriber, source) {
              var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
              var notifierSubscription = (0, _subscribeToResult.subscribeToResult)(takeUntilSubscriber, this.notifier);

              if (notifierSubscription && !takeUntilSubscriber.seenValue) {
                takeUntilSubscriber.add(notifierSubscription);
                return source.subscribe(takeUntilSubscriber);
              }

              return takeUntilSubscriber;
            };

            return TakeUntilOperator;
          })();

        var TakeUntilSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(TakeUntilSubscriber, _super);

            function TakeUntilSubscriber(destination) {
              var _this = _super.call(this, destination) || this;

              _this.seenValue = false;
              return _this;
            }

            TakeUntilSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.seenValue = true;
              this.complete();
            };

            TakeUntilSubscriber.prototype.notifyComplete = function() {};

            return TakeUntilSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/takeWhile.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.takeWhile = takeWhile;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
        function takeWhile(predicate, inclusive) {
          if (inclusive === void 0) {
            inclusive = false;
          }

          return function(source) {
            return source.lift(new TakeWhileOperator(predicate, inclusive));
          };
        }

        var TakeWhileOperator =
          /*@__PURE__*/
          (function() {
            function TakeWhileOperator(predicate, inclusive) {
              this.predicate = predicate;
              this.inclusive = inclusive;
            }

            TakeWhileOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
            };

            return TakeWhileOperator;
          })();

        var TakeWhileSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(TakeWhileSubscriber, _super);

            function TakeWhileSubscriber(destination, predicate, inclusive) {
              var _this = _super.call(this, destination) || this;

              _this.predicate = predicate;
              _this.inclusive = inclusive;
              _this.index = 0;
              return _this;
            }

            TakeWhileSubscriber.prototype._next = function(value) {
              var destination = this.destination;
              var result;

              try {
                result = this.predicate(value, this.index++);
              } catch (err) {
                destination.error(err);
                return;
              }

              this.nextOrComplete(value, result);
            };

            TakeWhileSubscriber.prototype.nextOrComplete = function(value, predicateResult) {
              var destination = this.destination;

              if (Boolean(predicateResult)) {
                destination.next(value);
              } else {
                if (this.inclusive) {
                  destination.next(value);
                }

                destination.complete();
              }
            };

            return TakeWhileSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/tap.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.tap = tap;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _noop = require('../util/noop');

        var _isFunction = require('../util/isFunction');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
        function tap(nextOrObserver, error, complete) {
          return function tapOperatorFunction(source) {
            return source.lift(new DoOperator(nextOrObserver, error, complete));
          };
        }

        var DoOperator =
          /*@__PURE__*/
          (function() {
            function DoOperator(nextOrObserver, error, complete) {
              this.nextOrObserver = nextOrObserver;
              this.error = error;
              this.complete = complete;
            }

            DoOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
            };

            return DoOperator;
          })();

        var TapSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(TapSubscriber, _super);

            function TapSubscriber(destination, observerOrNext, error, complete) {
              var _this = _super.call(this, destination) || this;

              _this._tapNext = _noop.noop;
              _this._tapError = _noop.noop;
              _this._tapComplete = _noop.noop;
              _this._tapError = error || _noop.noop;
              _this._tapComplete = complete || _noop.noop;

              if ((0, _isFunction.isFunction)(observerOrNext)) {
                _this._context = _this;
                _this._tapNext = observerOrNext;
              } else if (observerOrNext) {
                _this._context = observerOrNext;
                _this._tapNext = observerOrNext.next || _noop.noop;
                _this._tapError = observerOrNext.error || _noop.noop;
                _this._tapComplete = observerOrNext.complete || _noop.noop;
              }

              return _this;
            }

            TapSubscriber.prototype._next = function(value) {
              try {
                this._tapNext.call(this._context, value);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.next(value);
            };

            TapSubscriber.prototype._error = function(err) {
              try {
                this._tapError.call(this._context, err);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.error(err);
            };

            TapSubscriber.prototype._complete = function() {
              try {
                this._tapComplete.call(this._context);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              return this.destination.complete();
            };

            return TapSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/noop': '../../../node_modules/rxjs/_esm5/internal/util/noop.js',
        '../util/isFunction': '../../../node_modules/rxjs/_esm5/internal/util/isFunction.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/throttle.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.throttle = throttle;
        exports.defaultThrottleConfig = void 0;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        var defaultThrottleConfig = {
          leading: true,
          trailing: false,
        };
        exports.defaultThrottleConfig = defaultThrottleConfig;

        function throttle(durationSelector, config) {
          if (config === void 0) {
            config = defaultThrottleConfig;
          }

          return function(source) {
            return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));
          };
        }

        var ThrottleOperator =
          /*@__PURE__*/
          (function() {
            function ThrottleOperator(durationSelector, leading, trailing) {
              this.durationSelector = durationSelector;
              this.leading = leading;
              this.trailing = trailing;
            }

            ThrottleOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing)
              );
            };

            return ThrottleOperator;
          })();

        var ThrottleSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ThrottleSubscriber, _super);

            function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
              var _this = _super.call(this, destination) || this;

              _this.destination = destination;
              _this.durationSelector = durationSelector;
              _this._leading = _leading;
              _this._trailing = _trailing;
              _this._hasValue = false;
              return _this;
            }

            ThrottleSubscriber.prototype._next = function(value) {
              this._hasValue = true;
              this._sendValue = value;

              if (!this._throttled) {
                if (this._leading) {
                  this.send();
                } else {
                  this.throttle(value);
                }
              }
            };

            ThrottleSubscriber.prototype.send = function() {
              var _a = this,
                _hasValue = _a._hasValue,
                _sendValue = _a._sendValue;

              if (_hasValue) {
                this.destination.next(_sendValue);
                this.throttle(_sendValue);
              }

              this._hasValue = false;
              this._sendValue = null;
            };

            ThrottleSubscriber.prototype.throttle = function(value) {
              var duration = this.tryDurationSelector(value);

              if (!!duration) {
                this.add((this._throttled = (0, _subscribeToResult.subscribeToResult)(this, duration)));
              }
            };

            ThrottleSubscriber.prototype.tryDurationSelector = function(value) {
              try {
                return this.durationSelector(value);
              } catch (err) {
                this.destination.error(err);
                return null;
              }
            };

            ThrottleSubscriber.prototype.throttlingDone = function() {
              var _a = this,
                _throttled = _a._throttled,
                _trailing = _a._trailing;

              if (_throttled) {
                _throttled.unsubscribe();
              }

              this._throttled = null;

              if (_trailing) {
                this.send();
              }
            };

            ThrottleSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.throttlingDone();
            };

            ThrottleSubscriber.prototype.notifyComplete = function() {
              this.throttlingDone();
            };

            return ThrottleSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/throttleTime.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.throttleTime = throttleTime;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _async = require('../scheduler/async');

        var _throttle = require('./throttle');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
        function throttleTime(duration, scheduler, config) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          if (config === void 0) {
            config = _throttle.defaultThrottleConfig;
          }

          return function(source) {
            return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
          };
        }

        var ThrottleTimeOperator =
          /*@__PURE__*/
          (function() {
            function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
              this.duration = duration;
              this.scheduler = scheduler;
              this.leading = leading;
              this.trailing = trailing;
            }

            ThrottleTimeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)
              );
            };

            return ThrottleTimeOperator;
          })();

        var ThrottleTimeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(ThrottleTimeSubscriber, _super);

            function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
              var _this = _super.call(this, destination) || this;

              _this.duration = duration;
              _this.scheduler = scheduler;
              _this.leading = leading;
              _this.trailing = trailing;
              _this._hasTrailingValue = false;
              _this._trailingValue = null;
              return _this;
            }

            ThrottleTimeSubscriber.prototype._next = function(value) {
              if (this.throttled) {
                if (this.trailing) {
                  this._trailingValue = value;
                  this._hasTrailingValue = true;
                }
              } else {
                this.add(
                  (this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
                    subscriber: this,
                  }))
                );

                if (this.leading) {
                  this.destination.next(value);
                } else if (this.trailing) {
                  this._trailingValue = value;
                  this._hasTrailingValue = true;
                }
              }
            };

            ThrottleTimeSubscriber.prototype._complete = function() {
              if (this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this.destination.complete();
              } else {
                this.destination.complete();
              }
            };

            ThrottleTimeSubscriber.prototype.clearThrottle = function() {
              var throttled = this.throttled;

              if (throttled) {
                if (this.trailing && this._hasTrailingValue) {
                  this.destination.next(this._trailingValue);
                  this._trailingValue = null;
                  this._hasTrailingValue = false;
                }

                throttled.unsubscribe();
                this.remove(throttled);
                this.throttled = null;
              }
            };

            return ThrottleTimeSubscriber;
          })(_Subscriber.Subscriber);

        function dispatchNext(arg) {
          var subscriber = arg.subscriber;
          subscriber.clearThrottle();
        }
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        './throttle': '../../../node_modules/rxjs/_esm5/internal/operators/throttle.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/timeInterval.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.timeInterval = timeInterval;
        exports.TimeInterval = void 0;

        var _async = require('../scheduler/async');

        var _scan = require('./scan');

        var _defer = require('../observable/defer');

        var _map = require('./map');

        /** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */
        function timeInterval(scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return function(source) {
            return (0, _defer.defer)(function() {
              return source.pipe(
                (0, _scan.scan)(
                  function(_a, value) {
                    var current = _a.current;
                    return {
                      value: value,
                      current: scheduler.now(),
                      last: current,
                    };
                  },
                  {
                    current: scheduler.now(),
                    value: undefined,
                    last: undefined,
                  }
                ),
                (0, _map.map)(function(_a) {
                  var current = _a.current,
                    last = _a.last,
                    value = _a.value;
                  return new TimeInterval(value, current - last);
                })
              );
            });
          };
        }

        var TimeInterval =
          /*@__PURE__*/
          (function() {
            function TimeInterval(value, interval) {
              this.value = value;
              this.interval = interval;
            }

            return TimeInterval;
          })();

        exports.TimeInterval = TimeInterval;
      },
      {
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        './scan': '../../../node_modules/rxjs/_esm5/internal/operators/scan.js',
        '../observable/defer': '../../../node_modules/rxjs/_esm5/internal/observable/defer.js',
        './map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.timeoutWith = timeoutWith;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _async = require('../scheduler/async');

        var _isDate = require('../util/isDate');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function timeoutWith(due, withObservable, scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return function(source) {
            var absoluteTimeout = (0, _isDate.isDate)(due);
            var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
            return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
          };
        }

        var TimeoutWithOperator =
          /*@__PURE__*/
          (function() {
            function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
              this.waitFor = waitFor;
              this.absoluteTimeout = absoluteTimeout;
              this.withObservable = withObservable;
              this.scheduler = scheduler;
            }

            TimeoutWithOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new TimeoutWithSubscriber(
                  subscriber,
                  this.absoluteTimeout,
                  this.waitFor,
                  this.withObservable,
                  this.scheduler
                )
              );
            };

            return TimeoutWithOperator;
          })();

        var TimeoutWithSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(TimeoutWithSubscriber, _super);

            function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
              var _this = _super.call(this, destination) || this;

              _this.absoluteTimeout = absoluteTimeout;
              _this.waitFor = waitFor;
              _this.withObservable = withObservable;
              _this.scheduler = scheduler;
              _this.action = null;

              _this.scheduleTimeout();

              return _this;
            }

            TimeoutWithSubscriber.dispatchTimeout = function(subscriber) {
              var withObservable = subscriber.withObservable;

              subscriber._unsubscribeAndRecycle();

              subscriber.add((0, _subscribeToResult.subscribeToResult)(subscriber, withObservable));
            };

            TimeoutWithSubscriber.prototype.scheduleTimeout = function() {
              var action = this.action;

              if (action) {
                this.action = action.schedule(this, this.waitFor);
              } else {
                this.add(
                  (this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this))
                );
              }
            };

            TimeoutWithSubscriber.prototype._next = function(value) {
              if (!this.absoluteTimeout) {
                this.scheduleTimeout();
              }

              _super.prototype._next.call(this, value);
            };

            TimeoutWithSubscriber.prototype._unsubscribe = function() {
              this.action = null;
              this.scheduler = null;
              this.withObservable = null;
            };

            return TimeoutWithSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../util/isDate': '../../../node_modules/rxjs/_esm5/internal/util/isDate.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/timeout.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.timeout = timeout;

        var _async = require('../scheduler/async');

        var _TimeoutError = require('../util/TimeoutError');

        var _timeoutWith = require('./timeoutWith');

        var _throwError = require('../observable/throwError');

        /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
        function timeout(due, scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return (0, _timeoutWith.timeoutWith)(
            due,
            (0, _throwError.throwError)(new _TimeoutError.TimeoutError()),
            scheduler
          );
        }
      },
      {
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../util/TimeoutError': '../../../node_modules/rxjs/_esm5/internal/util/TimeoutError.js',
        './timeoutWith': '../../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js',
        '../observable/throwError': '../../../node_modules/rxjs/_esm5/internal/observable/throwError.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/timestamp.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.timestamp = timestamp;
        exports.Timestamp = void 0;

        var _async = require('../scheduler/async');

        var _map = require('./map');

        /** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */
        function timestamp(scheduler) {
          if (scheduler === void 0) {
            scheduler = _async.async;
          }

          return (0, _map.map)(function(value) {
            return new Timestamp(value, scheduler.now());
          });
        }

        var Timestamp =
          /*@__PURE__*/
          (function() {
            function Timestamp(value, timestamp) {
              this.value = value;
              this.timestamp = timestamp;
            }

            return Timestamp;
          })();

        exports.Timestamp = Timestamp;
      },
      {
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        './map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/toArray.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.toArray = toArray;

        var _reduce = require('./reduce');

        /** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
        function toArrayReducer(arr, item, index) {
          if (index === 0) {
            return [item];
          }

          arr.push(item);
          return arr;
        }

        function toArray() {
          return (0, _reduce.reduce)(toArrayReducer, []);
        }
      },
      { './reduce': '../../../node_modules/rxjs/_esm5/internal/operators/reduce.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/window.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.window = window;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function window(windowBoundaries) {
          return function windowOperatorFunction(source) {
            return source.lift(new WindowOperator(windowBoundaries));
          };
        }

        var WindowOperator =
          /*@__PURE__*/
          (function() {
            function WindowOperator(windowBoundaries) {
              this.windowBoundaries = windowBoundaries;
            }

            WindowOperator.prototype.call = function(subscriber, source) {
              var windowSubscriber = new WindowSubscriber(subscriber);
              var sourceSubscription = source.subscribe(windowSubscriber);

              if (!sourceSubscription.closed) {
                windowSubscriber.add(
                  (0, _subscribeToResult.subscribeToResult)(windowSubscriber, this.windowBoundaries)
                );
              }

              return sourceSubscription;
            };

            return WindowOperator;
          })();

        var WindowSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(WindowSubscriber, _super);

            function WindowSubscriber(destination) {
              var _this = _super.call(this, destination) || this;

              _this.window = new _Subject.Subject();
              destination.next(_this.window);
              return _this;
            }

            WindowSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              this.openWindow();
            };

            WindowSubscriber.prototype.notifyError = function(error, innerSub) {
              this._error(error);
            };

            WindowSubscriber.prototype.notifyComplete = function(innerSub) {
              this._complete();
            };

            WindowSubscriber.prototype._next = function(value) {
              this.window.next(value);
            };

            WindowSubscriber.prototype._error = function(err) {
              this.window.error(err);
              this.destination.error(err);
            };

            WindowSubscriber.prototype._complete = function() {
              this.window.complete();
              this.destination.complete();
            };

            WindowSubscriber.prototype._unsubscribe = function() {
              this.window = null;
            };

            WindowSubscriber.prototype.openWindow = function() {
              var prevWindow = this.window;

              if (prevWindow) {
                prevWindow.complete();
              }

              var destination = this.destination;
              var newWindow = (this.window = new _Subject.Subject());
              destination.next(newWindow);
            };

            return WindowSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/windowCount.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.windowCount = windowCount;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subscriber = require('../Subscriber');

        var _Subject = require('../Subject');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
        function windowCount(windowSize, startWindowEvery) {
          if (startWindowEvery === void 0) {
            startWindowEvery = 0;
          }

          return function windowCountOperatorFunction(source) {
            return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
          };
        }

        var WindowCountOperator =
          /*@__PURE__*/
          (function() {
            function WindowCountOperator(windowSize, startWindowEvery) {
              this.windowSize = windowSize;
              this.startWindowEvery = startWindowEvery;
            }

            WindowCountOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
            };

            return WindowCountOperator;
          })();

        var WindowCountSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(WindowCountSubscriber, _super);

            function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
              var _this = _super.call(this, destination) || this;

              _this.destination = destination;
              _this.windowSize = windowSize;
              _this.startWindowEvery = startWindowEvery;
              _this.windows = [new _Subject.Subject()];
              _this.count = 0;
              destination.next(_this.windows[0]);
              return _this;
            }

            WindowCountSubscriber.prototype._next = function(value) {
              var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
              var destination = this.destination;
              var windowSize = this.windowSize;
              var windows = this.windows;
              var len = windows.length;

              for (var i = 0; i < len && !this.closed; i++) {
                windows[i].next(value);
              }

              var c = this.count - windowSize + 1;

              if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
                windows.shift().complete();
              }

              if (++this.count % startWindowEvery === 0 && !this.closed) {
                var window_1 = new _Subject.Subject();
                windows.push(window_1);
                destination.next(window_1);
              }
            };

            WindowCountSubscriber.prototype._error = function(err) {
              var windows = this.windows;

              if (windows) {
                while (windows.length > 0 && !this.closed) {
                  windows.shift().error(err);
                }
              }

              this.destination.error(err);
            };

            WindowCountSubscriber.prototype._complete = function() {
              var windows = this.windows;

              if (windows) {
                while (windows.length > 0 && !this.closed) {
                  windows.shift().complete();
                }
              }

              this.destination.complete();
            };

            WindowCountSubscriber.prototype._unsubscribe = function() {
              this.count = 0;
              this.windows = null;
            };

            return WindowCountSubscriber;
          })(_Subscriber.Subscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/windowTime.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.windowTime = windowTime;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _async = require('../scheduler/async');

        var _Subscriber = require('../Subscriber');

        var _isNumeric = require('../util/isNumeric');

        var _isScheduler = require('../util/isScheduler');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
        function windowTime(windowTimeSpan) {
          var scheduler = _async.async;
          var windowCreationInterval = null;
          var maxWindowSize = Number.POSITIVE_INFINITY;

          if ((0, _isScheduler.isScheduler)(arguments[3])) {
            scheduler = arguments[3];
          }

          if ((0, _isScheduler.isScheduler)(arguments[2])) {
            scheduler = arguments[2];
          } else if ((0, _isNumeric.isNumeric)(arguments[2])) {
            maxWindowSize = arguments[2];
          }

          if ((0, _isScheduler.isScheduler)(arguments[1])) {
            scheduler = arguments[1];
          } else if ((0, _isNumeric.isNumeric)(arguments[1])) {
            windowCreationInterval = arguments[1];
          }

          return function windowTimeOperatorFunction(source) {
            return source.lift(
              new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)
            );
          };
        }

        var WindowTimeOperator =
          /*@__PURE__*/
          (function() {
            function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
              this.windowTimeSpan = windowTimeSpan;
              this.windowCreationInterval = windowCreationInterval;
              this.maxWindowSize = maxWindowSize;
              this.scheduler = scheduler;
            }

            WindowTimeOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(
                new WindowTimeSubscriber(
                  subscriber,
                  this.windowTimeSpan,
                  this.windowCreationInterval,
                  this.maxWindowSize,
                  this.scheduler
                )
              );
            };

            return WindowTimeOperator;
          })();

        var CountedSubject =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(CountedSubject, _super);

            function CountedSubject() {
              var _this = (_super !== null && _super.apply(this, arguments)) || this;

              _this._numberOfNextedValues = 0;
              return _this;
            }

            CountedSubject.prototype.next = function(value) {
              this._numberOfNextedValues++;

              _super.prototype.next.call(this, value);
            };

            Object.defineProperty(CountedSubject.prototype, 'numberOfNextedValues', {
              get: function() {
                return this._numberOfNextedValues;
              },
              enumerable: true,
              configurable: true,
            });
            return CountedSubject;
          })(_Subject.Subject);

        var WindowTimeSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(WindowTimeSubscriber, _super);

            function WindowTimeSubscriber(
              destination,
              windowTimeSpan,
              windowCreationInterval,
              maxWindowSize,
              scheduler
            ) {
              var _this = _super.call(this, destination) || this;

              _this.destination = destination;
              _this.windowTimeSpan = windowTimeSpan;
              _this.windowCreationInterval = windowCreationInterval;
              _this.maxWindowSize = maxWindowSize;
              _this.scheduler = scheduler;
              _this.windows = [];

              var window = _this.openWindow();

              if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                var closeState = {
                  subscriber: _this,
                  window: window,
                  context: null,
                };
                var creationState = {
                  windowTimeSpan: windowTimeSpan,
                  windowCreationInterval: windowCreationInterval,
                  subscriber: _this,
                  scheduler: scheduler,
                };

                _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));

                _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
              } else {
                var timeSpanOnlyState = {
                  subscriber: _this,
                  window: window,
                  windowTimeSpan: windowTimeSpan,
                };

                _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
              }

              return _this;
            }

            WindowTimeSubscriber.prototype._next = function(value) {
              var windows = this.windows;
              var len = windows.length;

              for (var i = 0; i < len; i++) {
                var window_1 = windows[i];

                if (!window_1.closed) {
                  window_1.next(value);

                  if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                  }
                }
              }
            };

            WindowTimeSubscriber.prototype._error = function(err) {
              var windows = this.windows;

              while (windows.length > 0) {
                windows.shift().error(err);
              }

              this.destination.error(err);
            };

            WindowTimeSubscriber.prototype._complete = function() {
              var windows = this.windows;

              while (windows.length > 0) {
                var window_2 = windows.shift();

                if (!window_2.closed) {
                  window_2.complete();
                }
              }

              this.destination.complete();
            };

            WindowTimeSubscriber.prototype.openWindow = function() {
              var window = new CountedSubject();
              this.windows.push(window);
              var destination = this.destination;
              destination.next(window);
              return window;
            };

            WindowTimeSubscriber.prototype.closeWindow = function(window) {
              window.complete();
              var windows = this.windows;
              windows.splice(windows.indexOf(window), 1);
            };

            return WindowTimeSubscriber;
          })(_Subscriber.Subscriber);

        function dispatchWindowTimeSpanOnly(state) {
          var subscriber = state.subscriber,
            windowTimeSpan = state.windowTimeSpan,
            window = state.window;

          if (window) {
            subscriber.closeWindow(window);
          }

          state.window = subscriber.openWindow();
          this.schedule(state, windowTimeSpan);
        }

        function dispatchWindowCreation(state) {
          var windowTimeSpan = state.windowTimeSpan,
            subscriber = state.subscriber,
            scheduler = state.scheduler,
            windowCreationInterval = state.windowCreationInterval;
          var window = subscriber.openWindow();
          var action = this;
          var context = {
            action: action,
            subscription: null,
          };
          var timeSpanState = {
            subscriber: subscriber,
            window: window,
            context: context,
          };
          context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
          action.add(context.subscription);
          action.schedule(state, windowCreationInterval);
        }

        function dispatchWindowClose(state) {
          var subscriber = state.subscriber,
            window = state.window,
            context = state.context;

          if (context && context.action && context.subscription) {
            context.action.remove(context.subscription);
          }

          subscriber.closeWindow(window);
        }
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../scheduler/async': '../../../node_modules/rxjs/_esm5/internal/scheduler/async.js',
        '../Subscriber': '../../../node_modules/rxjs/_esm5/internal/Subscriber.js',
        '../util/isNumeric': '../../../node_modules/rxjs/_esm5/internal/util/isNumeric.js',
        '../util/isScheduler': '../../../node_modules/rxjs/_esm5/internal/util/isScheduler.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/windowToggle.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.windowToggle = windowToggle;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _Subscription = require('../Subscription');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function windowToggle(openings, closingSelector) {
          return function(source) {
            return source.lift(new WindowToggleOperator(openings, closingSelector));
          };
        }

        var WindowToggleOperator =
          /*@__PURE__*/
          (function() {
            function WindowToggleOperator(openings, closingSelector) {
              this.openings = openings;
              this.closingSelector = closingSelector;
            }

            WindowToggleOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
            };

            return WindowToggleOperator;
          })();

        var WindowToggleSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(WindowToggleSubscriber, _super);

            function WindowToggleSubscriber(destination, openings, closingSelector) {
              var _this = _super.call(this, destination) || this;

              _this.openings = openings;
              _this.closingSelector = closingSelector;
              _this.contexts = [];

              _this.add(
                (_this.openSubscription = (0, _subscribeToResult.subscribeToResult)(_this, openings, openings))
              );

              return _this;
            }

            WindowToggleSubscriber.prototype._next = function(value) {
              var contexts = this.contexts;

              if (contexts) {
                var len = contexts.length;

                for (var i = 0; i < len; i++) {
                  contexts[i].window.next(value);
                }
              }
            };

            WindowToggleSubscriber.prototype._error = function(err) {
              var contexts = this.contexts;
              this.contexts = null;

              if (contexts) {
                var len = contexts.length;
                var index = -1;

                while (++index < len) {
                  var context_1 = contexts[index];
                  context_1.window.error(err);
                  context_1.subscription.unsubscribe();
                }
              }

              _super.prototype._error.call(this, err);
            };

            WindowToggleSubscriber.prototype._complete = function() {
              var contexts = this.contexts;
              this.contexts = null;

              if (contexts) {
                var len = contexts.length;
                var index = -1;

                while (++index < len) {
                  var context_2 = contexts[index];
                  context_2.window.complete();
                  context_2.subscription.unsubscribe();
                }
              }

              _super.prototype._complete.call(this);
            };

            WindowToggleSubscriber.prototype._unsubscribe = function() {
              var contexts = this.contexts;
              this.contexts = null;

              if (contexts) {
                var len = contexts.length;
                var index = -1;

                while (++index < len) {
                  var context_3 = contexts[index];
                  context_3.window.unsubscribe();
                  context_3.subscription.unsubscribe();
                }
              }
            };

            WindowToggleSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              if (outerValue === this.openings) {
                var closingNotifier = void 0;

                try {
                  var closingSelector = this.closingSelector;
                  closingNotifier = closingSelector(innerValue);
                } catch (e) {
                  return this.error(e);
                }

                var window_1 = new _Subject.Subject();
                var subscription = new _Subscription.Subscription();
                var context_4 = {
                  window: window_1,
                  subscription: subscription,
                };
                this.contexts.push(context_4);
                var innerSubscription = (0, _subscribeToResult.subscribeToResult)(this, closingNotifier, context_4);

                if (innerSubscription.closed) {
                  this.closeWindow(this.contexts.length - 1);
                } else {
                  innerSubscription.context = context_4;
                  subscription.add(innerSubscription);
                }

                this.destination.next(window_1);
              } else {
                this.closeWindow(this.contexts.indexOf(outerValue));
              }
            };

            WindowToggleSubscriber.prototype.notifyError = function(err) {
              this.error(err);
            };

            WindowToggleSubscriber.prototype.notifyComplete = function(inner) {
              if (inner !== this.openSubscription) {
                this.closeWindow(this.contexts.indexOf(inner.context));
              }
            };

            WindowToggleSubscriber.prototype.closeWindow = function(index) {
              if (index === -1) {
                return;
              }

              var contexts = this.contexts;
              var context = contexts[index];
              var window = context.window,
                subscription = context.subscription;
              contexts.splice(index, 1);
              window.complete();
              subscription.unsubscribe();
            };

            return WindowToggleSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../Subscription': '../../../node_modules/rxjs/_esm5/internal/Subscription.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/windowWhen.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.windowWhen = windowWhen;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _Subject = require('../Subject');

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function windowWhen(closingSelector) {
          return function windowWhenOperatorFunction(source) {
            return source.lift(new WindowOperator(closingSelector));
          };
        }

        var WindowOperator =
          /*@__PURE__*/
          (function() {
            function WindowOperator(closingSelector) {
              this.closingSelector = closingSelector;
            }

            WindowOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
            };

            return WindowOperator;
          })();

        var WindowSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(WindowSubscriber, _super);

            function WindowSubscriber(destination, closingSelector) {
              var _this = _super.call(this, destination) || this;

              _this.destination = destination;
              _this.closingSelector = closingSelector;

              _this.openWindow();

              return _this;
            }

            WindowSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
              this.openWindow(innerSub);
            };

            WindowSubscriber.prototype.notifyError = function(error, innerSub) {
              this._error(error);
            };

            WindowSubscriber.prototype.notifyComplete = function(innerSub) {
              this.openWindow(innerSub);
            };

            WindowSubscriber.prototype._next = function(value) {
              this.window.next(value);
            };

            WindowSubscriber.prototype._error = function(err) {
              this.window.error(err);
              this.destination.error(err);
              this.unsubscribeClosingNotification();
            };

            WindowSubscriber.prototype._complete = function() {
              this.window.complete();
              this.destination.complete();
              this.unsubscribeClosingNotification();
            };

            WindowSubscriber.prototype.unsubscribeClosingNotification = function() {
              if (this.closingNotification) {
                this.closingNotification.unsubscribe();
              }
            };

            WindowSubscriber.prototype.openWindow = function(innerSub) {
              if (innerSub === void 0) {
                innerSub = null;
              }

              if (innerSub) {
                this.remove(innerSub);
                innerSub.unsubscribe();
              }

              var prevWindow = this.window;

              if (prevWindow) {
                prevWindow.complete();
              }

              var window = (this.window = new _Subject.Subject());
              this.destination.next(window);
              var closingNotifier;

              try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector();
              } catch (e) {
                this.destination.error(e);
                this.window.error(e);
                return;
              }

              this.add((this.closingNotification = (0, _subscribeToResult.subscribeToResult)(this, closingNotifier)));
            };

            return WindowSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../Subject': '../../../node_modules/rxjs/_esm5/internal/Subject.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.withLatestFrom = withLatestFrom;

        var tslib_1 = _interopRequireWildcard(require('tslib'));

        var _OuterSubscriber = require('../OuterSubscriber');

        var _subscribeToResult = require('../util/subscribeToResult');

        function _getRequireWildcardCache() {
          if (typeof WeakMap !== 'function') return null;
          var cache = new WeakMap();
          _getRequireWildcardCache = function() {
            return cache;
          };
          return cache;
        }

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
            return { default: obj };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj.default = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }

        /** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
        function withLatestFrom() {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          return function(source) {
            var project;

            if (typeof args[args.length - 1] === 'function') {
              project = args.pop();
            }

            var observables = args;
            return source.lift(new WithLatestFromOperator(observables, project));
          };
        }

        var WithLatestFromOperator =
          /*@__PURE__*/
          (function() {
            function WithLatestFromOperator(observables, project) {
              this.observables = observables;
              this.project = project;
            }

            WithLatestFromOperator.prototype.call = function(subscriber, source) {
              return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
            };

            return WithLatestFromOperator;
          })();

        var WithLatestFromSubscriber =
          /*@__PURE__*/
          (function(_super) {
            tslib_1.__extends(WithLatestFromSubscriber, _super);

            function WithLatestFromSubscriber(destination, observables, project) {
              var _this = _super.call(this, destination) || this;

              _this.observables = observables;
              _this.project = project;
              _this.toRespond = [];
              var len = observables.length;
              _this.values = new Array(len);

              for (var i = 0; i < len; i++) {
                _this.toRespond.push(i);
              }

              for (var i = 0; i < len; i++) {
                var observable = observables[i];

                _this.add((0, _subscribeToResult.subscribeToResult)(_this, observable, observable, i));
              }

              return _this;
            }

            WithLatestFromSubscriber.prototype.notifyNext = function(
              outerValue,
              innerValue,
              outerIndex,
              innerIndex,
              innerSub
            ) {
              this.values[outerIndex] = innerValue;
              var toRespond = this.toRespond;

              if (toRespond.length > 0) {
                var found = toRespond.indexOf(outerIndex);

                if (found !== -1) {
                  toRespond.splice(found, 1);
                }
              }
            };

            WithLatestFromSubscriber.prototype.notifyComplete = function() {};

            WithLatestFromSubscriber.prototype._next = function(value) {
              if (this.toRespond.length === 0) {
                var args = [value].concat(this.values);

                if (this.project) {
                  this._tryProject(args);
                } else {
                  this.destination.next(args);
                }
              }
            };

            WithLatestFromSubscriber.prototype._tryProject = function(args) {
              var result;

              try {
                result = this.project.apply(this, args);
              } catch (err) {
                this.destination.error(err);
                return;
              }

              this.destination.next(result);
            };

            return WithLatestFromSubscriber;
          })(_OuterSubscriber.OuterSubscriber);
      },
      {
        tslib: '../../../node_modules/tslib/tslib.es6.js',
        '../OuterSubscriber': '../../../node_modules/rxjs/_esm5/internal/OuterSubscriber.js',
        '../util/subscribeToResult': '../../../node_modules/rxjs/_esm5/internal/util/subscribeToResult.js',
      },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/zip.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.zip = zip;

        var _zip = require('../observable/zip');

        /** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
        function zip() {
          var observables = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            observables[_i] = arguments[_i];
          }

          return function zipOperatorFunction(source) {
            return source.lift.call(_zip.zip.apply(void 0, [source].concat(observables)));
          };
        }
      },
      { '../observable/zip': '../../../node_modules/rxjs/_esm5/internal/observable/zip.js' },
    ],
    '../../../node_modules/rxjs/_esm5/internal/operators/zipAll.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.zipAll = zipAll;

        var _zip = require('../observable/zip');

        /** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
        function zipAll(project) {
          return function(source) {
            return source.lift(new _zip.ZipOperator(project));
          };
        }
      },
      { '../observable/zip': '../../../node_modules/rxjs/_esm5/internal/observable/zip.js' },
    ],
    '../../../node_modules/rxjs/_esm5/operators/index.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        Object.defineProperty(exports, 'audit', {
          enumerable: true,
          get: function() {
            return _audit.audit;
          },
        });
        Object.defineProperty(exports, 'auditTime', {
          enumerable: true,
          get: function() {
            return _auditTime.auditTime;
          },
        });
        Object.defineProperty(exports, 'buffer', {
          enumerable: true,
          get: function() {
            return _buffer.buffer;
          },
        });
        Object.defineProperty(exports, 'bufferCount', {
          enumerable: true,
          get: function() {
            return _bufferCount.bufferCount;
          },
        });
        Object.defineProperty(exports, 'bufferTime', {
          enumerable: true,
          get: function() {
            return _bufferTime.bufferTime;
          },
        });
        Object.defineProperty(exports, 'bufferToggle', {
          enumerable: true,
          get: function() {
            return _bufferToggle.bufferToggle;
          },
        });
        Object.defineProperty(exports, 'bufferWhen', {
          enumerable: true,
          get: function() {
            return _bufferWhen.bufferWhen;
          },
        });
        Object.defineProperty(exports, 'catchError', {
          enumerable: true,
          get: function() {
            return _catchError.catchError;
          },
        });
        Object.defineProperty(exports, 'combineAll', {
          enumerable: true,
          get: function() {
            return _combineAll.combineAll;
          },
        });
        Object.defineProperty(exports, 'combineLatest', {
          enumerable: true,
          get: function() {
            return _combineLatest.combineLatest;
          },
        });
        Object.defineProperty(exports, 'concat', {
          enumerable: true,
          get: function() {
            return _concat.concat;
          },
        });
        Object.defineProperty(exports, 'concatAll', {
          enumerable: true,
          get: function() {
            return _concatAll.concatAll;
          },
        });
        Object.defineProperty(exports, 'concatMap', {
          enumerable: true,
          get: function() {
            return _concatMap.concatMap;
          },
        });
        Object.defineProperty(exports, 'concatMapTo', {
          enumerable: true,
          get: function() {
            return _concatMapTo.concatMapTo;
          },
        });
        Object.defineProperty(exports, 'count', {
          enumerable: true,
          get: function() {
            return _count.count;
          },
        });
        Object.defineProperty(exports, 'debounce', {
          enumerable: true,
          get: function() {
            return _debounce.debounce;
          },
        });
        Object.defineProperty(exports, 'debounceTime', {
          enumerable: true,
          get: function() {
            return _debounceTime.debounceTime;
          },
        });
        Object.defineProperty(exports, 'defaultIfEmpty', {
          enumerable: true,
          get: function() {
            return _defaultIfEmpty.defaultIfEmpty;
          },
        });
        Object.defineProperty(exports, 'delay', {
          enumerable: true,
          get: function() {
            return _delay.delay;
          },
        });
        Object.defineProperty(exports, 'delayWhen', {
          enumerable: true,
          get: function() {
            return _delayWhen.delayWhen;
          },
        });
        Object.defineProperty(exports, 'dematerialize', {
          enumerable: true,
          get: function() {
            return _dematerialize.dematerialize;
          },
        });
        Object.defineProperty(exports, 'distinct', {
          enumerable: true,
          get: function() {
            return _distinct.distinct;
          },
        });
        Object.defineProperty(exports, 'distinctUntilChanged', {
          enumerable: true,
          get: function() {
            return _distinctUntilChanged.distinctUntilChanged;
          },
        });
        Object.defineProperty(exports, 'distinctUntilKeyChanged', {
          enumerable: true,
          get: function() {
            return _distinctUntilKeyChanged.distinctUntilKeyChanged;
          },
        });
        Object.defineProperty(exports, 'elementAt', {
          enumerable: true,
          get: function() {
            return _elementAt.elementAt;
          },
        });
        Object.defineProperty(exports, 'endWith', {
          enumerable: true,
          get: function() {
            return _endWith.endWith;
          },
        });
        Object.defineProperty(exports, 'every', {
          enumerable: true,
          get: function() {
            return _every.every;
          },
        });
        Object.defineProperty(exports, 'exhaust', {
          enumerable: true,
          get: function() {
            return _exhaust.exhaust;
          },
        });
        Object.defineProperty(exports, 'exhaustMap', {
          enumerable: true,
          get: function() {
            return _exhaustMap.exhaustMap;
          },
        });
        Object.defineProperty(exports, 'expand', {
          enumerable: true,
          get: function() {
            return _expand.expand;
          },
        });
        Object.defineProperty(exports, 'filter', {
          enumerable: true,
          get: function() {
            return _filter.filter;
          },
        });
        Object.defineProperty(exports, 'finalize', {
          enumerable: true,
          get: function() {
            return _finalize.finalize;
          },
        });
        Object.defineProperty(exports, 'find', {
          enumerable: true,
          get: function() {
            return _find.find;
          },
        });
        Object.defineProperty(exports, 'findIndex', {
          enumerable: true,
          get: function() {
            return _findIndex.findIndex;
          },
        });
        Object.defineProperty(exports, 'first', {
          enumerable: true,
          get: function() {
            return _first.first;
          },
        });
        Object.defineProperty(exports, 'groupBy', {
          enumerable: true,
          get: function() {
            return _groupBy.groupBy;
          },
        });
        Object.defineProperty(exports, 'ignoreElements', {
          enumerable: true,
          get: function() {
            return _ignoreElements.ignoreElements;
          },
        });
        Object.defineProperty(exports, 'isEmpty', {
          enumerable: true,
          get: function() {
            return _isEmpty.isEmpty;
          },
        });
        Object.defineProperty(exports, 'last', {
          enumerable: true,
          get: function() {
            return _last.last;
          },
        });
        Object.defineProperty(exports, 'map', {
          enumerable: true,
          get: function() {
            return _map.map;
          },
        });
        Object.defineProperty(exports, 'mapTo', {
          enumerable: true,
          get: function() {
            return _mapTo.mapTo;
          },
        });
        Object.defineProperty(exports, 'materialize', {
          enumerable: true,
          get: function() {
            return _materialize.materialize;
          },
        });
        Object.defineProperty(exports, 'max', {
          enumerable: true,
          get: function() {
            return _max.max;
          },
        });
        Object.defineProperty(exports, 'merge', {
          enumerable: true,
          get: function() {
            return _merge.merge;
          },
        });
        Object.defineProperty(exports, 'mergeAll', {
          enumerable: true,
          get: function() {
            return _mergeAll.mergeAll;
          },
        });
        Object.defineProperty(exports, 'mergeMap', {
          enumerable: true,
          get: function() {
            return _mergeMap.mergeMap;
          },
        });
        Object.defineProperty(exports, 'flatMap', {
          enumerable: true,
          get: function() {
            return _mergeMap.mergeMap;
          },
        });
        Object.defineProperty(exports, 'mergeMapTo', {
          enumerable: true,
          get: function() {
            return _mergeMapTo.mergeMapTo;
          },
        });
        Object.defineProperty(exports, 'mergeScan', {
          enumerable: true,
          get: function() {
            return _mergeScan.mergeScan;
          },
        });
        Object.defineProperty(exports, 'min', {
          enumerable: true,
          get: function() {
            return _min.min;
          },
        });
        Object.defineProperty(exports, 'multicast', {
          enumerable: true,
          get: function() {
            return _multicast.multicast;
          },
        });
        Object.defineProperty(exports, 'observeOn', {
          enumerable: true,
          get: function() {
            return _observeOn.observeOn;
          },
        });
        Object.defineProperty(exports, 'onErrorResumeNext', {
          enumerable: true,
          get: function() {
            return _onErrorResumeNext.onErrorResumeNext;
          },
        });
        Object.defineProperty(exports, 'pairwise', {
          enumerable: true,
          get: function() {
            return _pairwise.pairwise;
          },
        });
        Object.defineProperty(exports, 'partition', {
          enumerable: true,
          get: function() {
            return _partition.partition;
          },
        });
        Object.defineProperty(exports, 'pluck', {
          enumerable: true,
          get: function() {
            return _pluck.pluck;
          },
        });
        Object.defineProperty(exports, 'publish', {
          enumerable: true,
          get: function() {
            return _publish.publish;
          },
        });
        Object.defineProperty(exports, 'publishBehavior', {
          enumerable: true,
          get: function() {
            return _publishBehavior.publishBehavior;
          },
        });
        Object.defineProperty(exports, 'publishLast', {
          enumerable: true,
          get: function() {
            return _publishLast.publishLast;
          },
        });
        Object.defineProperty(exports, 'publishReplay', {
          enumerable: true,
          get: function() {
            return _publishReplay.publishReplay;
          },
        });
        Object.defineProperty(exports, 'race', {
          enumerable: true,
          get: function() {
            return _race.race;
          },
        });
        Object.defineProperty(exports, 'reduce', {
          enumerable: true,
          get: function() {
            return _reduce.reduce;
          },
        });
        Object.defineProperty(exports, 'repeat', {
          enumerable: true,
          get: function() {
            return _repeat.repeat;
          },
        });
        Object.defineProperty(exports, 'repeatWhen', {
          enumerable: true,
          get: function() {
            return _repeatWhen.repeatWhen;
          },
        });
        Object.defineProperty(exports, 'retry', {
          enumerable: true,
          get: function() {
            return _retry.retry;
          },
        });
        Object.defineProperty(exports, 'retryWhen', {
          enumerable: true,
          get: function() {
            return _retryWhen.retryWhen;
          },
        });
        Object.defineProperty(exports, 'refCount', {
          enumerable: true,
          get: function() {
            return _refCount.refCount;
          },
        });
        Object.defineProperty(exports, 'sample', {
          enumerable: true,
          get: function() {
            return _sample.sample;
          },
        });
        Object.defineProperty(exports, 'sampleTime', {
          enumerable: true,
          get: function() {
            return _sampleTime.sampleTime;
          },
        });
        Object.defineProperty(exports, 'scan', {
          enumerable: true,
          get: function() {
            return _scan.scan;
          },
        });
        Object.defineProperty(exports, 'sequenceEqual', {
          enumerable: true,
          get: function() {
            return _sequenceEqual.sequenceEqual;
          },
        });
        Object.defineProperty(exports, 'share', {
          enumerable: true,
          get: function() {
            return _share.share;
          },
        });
        Object.defineProperty(exports, 'shareReplay', {
          enumerable: true,
          get: function() {
            return _shareReplay.shareReplay;
          },
        });
        Object.defineProperty(exports, 'single', {
          enumerable: true,
          get: function() {
            return _single.single;
          },
        });
        Object.defineProperty(exports, 'skip', {
          enumerable: true,
          get: function() {
            return _skip.skip;
          },
        });
        Object.defineProperty(exports, 'skipLast', {
          enumerable: true,
          get: function() {
            return _skipLast.skipLast;
          },
        });
        Object.defineProperty(exports, 'skipUntil', {
          enumerable: true,
          get: function() {
            return _skipUntil.skipUntil;
          },
        });
        Object.defineProperty(exports, 'skipWhile', {
          enumerable: true,
          get: function() {
            return _skipWhile.skipWhile;
          },
        });
        Object.defineProperty(exports, 'startWith', {
          enumerable: true,
          get: function() {
            return _startWith.startWith;
          },
        });
        Object.defineProperty(exports, 'subscribeOn', {
          enumerable: true,
          get: function() {
            return _subscribeOn.subscribeOn;
          },
        });
        Object.defineProperty(exports, 'switchAll', {
          enumerable: true,
          get: function() {
            return _switchAll.switchAll;
          },
        });
        Object.defineProperty(exports, 'switchMap', {
          enumerable: true,
          get: function() {
            return _switchMap.switchMap;
          },
        });
        Object.defineProperty(exports, 'switchMapTo', {
          enumerable: true,
          get: function() {
            return _switchMapTo.switchMapTo;
          },
        });
        Object.defineProperty(exports, 'take', {
          enumerable: true,
          get: function() {
            return _take.take;
          },
        });
        Object.defineProperty(exports, 'takeLast', {
          enumerable: true,
          get: function() {
            return _takeLast.takeLast;
          },
        });
        Object.defineProperty(exports, 'takeUntil', {
          enumerable: true,
          get: function() {
            return _takeUntil.takeUntil;
          },
        });
        Object.defineProperty(exports, 'takeWhile', {
          enumerable: true,
          get: function() {
            return _takeWhile.takeWhile;
          },
        });
        Object.defineProperty(exports, 'tap', {
          enumerable: true,
          get: function() {
            return _tap.tap;
          },
        });
        Object.defineProperty(exports, 'throttle', {
          enumerable: true,
          get: function() {
            return _throttle.throttle;
          },
        });
        Object.defineProperty(exports, 'throttleTime', {
          enumerable: true,
          get: function() {
            return _throttleTime.throttleTime;
          },
        });
        Object.defineProperty(exports, 'throwIfEmpty', {
          enumerable: true,
          get: function() {
            return _throwIfEmpty.throwIfEmpty;
          },
        });
        Object.defineProperty(exports, 'timeInterval', {
          enumerable: true,
          get: function() {
            return _timeInterval.timeInterval;
          },
        });
        Object.defineProperty(exports, 'timeout', {
          enumerable: true,
          get: function() {
            return _timeout.timeout;
          },
        });
        Object.defineProperty(exports, 'timeoutWith', {
          enumerable: true,
          get: function() {
            return _timeoutWith.timeoutWith;
          },
        });
        Object.defineProperty(exports, 'timestamp', {
          enumerable: true,
          get: function() {
            return _timestamp.timestamp;
          },
        });
        Object.defineProperty(exports, 'toArray', {
          enumerable: true,
          get: function() {
            return _toArray.toArray;
          },
        });
        Object.defineProperty(exports, 'window', {
          enumerable: true,
          get: function() {
            return _window.window;
          },
        });
        Object.defineProperty(exports, 'windowCount', {
          enumerable: true,
          get: function() {
            return _windowCount.windowCount;
          },
        });
        Object.defineProperty(exports, 'windowTime', {
          enumerable: true,
          get: function() {
            return _windowTime.windowTime;
          },
        });
        Object.defineProperty(exports, 'windowToggle', {
          enumerable: true,
          get: function() {
            return _windowToggle.windowToggle;
          },
        });
        Object.defineProperty(exports, 'windowWhen', {
          enumerable: true,
          get: function() {
            return _windowWhen.windowWhen;
          },
        });
        Object.defineProperty(exports, 'withLatestFrom', {
          enumerable: true,
          get: function() {
            return _withLatestFrom.withLatestFrom;
          },
        });
        Object.defineProperty(exports, 'zip', {
          enumerable: true,
          get: function() {
            return _zip.zip;
          },
        });
        Object.defineProperty(exports, 'zipAll', {
          enumerable: true,
          get: function() {
            return _zipAll.zipAll;
          },
        });

        var _audit = require('../internal/operators/audit');

        var _auditTime = require('../internal/operators/auditTime');

        var _buffer = require('../internal/operators/buffer');

        var _bufferCount = require('../internal/operators/bufferCount');

        var _bufferTime = require('../internal/operators/bufferTime');

        var _bufferToggle = require('../internal/operators/bufferToggle');

        var _bufferWhen = require('../internal/operators/bufferWhen');

        var _catchError = require('../internal/operators/catchError');

        var _combineAll = require('../internal/operators/combineAll');

        var _combineLatest = require('../internal/operators/combineLatest');

        var _concat = require('../internal/operators/concat');

        var _concatAll = require('../internal/operators/concatAll');

        var _concatMap = require('../internal/operators/concatMap');

        var _concatMapTo = require('../internal/operators/concatMapTo');

        var _count = require('../internal/operators/count');

        var _debounce = require('../internal/operators/debounce');

        var _debounceTime = require('../internal/operators/debounceTime');

        var _defaultIfEmpty = require('../internal/operators/defaultIfEmpty');

        var _delay = require('../internal/operators/delay');

        var _delayWhen = require('../internal/operators/delayWhen');

        var _dematerialize = require('../internal/operators/dematerialize');

        var _distinct = require('../internal/operators/distinct');

        var _distinctUntilChanged = require('../internal/operators/distinctUntilChanged');

        var _distinctUntilKeyChanged = require('../internal/operators/distinctUntilKeyChanged');

        var _elementAt = require('../internal/operators/elementAt');

        var _endWith = require('../internal/operators/endWith');

        var _every = require('../internal/operators/every');

        var _exhaust = require('../internal/operators/exhaust');

        var _exhaustMap = require('../internal/operators/exhaustMap');

        var _expand = require('../internal/operators/expand');

        var _filter = require('../internal/operators/filter');

        var _finalize = require('../internal/operators/finalize');

        var _find = require('../internal/operators/find');

        var _findIndex = require('../internal/operators/findIndex');

        var _first = require('../internal/operators/first');

        var _groupBy = require('../internal/operators/groupBy');

        var _ignoreElements = require('../internal/operators/ignoreElements');

        var _isEmpty = require('../internal/operators/isEmpty');

        var _last = require('../internal/operators/last');

        var _map = require('../internal/operators/map');

        var _mapTo = require('../internal/operators/mapTo');

        var _materialize = require('../internal/operators/materialize');

        var _max = require('../internal/operators/max');

        var _merge = require('../internal/operators/merge');

        var _mergeAll = require('../internal/operators/mergeAll');

        var _mergeMap = require('../internal/operators/mergeMap');

        var _mergeMapTo = require('../internal/operators/mergeMapTo');

        var _mergeScan = require('../internal/operators/mergeScan');

        var _min = require('../internal/operators/min');

        var _multicast = require('../internal/operators/multicast');

        var _observeOn = require('../internal/operators/observeOn');

        var _onErrorResumeNext = require('../internal/operators/onErrorResumeNext');

        var _pairwise = require('../internal/operators/pairwise');

        var _partition = require('../internal/operators/partition');

        var _pluck = require('../internal/operators/pluck');

        var _publish = require('../internal/operators/publish');

        var _publishBehavior = require('../internal/operators/publishBehavior');

        var _publishLast = require('../internal/operators/publishLast');

        var _publishReplay = require('../internal/operators/publishReplay');

        var _race = require('../internal/operators/race');

        var _reduce = require('../internal/operators/reduce');

        var _repeat = require('../internal/operators/repeat');

        var _repeatWhen = require('../internal/operators/repeatWhen');

        var _retry = require('../internal/operators/retry');

        var _retryWhen = require('../internal/operators/retryWhen');

        var _refCount = require('../internal/operators/refCount');

        var _sample = require('../internal/operators/sample');

        var _sampleTime = require('../internal/operators/sampleTime');

        var _scan = require('../internal/operators/scan');

        var _sequenceEqual = require('../internal/operators/sequenceEqual');

        var _share = require('../internal/operators/share');

        var _shareReplay = require('../internal/operators/shareReplay');

        var _single = require('../internal/operators/single');

        var _skip = require('../internal/operators/skip');

        var _skipLast = require('../internal/operators/skipLast');

        var _skipUntil = require('../internal/operators/skipUntil');

        var _skipWhile = require('../internal/operators/skipWhile');

        var _startWith = require('../internal/operators/startWith');

        var _subscribeOn = require('../internal/operators/subscribeOn');

        var _switchAll = require('../internal/operators/switchAll');

        var _switchMap = require('../internal/operators/switchMap');

        var _switchMapTo = require('../internal/operators/switchMapTo');

        var _take = require('../internal/operators/take');

        var _takeLast = require('../internal/operators/takeLast');

        var _takeUntil = require('../internal/operators/takeUntil');

        var _takeWhile = require('../internal/operators/takeWhile');

        var _tap = require('../internal/operators/tap');

        var _throttle = require('../internal/operators/throttle');

        var _throttleTime = require('../internal/operators/throttleTime');

        var _throwIfEmpty = require('../internal/operators/throwIfEmpty');

        var _timeInterval = require('../internal/operators/timeInterval');

        var _timeout = require('../internal/operators/timeout');

        var _timeoutWith = require('../internal/operators/timeoutWith');

        var _timestamp = require('../internal/operators/timestamp');

        var _toArray = require('../internal/operators/toArray');

        var _window = require('../internal/operators/window');

        var _windowCount = require('../internal/operators/windowCount');

        var _windowTime = require('../internal/operators/windowTime');

        var _windowToggle = require('../internal/operators/windowToggle');

        var _windowWhen = require('../internal/operators/windowWhen');

        var _withLatestFrom = require('../internal/operators/withLatestFrom');

        var _zip = require('../internal/operators/zip');

        var _zipAll = require('../internal/operators/zipAll');
      },
      {
        '../internal/operators/audit': '../../../node_modules/rxjs/_esm5/internal/operators/audit.js',
        '../internal/operators/auditTime': '../../../node_modules/rxjs/_esm5/internal/operators/auditTime.js',
        '../internal/operators/buffer': '../../../node_modules/rxjs/_esm5/internal/operators/buffer.js',
        '../internal/operators/bufferCount': '../../../node_modules/rxjs/_esm5/internal/operators/bufferCount.js',
        '../internal/operators/bufferTime': '../../../node_modules/rxjs/_esm5/internal/operators/bufferTime.js',
        '../internal/operators/bufferToggle': '../../../node_modules/rxjs/_esm5/internal/operators/bufferToggle.js',
        '../internal/operators/bufferWhen': '../../../node_modules/rxjs/_esm5/internal/operators/bufferWhen.js',
        '../internal/operators/catchError': '../../../node_modules/rxjs/_esm5/internal/operators/catchError.js',
        '../internal/operators/combineAll': '../../../node_modules/rxjs/_esm5/internal/operators/combineAll.js',
        '../internal/operators/combineLatest': '../../../node_modules/rxjs/_esm5/internal/operators/combineLatest.js',
        '../internal/operators/concat': '../../../node_modules/rxjs/_esm5/internal/operators/concat.js',
        '../internal/operators/concatAll': '../../../node_modules/rxjs/_esm5/internal/operators/concatAll.js',
        '../internal/operators/concatMap': '../../../node_modules/rxjs/_esm5/internal/operators/concatMap.js',
        '../internal/operators/concatMapTo': '../../../node_modules/rxjs/_esm5/internal/operators/concatMapTo.js',
        '../internal/operators/count': '../../../node_modules/rxjs/_esm5/internal/operators/count.js',
        '../internal/operators/debounce': '../../../node_modules/rxjs/_esm5/internal/operators/debounce.js',
        '../internal/operators/debounceTime': '../../../node_modules/rxjs/_esm5/internal/operators/debounceTime.js',
        '../internal/operators/defaultIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js',
        '../internal/operators/delay': '../../../node_modules/rxjs/_esm5/internal/operators/delay.js',
        '../internal/operators/delayWhen': '../../../node_modules/rxjs/_esm5/internal/operators/delayWhen.js',
        '../internal/operators/dematerialize': '../../../node_modules/rxjs/_esm5/internal/operators/dematerialize.js',
        '../internal/operators/distinct': '../../../node_modules/rxjs/_esm5/internal/operators/distinct.js',
        '../internal/operators/distinctUntilChanged':
          '../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js',
        '../internal/operators/distinctUntilKeyChanged':
          '../../../node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js',
        '../internal/operators/elementAt': '../../../node_modules/rxjs/_esm5/internal/operators/elementAt.js',
        '../internal/operators/endWith': '../../../node_modules/rxjs/_esm5/internal/operators/endWith.js',
        '../internal/operators/every': '../../../node_modules/rxjs/_esm5/internal/operators/every.js',
        '../internal/operators/exhaust': '../../../node_modules/rxjs/_esm5/internal/operators/exhaust.js',
        '../internal/operators/exhaustMap': '../../../node_modules/rxjs/_esm5/internal/operators/exhaustMap.js',
        '../internal/operators/expand': '../../../node_modules/rxjs/_esm5/internal/operators/expand.js',
        '../internal/operators/filter': '../../../node_modules/rxjs/_esm5/internal/operators/filter.js',
        '../internal/operators/finalize': '../../../node_modules/rxjs/_esm5/internal/operators/finalize.js',
        '../internal/operators/find': '../../../node_modules/rxjs/_esm5/internal/operators/find.js',
        '../internal/operators/findIndex': '../../../node_modules/rxjs/_esm5/internal/operators/findIndex.js',
        '../internal/operators/first': '../../../node_modules/rxjs/_esm5/internal/operators/first.js',
        '../internal/operators/groupBy': '../../../node_modules/rxjs/_esm5/internal/operators/groupBy.js',
        '../internal/operators/ignoreElements': '../../../node_modules/rxjs/_esm5/internal/operators/ignoreElements.js',
        '../internal/operators/isEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/isEmpty.js',
        '../internal/operators/last': '../../../node_modules/rxjs/_esm5/internal/operators/last.js',
        '../internal/operators/map': '../../../node_modules/rxjs/_esm5/internal/operators/map.js',
        '../internal/operators/mapTo': '../../../node_modules/rxjs/_esm5/internal/operators/mapTo.js',
        '../internal/operators/materialize': '../../../node_modules/rxjs/_esm5/internal/operators/materialize.js',
        '../internal/operators/max': '../../../node_modules/rxjs/_esm5/internal/operators/max.js',
        '../internal/operators/merge': '../../../node_modules/rxjs/_esm5/internal/operators/merge.js',
        '../internal/operators/mergeAll': '../../../node_modules/rxjs/_esm5/internal/operators/mergeAll.js',
        '../internal/operators/mergeMap': '../../../node_modules/rxjs/_esm5/internal/operators/mergeMap.js',
        '../internal/operators/mergeMapTo': '../../../node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js',
        '../internal/operators/mergeScan': '../../../node_modules/rxjs/_esm5/internal/operators/mergeScan.js',
        '../internal/operators/min': '../../../node_modules/rxjs/_esm5/internal/operators/min.js',
        '../internal/operators/multicast': '../../../node_modules/rxjs/_esm5/internal/operators/multicast.js',
        '../internal/operators/observeOn': '../../../node_modules/rxjs/_esm5/internal/operators/observeOn.js',
        '../internal/operators/onErrorResumeNext':
          '../../../node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js',
        '../internal/operators/pairwise': '../../../node_modules/rxjs/_esm5/internal/operators/pairwise.js',
        '../internal/operators/partition': '../../../node_modules/rxjs/_esm5/internal/operators/partition.js',
        '../internal/operators/pluck': '../../../node_modules/rxjs/_esm5/internal/operators/pluck.js',
        '../internal/operators/publish': '../../../node_modules/rxjs/_esm5/internal/operators/publish.js',
        '../internal/operators/publishBehavior':
          '../../../node_modules/rxjs/_esm5/internal/operators/publishBehavior.js',
        '../internal/operators/publishLast': '../../../node_modules/rxjs/_esm5/internal/operators/publishLast.js',
        '../internal/operators/publishReplay': '../../../node_modules/rxjs/_esm5/internal/operators/publishReplay.js',
        '../internal/operators/race': '../../../node_modules/rxjs/_esm5/internal/operators/race.js',
        '../internal/operators/reduce': '../../../node_modules/rxjs/_esm5/internal/operators/reduce.js',
        '../internal/operators/repeat': '../../../node_modules/rxjs/_esm5/internal/operators/repeat.js',
        '../internal/operators/repeatWhen': '../../../node_modules/rxjs/_esm5/internal/operators/repeatWhen.js',
        '../internal/operators/retry': '../../../node_modules/rxjs/_esm5/internal/operators/retry.js',
        '../internal/operators/retryWhen': '../../../node_modules/rxjs/_esm5/internal/operators/retryWhen.js',
        '../internal/operators/refCount': '../../../node_modules/rxjs/_esm5/internal/operators/refCount.js',
        '../internal/operators/sample': '../../../node_modules/rxjs/_esm5/internal/operators/sample.js',
        '../internal/operators/sampleTime': '../../../node_modules/rxjs/_esm5/internal/operators/sampleTime.js',
        '../internal/operators/scan': '../../../node_modules/rxjs/_esm5/internal/operators/scan.js',
        '../internal/operators/sequenceEqual': '../../../node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js',
        '../internal/operators/share': '../../../node_modules/rxjs/_esm5/internal/operators/share.js',
        '../internal/operators/shareReplay': '../../../node_modules/rxjs/_esm5/internal/operators/shareReplay.js',
        '../internal/operators/single': '../../../node_modules/rxjs/_esm5/internal/operators/single.js',
        '../internal/operators/skip': '../../../node_modules/rxjs/_esm5/internal/operators/skip.js',
        '../internal/operators/skipLast': '../../../node_modules/rxjs/_esm5/internal/operators/skipLast.js',
        '../internal/operators/skipUntil': '../../../node_modules/rxjs/_esm5/internal/operators/skipUntil.js',
        '../internal/operators/skipWhile': '../../../node_modules/rxjs/_esm5/internal/operators/skipWhile.js',
        '../internal/operators/startWith': '../../../node_modules/rxjs/_esm5/internal/operators/startWith.js',
        '../internal/operators/subscribeOn': '../../../node_modules/rxjs/_esm5/internal/operators/subscribeOn.js',
        '../internal/operators/switchAll': '../../../node_modules/rxjs/_esm5/internal/operators/switchAll.js',
        '../internal/operators/switchMap': '../../../node_modules/rxjs/_esm5/internal/operators/switchMap.js',
        '../internal/operators/switchMapTo': '../../../node_modules/rxjs/_esm5/internal/operators/switchMapTo.js',
        '../internal/operators/take': '../../../node_modules/rxjs/_esm5/internal/operators/take.js',
        '../internal/operators/takeLast': '../../../node_modules/rxjs/_esm5/internal/operators/takeLast.js',
        '../internal/operators/takeUntil': '../../../node_modules/rxjs/_esm5/internal/operators/takeUntil.js',
        '../internal/operators/takeWhile': '../../../node_modules/rxjs/_esm5/internal/operators/takeWhile.js',
        '../internal/operators/tap': '../../../node_modules/rxjs/_esm5/internal/operators/tap.js',
        '../internal/operators/throttle': '../../../node_modules/rxjs/_esm5/internal/operators/throttle.js',
        '../internal/operators/throttleTime': '../../../node_modules/rxjs/_esm5/internal/operators/throttleTime.js',
        '../internal/operators/throwIfEmpty': '../../../node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js',
        '../internal/operators/timeInterval': '../../../node_modules/rxjs/_esm5/internal/operators/timeInterval.js',
        '../internal/operators/timeout': '../../../node_modules/rxjs/_esm5/internal/operators/timeout.js',
        '../internal/operators/timeoutWith': '../../../node_modules/rxjs/_esm5/internal/operators/timeoutWith.js',
        '../internal/operators/timestamp': '../../../node_modules/rxjs/_esm5/internal/operators/timestamp.js',
        '../internal/operators/toArray': '../../../node_modules/rxjs/_esm5/internal/operators/toArray.js',
        '../internal/operators/window': '../../../node_modules/rxjs/_esm5/internal/operators/window.js',
        '../internal/operators/windowCount': '../../../node_modules/rxjs/_esm5/internal/operators/windowCount.js',
        '../internal/operators/windowTime': '../../../node_modules/rxjs/_esm5/internal/operators/windowTime.js',
        '../internal/operators/windowToggle': '../../../node_modules/rxjs/_esm5/internal/operators/windowToggle.js',
        '../internal/operators/windowWhen': '../../../node_modules/rxjs/_esm5/internal/operators/windowWhen.js',
        '../internal/operators/withLatestFrom': '../../../node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js',
        '../internal/operators/zip': '../../../node_modules/rxjs/_esm5/internal/operators/zip.js',
        '../internal/operators/zipAll': '../../../node_modules/rxjs/_esm5/internal/operators/zipAll.js',
      },
    ],
    'index.js': [
      function(require, module, exports) {
        'use strict';

        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.MarketServiceDefinition = void 0;

        var _browser = require('@scalecube/browser');

        var _rxjs = require('rxjs');

        var _operators = require('rxjs/operators');

        const remoteServiceDefinition = {
          serviceName: 'remoteService',
          methods: {
            assets$: {
              asyncModel: _browser.ASYNC_MODEL_TYPES.REQUEST_STREAM,
            },
          },
        };
        const MarketServiceDefinition = {
          serviceName: 'MarketService',
          methods: {
            assets$: {
              asyncModel: _browser.ASYNC_MODEL_TYPES.REQUEST_RESPONSE,
            },
            asset$: {
              asyncModel: _browser.ASYNC_MODEL_TYPES.REQUEST_STREAM,
            },
          },
        };
        exports.MarketServiceDefinition = MarketServiceDefinition;
        (0, _browser.createMicroservice)({
          seedAddress: 'seed',
          address: 'marketService',
          debug: true,
          services: [
            {
              definition: MarketServiceDefinition,
              reference: ({ createProxy }) => {
                const assets = {};
                const remoteService = createProxy({
                  serviceDefinition: remoteServiceDefinition,
                });
                remoteService.assets$().subscribe((i) => {
                  assets[i.id] = i;
                });
                const ticks = new _rxjs.Subject();
                (0, _rxjs.timer)(0, 13).subscribe(() => ticks.next());
                const ready = new _rxjs.ReplaySubject(1);
                (0, _rxjs.timer)(0, 13)
                  .pipe(
                    (0, _operators.filter)(() => assets[399] !== undefined),
                    (0, _operators.delay)(1000),
                    (0, _operators.take)(1)
                  )
                  .subscribe(() => ready.next());
                return {
                  assets$: () => {
                    return ready
                      .pipe(
                        (0, _operators.switchMap)(() =>
                          (0, _rxjs.of)(
                            Object.keys(assets).map((k) => ({
                              id: assets[k].id,
                              name: assets[k].name,
                              type: assets[k].type,
                            }))
                          )
                        ),
                        (0, _operators.take)(1)
                      )
                      .toPromise();
                  },
                  asset$: (id) => {
                    let lastTick;
                    return ticks.pipe(
                      (0, _operators.map)(() => {
                        return assets[id];
                      }),
                      (0, _operators.filter)((i) => i.lastUpdate != lastTick),
                      (0, _operators.tap)((i) => (lastTick = i.lastUpdate))
                    );
                  },
                };
              },
            },
          ],
        });
      },
      {
        '@scalecube/browser': '../../../node_modules/@scalecube/browser/es/index.js',
        rxjs: '../../../node_modules/rxjs/_esm5/index.js',
        'rxjs/operators': '../../../node_modules/rxjs/_esm5/operators/index.js',
      },
    ],
    '../../../../../../.config/yarn/global/node_modules/parcel-bundler/src/builtins/hmr-runtime.js': [
      function(require, module, exports) {
        var global = arguments[3];
        var OVERLAY_ID = '__parcel__error__overlay__';
        var OldModule = module.bundle.Module;

        function Module(moduleName) {
          OldModule.call(this, moduleName);
          this.hot = {
            data: module.bundle.hotData,
            _acceptCallbacks: [],
            _disposeCallbacks: [],
            accept: function(fn) {
              this._acceptCallbacks.push(fn || function() {});
            },
            dispose: function(fn) {
              this._disposeCallbacks.push(fn);
            },
          };
          module.bundle.hotData = null;
        }

        module.bundle.Module = Module;
        var checkedAssets, assetsToAccept;
        var parent = module.bundle.parent;

        if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
          var hostname = '' || location.hostname;
          var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
          var ws = new WebSocket(protocol + '://' + hostname + ':' + '39203' + '/');

          ws.onmessage = function(event) {
            checkedAssets = {};
            assetsToAccept = [];
            var data = JSON.parse(event.data);

            if (data.type === 'update') {
              var handled = false;
              data.assets.forEach(function(asset) {
                if (!asset.isNew) {
                  var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

                  if (didAccept) {
                    handled = true;
                  }
                }
              }); // Enable HMR for CSS by default.

              handled =
                handled ||
                data.assets.every(function(asset) {
                  return asset.type === 'css' && asset.generated.js;
                });

              if (handled) {
                console.clear();
                data.assets.forEach(function(asset) {
                  hmrApply(global.parcelRequire, asset);
                });
                assetsToAccept.forEach(function(v) {
                  hmrAcceptRun(v[0], v[1]);
                });
              } else if (location.reload) {
                // `location` global exists in a web worker context but lacks `.reload()` function.
                location.reload();
              }
            }

            if (data.type === 'reload') {
              ws.close();

              ws.onclose = function() {
                location.reload();
              };
            }

            if (data.type === 'error-resolved') {
              console.log('[parcel] ✨ Error resolved');
              removeErrorOverlay();
            }

            if (data.type === 'error') {
              console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
              removeErrorOverlay();
              var overlay = createErrorOverlay(data);
              document.body.appendChild(overlay);
            }
          };
        }

        function removeErrorOverlay() {
          var overlay = document.getElementById(OVERLAY_ID);

          if (overlay) {
            overlay.remove();
          }
        }

        function createErrorOverlay(data) {
          var overlay = document.createElement('div');
          overlay.id = OVERLAY_ID; // html encode message and stack trace

          var message = document.createElement('div');
          var stackTrace = document.createElement('pre');
          message.innerText = data.error.message;
          stackTrace.innerText = data.error.stack;
          overlay.innerHTML =
            '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' +
            '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' +
            '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' +
            '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' +
            message.innerHTML +
            '</div>' +
            '<pre>' +
            stackTrace.innerHTML +
            '</pre>' +
            '</div>';
          return overlay;
        }

        function getParents(bundle, id) {
          var modules = bundle.modules;

          if (!modules) {
            return [];
          }

          var parents = [];
          var k, d, dep;

          for (k in modules) {
            for (d in modules[k][1]) {
              dep = modules[k][1][d];

              if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {
                parents.push(k);
              }
            }
          }

          if (bundle.parent) {
            parents = parents.concat(getParents(bundle.parent, id));
          }

          return parents;
        }

        function hmrApply(bundle, asset) {
          var modules = bundle.modules;

          if (!modules) {
            return;
          }

          if (modules[asset.id] || !bundle.parent) {
            var fn = new Function('require', 'module', 'exports', asset.generated.js);
            asset.isNew = !modules[asset.id];
            modules[asset.id] = [fn, asset.deps];
          } else if (bundle.parent) {
            hmrApply(bundle.parent, asset);
          }
        }

        function hmrAcceptCheck(bundle, id) {
          var modules = bundle.modules;

          if (!modules) {
            return;
          }

          if (!modules[id] && bundle.parent) {
            return hmrAcceptCheck(bundle.parent, id);
          }

          if (checkedAssets[id]) {
            return;
          }

          checkedAssets[id] = true;
          var cached = bundle.cache[id];
          assetsToAccept.push([bundle, id]);

          if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
            return true;
          }

          return getParents(global.parcelRequire, id).some(function(id) {
            return hmrAcceptCheck(global.parcelRequire, id);
          });
        }

        function hmrAcceptRun(bundle, id) {
          var cached = bundle.cache[id];
          bundle.hotData = {};

          if (cached) {
            cached.hot.data = bundle.hotData;
          }

          if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
            cached.hot._disposeCallbacks.forEach(function(cb) {
              cb(bundle.hotData);
            });
          }

          delete bundle.cache[id];
          bundle(id);
          cached = bundle.cache[id];

          if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
            cached.hot._acceptCallbacks.forEach(function(cb) {
              cb();
            });

            return true;
          }
        }
      },
      {},
    ],
  },
  {},
  ['../../../../../../.config/yarn/global/node_modules/parcel-bundler/src/builtins/hmr-runtime.js', 'index.js'],
  null
);
//# sourceMappingURL=/index.js.map
